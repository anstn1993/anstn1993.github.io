I"<p>앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘6장 코딩하는 동안 해야 할 일들’을 정리했습니다.</p>

<h1 id="6장-코딩하는-동안-해야-할-일들">6장. 코딩하는 동안 해야 할 일들</h1>

<hr />

<h3 id="31장-우연에-맡기는-프로그래밍">31장. 우연에 맡기는 프로그래밍</h3>

<p>우리는 항상 <strong>생각하면서</strong> 코드를 작성해야 합니다. 즉 그냥 되는대로 작성하면 안 된다는 건데요. 항상 코드를 그렇게 작성하는 의도가 명확해야 합니다. 생각 없이 작성한 코드가 잘 돌아간다면 그것은 그저 그 코드를 돌리는 순간 운이 좋아서 잘 돌아가는 것이라고 생각합시다. 즉, 언제라도 제대로 돌아가지 않을 수 있다는 것을 의미합니다.
그럼 의도적으로 프로그래밍한다는 것은 무엇일까요? 책에서는 다음과 같이 설명합니다.</p>

<ul>
  <li>자기가 무엇을 하고 있는지 알아야 한다.</li>
  <li>맹목적인 코딩을 하지 말자. 왜 그렇게 동작하는지 아는 애플리케이션만 빌드하거고 이해하고 있는 기술을 사용하자.</li>
  <li>코드를 작성하기 전에 계획을 세우고 진행하라.</li>
  <li>신뢰할 수 있는 것에만 기대라.</li>
  <li>자신의 가정을 문서로 남기고 그것을 통해 다른 사람들과 소통하라.</li>
  <li>자신이 세운 가정을 반드시 테스트해서 증명해라.</li>
  <li>우선순위를 정하고 중요한 것을 먼저 처리하라.</li>
  <li>기존의 코드가 미래에 짤 코드의 발목을 잡지 못하게 해라. 더 이상 적절한 코드가 아니면 과감하게 리팩토링하라.</li>
</ul>

<h3 id="32장-알고리즘의-속도">32장. 알고리즘의 속도</h3>

<p>프로그램을 만들 때 어떤 알고리즘이 사용하는 자원(시간, 프로세서, 메모리 등)을 추정하는 것이 중요할 때가 있습니다. 일반적으로 ‘big O’ 표기법을 통해 근사값을 추정할 수 있습니다. 이 표기법을 통해 우리가 작성한 코드의 차수를 추정해봅시다. 만약 코드만 봐서는 가늠이 되지 않는다면 입력 레코드의 수나, 그 외에 영향을 미칠 수 있는 요소를 바꾸어가면서 직접 실행해보면 됩니다. 몇 번만 실행해서 그래프를 그려본다면 대략적인 답이 나올 것입니다. 이 얘기의 연장으로, 코드만 보고 추정을 하는 것을 넘어서 실제 데이터를 입력받아서 돌아가는 코드의 수행시간이 진정으로 의미있는 수치입니다. O(n^2)이 O(nlogn)보다 수치상으로는 좋지 않지만 실제 코드가 수행되는 조건, 환경 하에서 수행시간이 전자가 더 짧다면 당연히 전자의 알고리즘을 채택하는 것이 맞습니다.</p>

<h3 id="33장-리팩터링">33장. 리팩터링</h3>

<p>코드는 생물과도 같습니다. 즉, 코드는 시간이 지나면 늘 문제에 직면하기 마련이고 그로 인해 항상 변하는 것이라는 사실을 명심하고 코드를 다시 작성하는 것에 대해 주저하지 맙시다. 중복, 성능, 유효기간이 끝난 지식, 직교적이지 않은 설계 등, 무슨 문제라도 생기면 바로 리팩터링을 해야 합니다. 사실 현실에서 일정의 압박 때문에 리팩터링을 하는 것이 쉽지는 않습니다. 결국 일정의 압박이 있다는 건 리팩터링을 할 시간까지는 고려하지 않았다는 것을 의미하는데, 이게 현재의 시점에서는 문제 없이 동작하는 것처럼 보이기 때문에 합리적인 판단이라고 생각할 수 있지만, 앞서 말했듯이 반드시 문제에 직면하게 된다는 것을 생각해보면 그렇게 합리적이라고 할 수 없습니다. 지금 당장 고치지 않아서 나중에 고치는 데 더 큰 비용이 들어갈 것이니까요. 그래서 책에서는 <strong>일찍, 그리고 자주 리팩터링하라</strong>고 조언합니다.
리팩터링은 아주 천천히, 신중하게 해야합니다. 마틴 파울러는 올바른 리팩터링을 위해 다음과 같은 조언을 했습니다.</p>

<ul>
  <li>리팩터링을 할 때 새로운 기능 추가는 하지 말자.</li>
  <li>리팩터링을 시작하기 전에 든든한 회귀 테스트 집합을 확보해야 한다. 그래야 리팩터링 과정에서, 그리고 리팩터링이 종료된 후에도 리팩터링 전과 같이 동작하는지 확인해볼 수 있다.</li>
  <li>단계를 나누어서 신중하게 작업한다. 대부분의 커다란 작업은 사실 작은 규모의 것들이 합쳐진 것이다. 한 단계가 마무리될 때마다 테스트를 돌려서 디버깅의 지옥에서 벗어나자.</li>
</ul>

<h3 id="34장-테스트하기-쉬운-코드">34장. 테스트하기 쉬운 코드</h3>

<p>역할이 명확히 분리되게끔 모듈을 나누면 각 모듈들에 대한 단위 테스트를 하기 쉬워집니다. 단위 테스트는 모듈들의 루틴을 호출해보면서 그 루틴들이 계약을 잘 지키는지 테스트하는 것을 말합니다. 이때 테스트는 작은 것에서부터 점점 큰 것으로 진행되어야 합니다. 가장 작은 단위의 모듈들이 탄탄하게 테스트되면 그 모듈들에 의존하고 있는 다른 모듈들을 테스트할 때 문제가 생기더라도 이미 테스트가 완료된 모듈들은 후보에서 과감하게 제외할 수 있기 때문입니다. 물론 테스트를 하는 것은 성가시고, 귀찮고, 시간도 더 많이 필요하지만, 그렇게 하지 않았을 때 미래에 문제가 터져버려서 어디서부터 디버깅을 해야할지도 감이 안 오는 상황을 피하기 위해서 꼭 해야만 합니다.
테스트 코드는 다음의 아주 귀중한 자원도 제공합니다.</p>

<ul>
  <li>모듈의 모든 기능을 어떻게 이용해야 하는지 보여주는 예제</li>
  <li>코드 변경시 검증하기 위한 회귀 테스트 구축 수단</li>
</ul>

<p>실제로 저도 작업을 하면서 코드 수정을 하고 작성해둔 모든 테스트 코드를 돌려봅니다. 돌려보고 모든 테스트가 통과하면 마음이 편해지고, 통과하지 못해도 좋습니다. 배포 전에 문제를 찾은 것이니까요.
책에서는 테스트를 위한 장치(도구)를 사용하라고 권장하는데요. 그 장치는 다음과 같은 기능이 있어야 합니다.</p>

<ul>
  <li>시작할 때 할 일과 마칠 때 할 일을 지정할 수 있는 표준적인 방법</li>
  <li>개별적인 테스트들을 선택하거나, 모든 테스트를 한꺼번에 선택하게 해주는 메서드</li>
  <li>예상한(또는 예상치 못한) 결과에 비추어 결과를 분석할 수 있는 방법</li>
  <li>실패를 보고하는 표준화된 형태</li>
</ul>

<p>자바에서는 이 모든 조건을 갖춘 도구로 JUnit을 많이 활용합니다. 저도 팀에서 테스트 코드를 Junit으로 작성하고 있습니다^^ 모든 코드에 대한 테스트 코드를 작성하지는 못하지만 그래도 작성하고나면 마음이 든든합니다. 어차피 프로그래머 자신, 혹은 팀에서 테스트를 하지 않으면 유저가 테스트를 하게 됩니다. 유저가 테스트하기 전에 먼저 테스트를 꼼꼼하게 진행해야겠습니다!</p>

<h3 id="35장-사악한-마법사">35장. 사악한 마법사</h3>

<p>오늘날 방대해진 애플리케이션을 빠르게 만들기 위해서 거의 대부분의 코드 골격을 대신 생성해주는 마법사 덕분에 우리는 정해진 시간 안에 서비스를 만들 수 있지만 마법사가 만든 코드를 이해하고 사용하는 것이 중요합니다. 그렇지 않으면 이는 우연에 맡기는 프로그래밍과 다를 게 없습니다. 마법사가 만들어준 코드가 지금 상황에 맞지 않으면 혼자 힘으로 코드를 바꿔야 하는데 기를 때 마법사의 코드를 이해하지 못하면 결국 마법사에게 끌려다니게 될 것입니다.</p>
:ET