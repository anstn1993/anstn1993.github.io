I"r<p>Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘3장 케이블의 앞은 LAN기기였다’를 정리했습니다.</p>

<h1 id="3장-케이블의-앞은-lan기기였다">3장. 케이블의 앞은 LAN기기였다.</h1>

<hr />

<p>3장에서는 케이블로 송출된 패킷이 리피터 허브, 스위치 허브, 라우터등의 네트워크 장비를 지나서 인터넷을 향해 진행하는 과정을 살펴봅니다.</p>

<h3 id="리피터-허브의-패킷-중계-동작">리피터 허브의 패킷 중계 동작</h3>

<p>LAN 어댑터에서 생성한 패킷의 신호는 RJ-45 커넥터를 통해 트위스트 페어 케이블(꼰 선쌍)을 타고 리피터 허브의 RJ-45 커넥터에 도달하게 됩니다. 그럼 리피터 허브는 LAN 전체에 신호를 전달하게 됩니다. 이는 같은 대역 내의 모든 기기에 패킷의 신호를 뿌리고 수신처 MAC 주소에 해당하는 기기만 패킷을 수신한다는 이더넷의 기본 원리를 그대로 실현한 것입니다.</p>

<p>리피터 허브의 내부 구성은 LAN 어댑터와 크게 다르지 않습니다. 각 케이블에 연결된 커넥터별로 PHY들이 존재하고 이 PHY들은 리피터 회로에 전부 연결되어 있습니다. 즉 한쪽으로 신호가 들어오면 PHY로 신호가 전달되고 이 신호를 리피터 회로로 보내서 나머지 PHY들로 전달되고 커넥터에서 나가게 되어 리피터 허브에 접속한 모든 기기에 도달합니다. 이때 리피터 회로는 신호가 잡음의 영향을 받아 변형된 것 같은 신호라도 그대로 흘려보냅니다. 신호의 변형 여부는 수신한 기기에서 디지털 신호로 변환된 패킷의 FCS를 검사하면서 파악하기 때문입니다.</p>

<p>신호를 받은 기기는 패킷의 MAC 헤더의 수신처 MAC 주소를 보고 자신에게 온 것이 아니면 파기하고 자신에게 온 것이면 수신합니다.</p>

<h3 id="스위칭-허브의-패킷-중계-동작">스위칭 허브의 패킷 중계 동작</h3>

<p>스위칭 허브는 리피터 허브처럼 연결된 모든 기기에 신호를 전달하기 않고 수신처 MAC 주소에 해당하는 기기에만 중계하도록 만들어져 있습니다. 그것이 가능하게 하기 위해서 스위칭 허브는 내부에 <strong>주소 테이블</strong>을 관리합니다.</p>

<p>스위칭 허브의 내부 또한 LAN 어댑터와 동일합니다. RJ-45커넥터로 신호를 받아서 PHY에서 공통의 신호 형식으로 변환해서 MAC 회로로 전달합니다. 여기서 디지털 데이터로 변환해서 패킷의 맨 끝에 있는 FCS를 대조해서 오류의 유무를 검사하고 이상이 없으면 메모리에 저장합니다. 이때 RJ-45 커넥터 안쪽의 회로 부분(PHY-MAC-메모리로 이어지는 회로)을 <strong>포트</strong>라고 부릅니다. 그래서 <strong>스위칭 허브의 포트는 PC의 LAN 어댑터와 거의 같습니다.</strong> 그런데 둘 사이에 한가지 차이가 있습니다. 스위칭 허브의 포트에는 MAC 주소가 할당되어 있지 않습니다. 스위칭 허브의 포트는 수신처 MAC 주소를 검사하지 않고 모든 패킷을 버퍼 메모리에 저장하기 때문입니다. 스위칭 허브는 이 검사 동작을 MAC 주소 테이블로 수행합니다. 버퍼 메모리에 저장된 패킷의 MAC 헤더에서 수신처 MAC 주소를 파악하고 MAC 주소 테이블에 등록이 되어있는지 확인합니다. 이 테이블에는 <strong>기기의 MAC 주소</strong>와 그 <strong>기기가 어느 포트에 연결되어있는지</strong>에 대한 정보가 등록되어 있습니다. 이를 통해 수신한 패킷을 어느 포트로 송신할지 판단합니다. 수신처 MAC 주소에 해당하는 포트를 찾았으면 스위치 회로를 경유하여 패킷을 송신측 포트로 보내게 됩니다. 포트가 패킷을 신호로 만들어서 케이블로 전달하는 과정은 LAN 어댑터의 송신 동작과 완전히 동일합니다.</p>

<p>이때 스위칭 허브에 리피터 허브가 접속되어 반이중 모드로 동작할 때를 가정해서 먼저 살펴보겠습니다. 이더넷의 규칙에 따라 송/수신 회로 중 수신 회로에 신호가 들어오지 않는지 확인합니다. 만약 누군가가 송신 중이라면 기다리고 송신 동작이 끝나거나 송신 동작이 일어나고 있지 않으면 송신을 합니다. 만약 송신 중에 다른 기기가 보낸 신호가 수신 회로로 들어오면 패킷 충돌이 발생하기 때문에 재밍 신호를 보내고 송신 동작을 일정 시간이 지난 후에 다시 시작합니다. 하지만 최근에는 PC나 라우터 같은 기기를 리피터 허브 없이 스위칭 허브에 직접 접속하는 것이 일반적이기 때문에 전이중 모드로 동작합니다. 이에 대해서는 뒤에서 살펴봅니다.</p>

<h4 id="mac-주소-테이블의-갱신-동작">MAC 주소 테이블의 갱신 동작</h4>

<p>스위칭 허브는 패킷 중계시 MAC 주소 테이블의 내용을 통해 중계 대상을 정한다는 것을 살펴봤습니다. 그런데 사실 내용을 갱신하는 동작도 함께 수행합니다. 패킷을 수신했을 때 송신처 MAC 주소를 조사해서 이것을 수신한 입력 포트의 번호와 세트로 테이블에 등록합니다. 왜냐하면 언젠간 송신처 MAC 주소가 수신처 MAC 주소가 될 것이기 때문입니다.</p>

<p>또한 반대로 테이블의 내용을 지우는 동작도 있습니다. 이는 스위칭 허브에 연결된 기기를 이동한 경우의 불편함을 방지하기 위함입니다. 예를 들면, 책상에 사용하고 있던 노트북 PC를 회의실로 가져가서 사용할 수 있는데, 그럼 스위칭 허브의 입장에서는 자신에게 접속 중이던 노트북이 사라진 것이기 때문에, 이 상태로 그 노트북으로 가야 할 패킷을 수신했을 때 연결이 끊긴 포트로 패킷을 보내게 됩니다. 즉 통신이 제대로 일어날 수 없는 상황을 막기 위해서 오래된 정보는 일정 시간이 경과하면 삭제합니다. 새롭게 이동한 회의실의 스위칭 허브의 입장에서도 아무 문제가 없습니다. 노트북이 신호를 전달하면 해당 노트북의 MAC 주소와 포트를 테이블에 등록할 것이기 때문입니다.</p>

<h4 id="예외적인-동작">예외적인 동작</h4>

<p>만약 스위칭 허브가 신호를 수신했을 때 MAC 주소 테이블에서 일치하는 행을 찾았는데 그 행의 송신 대상 포트가 신호를 수신한 포트와 같으면 어떻게 될까요? 이런 상황은 스위칭 허브에 리피터 허브가 접속된 경우 발생할 수 있는 예외적인 케이스 입니다. PC A와 PC B가 리피터 허브에 접속한 상태고 리피터 허브가 스위칭 허브에 접속한 상태라고 가정해보겠습니다. 이때 PC A가 패킷을 보내면 리피터 허브가 받게 되고 리피터 허브는 자신에게 연결된 모든 기기로 신호를 전달하기 때문에 PC B와 스위칭 허브에 신호가 전달됩니다. 그럼 스위칭 허브는 테이블에서 PC B의 MAC주소가 있는 행을 찾을 것이고 그 행은 자신이 수신한 포트인 것을 확인하고 패킷을 다시 리피터 허브로 반송하게 됩니다. 그럼 리피터 허브는 다시 신호를 PC B, PC A에 뿌리게 됩니다. 그럼 PC B는 동일한 패킷을 두번 받게 됩니다. 스위칭 허브는 이런 문제를 방지하기 위해서 <strong>패킷을 수신한 포트와 송신해야 하는 포트가 동일한 경우 패킷을 폐기</strong>합니다.</p>

<p>또 다른 예외적인 상황이 있습니다. MAC 주소표에 수신처 MAC 주소와 일치하는 주소가 등록되어 있지 않은 경우 입니다. 주소의 기기에서 패킷이 한 번도 도착한 적이 없거나 시간이 경과해서 MAC 주소표에서 삭제된 경우에 발생할 수 있습니다. 이 경우에는 리피터 허브처럼 모든 포트에 패킷을 송신해서 문제를 해결합니다. 그럼 대상 기기에서 응답이 돌아올 때 스위칭 허브의 MAC 주소 테이블에 등록이 될 것이고 그 다음부터는 대상 기기를 찾을 수 있게 됩니다. 만약 수신처의 MAC 주소를 브로드캐스트 주소로 설정해서 스위칭 허브로 전달해도 마찬가지로 해당 신호를 수신한 포트를 제외한 모든 포트로 패킷을 송신하게 됩니다.</p>

<h4 id="전이중-모드">전이중 모드</h4>

<p>앞서 살펴본 스위칭 허브의 송신 동작은 반이중 모드를 가정했습니다. 하지만 오늘날은 대부분이 전이중 모드로 동작하기 때문에 전이중 모드의 동작방식도 살펴보겠습니다. 스위칭 허브는 케이블의 신호선이 송신용, 수신용으로 분리되어 있습니다. 그래서 총/수신 과정에서 충돌이 발생하지 않습니다. 즉, 스위칭 허브의 포트 부분이나 LAN 어댑터에 있는 PHY회로와 MAC 회로의 내부도 송신 회로, 수신 회로가 나누어져 있고 신호가 따로 흘러서 충돌하지 않습니다.</p>

<p>충돌이 발생하지 않으니 반이중 모드의 충돌 방지 대책을 적용할 필요가 없고 그냥 송/수신 동작을 동시에 실행해도 상관없습니다. 그런데 기본적으로 이더넷에 신호가 흐르고 있을 때는 기다렸다가 송신 동작을 수행하기 때문에 <strong>이더넷의 규칙을 개정해서 신호가 흐르고 있어도 송신해도 좋다는 동작 모드를 새롭게 추가</strong>했습니다. 이 동작 모드로 동작할 때는 신호의 충돌을 검출하는 회로를 무효화하기로 했는데 바로 이것이 <strong>전이중 동작 모드</strong>입니다. 전이중 모드는 양방향 동시 송신이 가능해지기 때문에 당연히 반이중 모드보다 빠릅니다.</p>

<h4 id="자동-조정">자동 조정</h4>

<p>전이중 모드가 등장하면서 전이중 모드와 반이중 모드를 전환할 필요가 생겼습니다. 전이중 모드가 등장한지 얼마 안 된 시점에는 수동으로 동작 모드를 전환했지만 시간이 지나면서 자동으로 모드를 전환하는 기능이 나왔습니다. 접속한 상대가 전이중 모드를 지원하는지 검출하고 동작 모드를 자동으로 전환합니다. 그뿐만 아니라 상대의 전송 속도를 검출해서 전송 속도도 자동으로 전환하는데 이 기능을 <strong>자동 조정</strong>이라고 합니다.</p>

<p>접속한 상대가 어떤 모드를 지원하는지, 전송 속도는 어느 정도인지 검출하기 위해서 이더넷은 데이터 신호를 송신하지 않을 때는 <strong>링크 펄스</strong>라는 신호를 흘립니다. 이 신호를 통해 PHY 회로나 케이블에 이상이 없는지 파악할 수 있습니다. 이더넷의 기기의 커넥터 주변에 초록 LED 표시등이 붙어있는데 이를 통해 펄스형 신호가 흐르는지를 나타냅니다. 즉 이 초록 표시등이 잘 켜져있으면 문제가 없음을 의미합니다.</p>

<p>시간이 흐르면서 이 펄스 신호를 단순히 이상 유무 판단을 넘어, <strong>특정 패턴으로 송신</strong>하여 자신의 상황을 상대에게 전달하는 방법이 고안됩니다. 자동 조정 기능은 바로 이 패턴화된 송신 방식을 이용합니다. 패턴을 통해 지원 가능한 모드와 전송 속도를 서로에게 통지할 수 있고, 그 중 최적의 조합을 선택해서 모드와 전송 속도를 정하게 됩니다.</p>

<h3 id="라우터의-패킷-중계-동작">라우터의 패킷 중계 동작</h3>

<p>리피터 허브나 스위칭 허브를 경유한 패킷은 라우터에 도착하고 라우터에서 다음 라우터로 중계될 것입니다. 라우터의 중계 원리는 중계 대상을 등록한 라우팅 테이블로 판단한다는 점에서 스위칭 허브와 비슷합니다. 그러나 구체적인 동작에서 차이가 있는데 이는 라우터는 IP를, 스위칭 허브는 이더넷을 기반으로 동작하기 때문입니다.</p>

<p>라우터는 크게 <strong>중계 부분</strong>과 <strong>포트 부분</strong>으로 구성됩니다. 중계 부분은 라우팅 테이블을 통해서 패킷의 중계 대상을 판단하는 동작을 담당하고, 포트 부분은 패킷의 송/수신 동작을 담당합니다. 포트에는 다양한 통신 기술을 지원하는 하드웨어를 장착해서 통신 기술을 지원할 수 있습니다. 예를 들면 컴퓨터는 LAN 어댑터를 교환해서 이더넷뿐만 아니라 무선 LAN도 지원할 수 있듯이, 라우터의 포트 부분에 무선 LAN 용 하드웨어를 장착한 기종이라면 무선 LAN도 지원 가능합니다. 그 외에도 ADSL, FTTH 등의 광대역 회선이라 불리는 전용선 등의 통신 회선을 지원하는 하드웨어를 장착해서 해당 통신 기술을 지원할 수도 있습니다.</p>

<p>이제 좀 더 구체적인 동작을 살펴보겠습니다. 포트는 다양한 통신 기술의 규칙에 따라 송/수신하는데, 가장 일반적인 이더넷 통신 기술을 적용한 포트를 예로 들어서 보면 라우터의 <strong>포트에는 MAC 주소가 할당되어 이더넷의 송신처나 수신처</strong>가 됩니다. 포트에는 IP 주소도 할당되기 때문에 이런 측면에서도 LAN 어댑터와 같습니다. 패킷 중계시 포트는 수신처가 되어서 패킷을 수신하게 됩니다. 그리고 중계 부분이 중계 대상을 조사하면 이번에는 포트 부분이 송신처가 되어 이더넷의 패킷 송신 동작을 실행합니다. 이는 스위칭 허브와는 다른 동작 방식입니다. <strong>스위칭 허브는 들어온 패킷을 전달하기만 하지, 자기 자신이 송신처나 수신처가 되지는 않기 때문</strong>입니다.</p>

<h4 id="라우팅-테이블">라우팅 테이블</h4>

<p>이미 2장에서 라우팅 테이블에 대해서 살펴봤었습니다. 여기서는 좀 더 구체적으로 라우팅 테이블의 정보로 어떻게 중계 대상을 정하는지 살펴보겠습니다. 라우팅 테이블에는 수신처 주소, 넷마스크, 게이트웨이, 인터페이스, 메트릭이라는 주요 정보가 존재합니다. 수신처 주소로는 호스트 번호는 무시하고 네트워크 번호만 일치하는지 확인합니다. 주소의 네트워크 번호와 호스트 번호를 구분하는 역할을 넷마스크가 합니다. 이때 10.10.1.0/24, 10.10.2.0/24, 10.10.3.0/24라는 3개의 서브넷이 있다고 가정해보겠습니다. 그럼 이 3개를 모두 라우팅 테이블에 등록하는 것이 원칙이지만, 3개의 서브넷을 일괄적으로 통합한 10.10.0.0/16이라는 서브넷에 있다고 간주해서 하나의 서브넷만 등록을 해도 중계 동작은 정확하게 수행할 수 있습니다. 이렇게 라우팅 테이블에 등록하는 건수를 줄일 수 있는데 이것이 <strong>주소 집약</strong>입니다. 그런데 그 반대로 한 개의 서브넷을 세분화해서 등록하고 복수의 서브넷이 있는 것처럼 보이는 경우도 있습니다. 결국 넷마스크로 어떤 비트까지 비교의 대상으로 삼을지를 정하기만 하면 됩니다.
게이트웨이와 인터페이스는 패킷의 실제 중계 대상을 나타냅니다. 수신처와 넷마스크로 행을 찾았으면 그 행의 인터페이스(포트)에서 게이트웨이 항목에 등록된 IP 주소를 가진 라우터로 패킷을 중계합니다.
메트릭은 수신처 IP 주소에 기록된 목적지가 가까운지, 먼지를 나타냅니다. 값이 작을수록 가까이 있기에 가능하면 메트릭이 작은 행을 선택하는 것이 좋습니다.
참고로 라우터 테이블은 스위칭 허브와 달리 패킷 중계 동작에서 테이블을 갱신하는 동작을 수행하지 않습니다. 라우터는 사람이 수동으로 정보를 갱신하거나 라우팅 프로토콜(RIP, OSPF, BGP…)을 사용해서 라우터들끼리 경로 정보를 교환해서 자체적으로 갱신을 합니다.</p>

<h4 id="라우터의-패킷-중계-동작-1">라우터의 패킷 중계 동작</h4>

<p>라우터의 패킷 수신은 포트에서 시작되는데 포트는 이더넷 포트로 가정을 합니다. 이더넷 포트는 LAN 어댑터와 거의 같아서 패킷 수신부터 버퍼 메모리에 저장하는 부분까지 동일합니다.
수신이 끝났으면 MAC 헤더를 폐기하고 IP 헤더의 내용을 통해 패킷 중계 동작에 들어갑니다. 라우팅 테이블에서 중계 대상을 정하게 되는데 구체적인 예를 들어서 살펴보겠습니다. 10.10.1.101인 PC가 있고 이 PC가 192.168.1.10이라는 서버에 보낸 패킷이 현재 라우터에 들어왔다고 가정하겠습니다. 현재 라우터는 아래와 같은 테이블을 가지고 있습니다.</p>

<table>
  <thead>
    <tr>
      <th>수신처</th>
      <th>넷마스크</th>
      <th>게이트웨이</th>
      <th>인터페이스</th>
      <th>메트릭</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>10.10.1.0</td>
      <td>255.255.255.0</td>
      <td>…</td>
      <td>e2</td>
      <td>1</td>
    </tr>
    <tr>
      <td>10.10.1.101</td>
      <td>255.255.255.255</td>
      <td>…</td>
      <td>e2</td>
      <td>1</td>
    </tr>
    <tr>
      <td>192.168.1.0</td>
      <td>255.255.255.0</td>
      <td>…</td>
      <td>e3</td>
      <td>1</td>
    </tr>
    <tr>
      <td>192.168.1.10</td>
      <td>255.255.255.255</td>
      <td>…</td>
      <td>e3</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0.0.0.0</td>
      <td>0.0.0.0</td>
      <td>…</td>
      <td>e1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>라우팅 테이블에서 수신처 ip와 일치하는 네트워크 번호는 3행, 4행이 됩니다. 3행의 경우 넷마스크를 통해 왼쪽부터 24비트까지가 네트워크 번호이고 그럼 192.168.1이 네트워크 번호가 되기 때문입니다. 4행은 넷마스크를 통해 번호 전체가 네트워크 번호임을 알 수 있고, 수신처 IP와 완전히 동일한 것을 알 수 있습니다. 이렇게 후보가 여러개일 경우에는 <strong>최장 일치</strong>의 원칙에 따라 결정을 하게 됩니다. 일치하는 비트가 가장 긴 행을 찾는 것입니다. 3행은 24비트까지가 네트워크 번호이고, 8비트는 호스트 번호로 할당할 수 있는 반면, 4행은 32비트 전체가 네트워크 번호이기 때문에 그 자체가 서버가 됩니다. 즉 4행이 더 일치하는 비트가 길어지기 때문에 최종적으로 4행을 선택합니다.
네트워크 번호의 길이가 같으면서 일치하는 행이 복수로 존재할 수도 있습니다. 이는 라우터의 고장이나 케이블의 단선 등을 고려해 우회로를 둔 경우인데 이 경우에는 메트릭이 가장 작은 쪽으로 선택됩니다.
그럼 테이블에서 일치하는 행이 하나도 없으면 어떻게 될까요? 패킷을 폐기하고 ICMP 프로토콜로 송신처에 이 사실을 통지합니다. 이것이 스위칭 허브와 다른 점인데, 스위칭 허브는 테이블에 일치하는 행이 없으면 브로드캐스팅을 한다고 했습니다. 이런 차이가 있는 이유는 스위칭 허브와 라우터가 가정하는 네트워크의 규모가 차원이 다르기 때문입니다. 스위칭 허브는 한 대역 안에서 정말 많아봐야 수천대에 그치는 대상을 가정하지만, 라우터는 인터넷 전체를 대상으로 삼기 때문에 여기에 패킷을 브로드캐스팅하는 것은 네트워크에 엄청난 부하를 주게 됩니다.
그런데 사실 해당 경로가 없어도 별 문제가 되지 않습니다. 위에서 살펴본 테이블의 마지막 행이 테이블에 등록된 주소 이외의 나머지 전체를 의미하기 때문입니다. 마지막 행의 넷마스크는 0.0.0.0이라서 수신처 항목을 비교할 비트 수가 0입니다. 이 말은 결국 모든 주소에 대해서 일치함을 의미합니다. 그래서 중계 대상을 찾지 못하면 이 행에 등록된 게이트웨이 주소에 해당하는 라우터로 패킷을 중계합니다. 이 행은 <strong>기본 경로</strong>라고 하고 여기에 등록한 라우터를 <strong>기본 게이트웨이</strong>라고 합니다.</p>

<h4 id="패킷의-유효기간">패킷의 유효기간</h4>

<p>라우팅 테이블에서 중계 대상을 찾고 피킷을 출력 포트로 옮겨서 송신하는데, 그 전에 라우터가 하는 일은 패킷의 수명을 1씩 줄이는 일을 합니다. IP 헤더를 보면 TTL(Time To Live)라는 필드가 존재합니다. 라우터를 경유할 때마다 이 TTL이 1씩 줄어들다가 0이 되면 이 패킷의 수명이 다했다고 간주하고 더 이상 중계하지 않고 폐기합니다. 이 TTL의 최초 값은 OS별로 다르게 설정되지만 통상적으로 64나 128로 설정됩니다.
이렇게 패킷에 수명을 두는 이유는 라우팅 테이블 정보에 오류가 있거나 기기의 고장 등으로 인해 우회로로 전환될 때 일시적으로 패킷이 같은 라우터들을 순환해서 도는 사태를 막기 위함입니다.</p>

<h4 id="큰-패킷은-조각화하여-중계한다">큰 패킷은 조각화하여 중계한다</h4>

<p>라우터의 포트는 앞서 살펴봤듯이 이더넷뿐만 아니라 다양한 통신 기술을 지원합니다. 그 종류에 따라 패킷의 최대 길이가 달라져서 라우터 간의 포트 입력측과 출력측의 패킷 최대 길이가 다른 경우가 있습니다. 중계하는 <strong>패킷의 크기가 출력측의 패킷 최대 길이를 초과하게 되면 패킷을 조각화(fragmentation)해서 보내야</strong> 합니다.
패킷의 조각화는 IP 헤더의 필드들로 수행합니다. 우선 출력측 포트의 MTU를 조사해서 중계하는 패킷을 그대로 출력해서 송신할 수 있는지 조사합니다. 만약 MTU가 패킷의 크기보다 작으면 IP 헤더의 플래그 필드를 조사하여 조각화가 가능한지 살펴봅니다. 만약 송신처에서 조각화 불가 플래그를 설정해서 보냈으면 조각화가 불가능하기 때문에 패킷을 폐기하고 ICMP 프로토콜로 송신처에 통지를 합니다. 그렇지 않으면 이제 조각화를 시작합니다. 이때 TCP 헤더 이후의 부분을 분할 대상 데이터로 간주합니다. TCP 헤더도 IP 헤더 입장에서는 데이터이기 때문입니다. 그렇게 분할된 데이터에 IP 헤더를 모두 붙여줍니다. 이때 IP 헤더의 Identification 필드로 조각화된 패킷이 하나의 그룹임을 식별하고, offset 필드의 값으로 조각난 패킷의 순서를 식별할 수 있습니다.</p>

<h4 id="라우터의-송신-동작">라우터의 송신 동작</h4>

<p>TTL 체크와 패킷 조각화가 끝나면 라우터는 송신 동작을 수행합니다. 송신 동작은 포트의 통신 기술에 따라 달라지지만, 여기서는 이더넷 포트임을 가정해서 살펴보겠습니다. 이더넷의 패킷 송신 동작은 이더넷 규칙에 따라 동작하기 때문에 라우터라도 송신 동작은 앞서 살펴본 것과 동일합니다. MAC 헤더에 수신처 MAC 주소를 채우기 위해서 테이블의 게이트웨이 항목에서 중계 상대를 판단합니다. 만약 게이트웨이 항목에 IP 주소가 비어있으면 IP 헤더의 수신처 IP가 중계 대상이 됩니다. 이렇게 IP 주소를 정했으면 그 주소를 ARP 프로토콜에 세팅하여 수신처 MAC 주소를 구합니다. 그리고 송신처 MAC 주소는 출력 포트의 ROM에서 구하게 됩니다.
이렇게 MAC 헤더까지 붙여서 송신 패킷을 만들었으면 전기 신호로 변환해서 포트에서 송신합니다. 만약 반이중 모드라면 케이블에 신호가 흐르지 않는지 확인하고 송출하고, 전이중 모드면 그런 확인 없이 바로 송신합니다.
송신한 패킷은 스위칭 허브를 경유하여 다음 라우터에 도달합니다. 스위칭 허브는 패킷의 MAC 헤더에 설정된 수신처 MAC 주소를 보고 자신의 MAC 테이블과 대조해서 중계합니다.</p>

<h3 id="라우터의-부가-기능">라우터의 부가 기능</h3>

<p>라우터는 앞서 살펴본 기능 외에도 <strong>주소 변환</strong>과 <strong>패킷 필터링</strong>이라는 중요한 기능을 가지고 있습니다. 하나씩 살펴보겠습니다.</p>

<h4 id="주소-변환">주소 변환</h4>

<p>주소 변환 기능은 인터넷에 접속하는 기기의 수가 기하급수적으로 늘어나면서 그 기기들에 할당해줄 고유한 주소의 부족 문제를 해결하기 위해서 등장했습니다. 그래서 공인 IP, 사설 IP라는 개념이 등장했습니다. 예를 들어보겠습니다. A사와 B사가 있고 이 둘은 완전히 독립된 사내 네트워크를 각자 구축했습니다. 그럼 A사와 B사가 패킷을 주고받을 일이 없으니 A사의 서버에 할당한 주소와 같은 주소를 B사의 클라이언트에 할당해도 됩니다. 즉 네트워크 대역만 다르다면 그 대역 내의 서버에 할당하는 주소는 다른 대역의 서버에 할당하는 주소와 겹쳐도 상관이 없는 것입니다. 이게 사설 IP 입니다. 대신 두 네트워크 대역의 구분은 필요합니다. 이처럼 네트워크 대역 구분을 위한 주소가 공인 IP 입니다. 이렇게 주소를 관리하면 주소를 대폭 절약할 수 있게 됩니다.</p>

<p>사설 IP로 사용할 수 있는 주소의 범위는 아래와 같습니다.</p>

<ul>
  <li>10.0.0.0 ~ 10.255.255.255</li>
  <li>172.16.0.0 ~ 172.31.255.255</li>
  <li>192.168.0,0 ~ 192.168.255.255</li>
</ul>

<p>위 범위에 해당하는 주소는 각 네트워크 대역 안에서 자유롭게 할당해서 쓸 수 있습니다.</p>

<p>그런데 이런 네트워크 대역 안의 기기가 그 대역 안의 기기와만 통신을 하는 것은 아닙니다. 인터넷을 통해 다른 대역에 있는 기기와도 통신을 해야 하는데 그렇게 되면 주소의 충돌이 발생합니다. 바로 이 문제를 해결하기 위해서 라우터가 사설 IP를 공인 IP로, 또 공인 IP를 다시 사설 IP로 변환하는 주소 변환이라는 것을 수행하는 것입니다. TCP의 3-way-handshake를 통한 접속 동작시에 최초로 흐르는 패킷을 중계할 때 사설 IP로 기재된 송신처 IP 주소를 공인 IP로 바꿉니다. 이때 공인 IP는 라우터의 인터넷측에 연결된 포트에 할당된 주소입니다. 그리고 TCP 헤더의 포트 번호도 바꾸어 씁니다. 바꿀 포트 번호는 라우터가 미사용 번호 중에 적당한 것으로 바꿔줍니다. 이렇게 바꿀 때 기존 사설 IP주소와 포트 번호, 공인 IP주소와 바뀐 포트번호를 한 세트로 해서 대응표에 그록해둡니다. 이 대응표를 <strong>NAT 테이블</strong>이라고 합니다. 즉 패킷의 수신처는 사실 송신처의 공인 IP로만 식별을 할뿐 송신처의 사설 IP는 알지 못하는 셈입니다. 그럼 당연히 송신처가 패킷을 회신했을 때의 수신처 IP는 공인 IP로 되어있을 것이고 이것을 NAT 테이블에서 찾아서 다시 사설 IP와 원래 포트 번호로 바꿔서 실제 기기로 전달을 해주게 됩니다.</p>

<p>그럼 한 가지 의문이 생깁니다. 요청을 먼저 보내는 클라이언트는 패킷을 내보낼 때 NAT 테이블에 기록을 해둬서 응답을 받았을 때도 적절한 기기로 패킷을 전달해줄 수 있지만, 한번도 요청 패킷을 내보낸 적이 없는(즉 NAT 테이블에 기록을 해둔적이 없는) 서버로 어떻게 패킷이 정상적으로 운반될 수 있을까요? 원칙적으로 바깥으로 패킷을 내보낸 적이 없는 기기에 패킷을 전달할 수는 없습니다. NAT 테이블에 기록이 되어있지 않기 때문이죠. 하지만 수동으로 NAT 테이블에 기록을 해뒀으면 가능합니다. 그럼 사설 IP가 할당된 서버에도 요청을 전달할 수 있게 됩니다. 공인 IP 주소에 물린 포트번호에 대응되는 사설 IP 주소와 포트번호를 NAT 테이블에 등록해두면 그 공인 IP주소와 포트번호로 요청이 오면 사설 IP로 패킷을 전달해줄 수 있습니다. 이런 것을 <strong>포트 포워딩</strong>이라고 합니다.</p>

<h4 id="라우터의-패킷-필터링">라우터의 패킷 필터링</h4>

<p>패킷 필터링은 패킷을 중계할 때 MAC 헤더, IP 헤더, TCP 헤더에 기록되어 있는 내용을 조사해서 그것이 사전에 설정한 조건에 합치되는 경우에만 패킷을 중계하는 것을 말합니다. 대부분의 방화벽 기기나 소프트웨어는 이 원리로 부정 침입을 방지합니다. 패킷 필터링은 원리는 간단하지만 필터링 조건을 설정하는 것이 간단하지 않습니다. 이와 관련해서는 서버의 동작에서 자세히 살펴보겠습니다.</p>
:ET