I"[<p>Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘2장 TCP/IP의 데이터를 전기 신호로 만들어 보낸다’를 정리했습니다.</p>

<h1 id="2장-tcpip의-데이터를-전기-신호로-만들어-보낸다">2장. TCP/IP의 데이터를 전기 신호로 만들어 보낸다.</h1>

<hr />

<p>2장에서는 프로토콜 스택이 패킷을 생성하고 LAN 어댑터에 넘긴 후, LAN 어댑터가 패킷을 디지털 데이터에서 전기 신호로 변환해서 케이블에 송출하는 순간까지 탐험합니다.</p>

<h3 id="프로토콜-스택의-내부-구성">프로토콜 스택의 내부 구성</h3>

<p>프로토콜 스택이 무슨 일을 하는지 보기에 앞서 프로토콜 스택이 어떻게 구성되어있는지 보겠습니다. 프로토콜 스택은 <strong>TCP, UDP, IP</strong>로 구성됩니다. 계층적으로 TCP, UDP가 IP보다 상위 계층으로, TCP, UDP가 애플리케이션에서 보낸 의뢰를 받아서 <strong>데이터의 송수신</strong>을 담당하고, 그 아래의 IP 프로토콜을 사용해서 <strong>패킷의 송수신</strong> 동작을 제어하게 됩니다. IP 안에는 ARP, ICMP 같은 프로토콜을 다루는 부분도 포함되어있는데, 자세한 건 뒤에서 살펴보겠습니다.</p>

<h3 id="소켓은-통신-제어용-제어-정보다">소켓은 통신 제어용 제어 정보다</h3>

<p>소켓은 프로토콜 스택이 통신 동작을 수행하기 위해서 필요한 제어 정보(수신처 IP 주소, 포트 번호, 통신 동작의 진행 상태 등..)를 의미합니다. 혹은 이런 제어 정보를 저장하는 프로토콜 스택 내부의 메모리 영역이 소켓이라고 생각해도 무방합니다. 프로토콜 스택은 이 소켓의 정보를 참조하면서 동작합니다.</p>

<p><code class="language-plaintext highlighter-rouge">netstat</code> 커맨드를 사용하면 소켓의 내용을 살펴볼 수 있습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netstat <span class="nt">-an</span>
Active Internet connections <span class="o">(</span>including servers<span class="o">)</span>
Proto  Local Address          Foreign Address        <span class="o">(</span>state<span class="o">)</span>
tcp4  192.168.0.10.49809     142.251.42.206.443     ESTABLISHED
tcp4  192.168.0.10.49804     172.217.25.99.443      ESTABLISHED
tcp46  <span class="k">*</span>.80                   <span class="k">*</span>.<span class="k">*</span>                    LISTEN
tcp46  <span class="k">*</span>.443                  <span class="k">*</span>.<span class="k">*</span>                    LISTEN
tcp4   <span class="k">*</span>.3306                 <span class="k">*</span>.<span class="k">*</span>                    LISTEN
</code></pre></div></div>

<p>Local Address는 로컬 ip주소와 포트 번호를 표시하고 Foreign Address는 통신 상대의 ip주소와 포트 번호를 나타냅니다. 192.168.0.10라는 ip를 할당한 LAN 어댑터를 사용해서 원격측과 통신을 하고 있습니다. state가 ‘ESTABLISHED’인 것을 통해 원격측과 접속이 끝나고 통신을 하고 있음을 의미하고, 그 중에서도 로컬측의 포트번호가 49809번인 프로세스가 142.251.42.206 ip주소를 가진 상대측의 443번 포트를 사용하는 프로세스와 통신을 하고 있고 포트번호가 49804번인 프로세스가 172.217.25.99 ip 주소를 가진 상대측의 443번 포트를 사용하는 프로세스와 통신을 하고 있습니다.
state가 ‘LISTEN’인 경우는 아직 상대의 접속을 기다리고 있음을 의미합니다. 로컬측, 원격측의 ip주소가 명확히 지정되지 않은 이유는 아직 통신이 시작되지 않았기 때문입니다. 만약에 로컬 주소에 ip 주소를 지정해주면, 그건 해당 ip 주소의 LAN 어댑터로만 요청을 처리하겠다는 것을 의미합니다. 보통 복수의 LAN 어댑터를 장착하고 있는 서버에서 접속 동작을 특정 LAN 어댑터로만 제한하려고 할 때 사용합니다.</p>

<h3 id="프로토콜-스택이-하는-일">프로토콜 스택이 하는 일</h3>

<p>이제 애플리케이션이 소켓 라이브러리의 루틴을 호출했을 때 프로토콜 스택이 실제로 하는 일을 살펴봅니다.</p>

<h4 id="socket을-호출했을-때-프로토콜-스택이-하는-일">socket()을 호출했을 때 프로토콜 스택이 하는 일</h4>

<p>소켓의 제어 정보를 저장하기 위한 메모리 공간을 할당받습니다. 이 시점은 아직 송/수신 동작이 시작되지 않은 초기상태이기 때문에 제어 정보를 소켓의 메모리 영역에 기록해둡니다. 이렇게 소켓이 만들어지면 소켓 식별자인 디스크립터를 반환해줍니다.
애플리케이션은 이 디스크립터를 이후의 동작 의뢰시에 함께 전달해서 프로토콜 스택이 어떤 소켓에 대해서 작업을 해야할지 결정할 수 있습니다.</p>

<h4 id="connect를-호출했을-때-프로토콜-스택이-하는-일">connect()를 호출했을 때 프로토콜 스택이 하는 일</h4>

<p>만들어둔 소켓을 통신 대상 서버측 소켓에 접속합니다. 제어 정보를 의미하는 물리적 실체가 없는 소켓에 접속이라는 단어가 사용되어서 다소 모호하게 느껴진다면 접속 대신 ‘준비’라고 생각해도 좋습니다. 그럼 무엇을 준비해야 할까요? 크게 두가지가 있습니다.
하나는 클라이언트와 서버가 서로의 <strong>제어정보</strong>를 교환하는 것입니다. 제어정보는 <strong>패킷의 헤더</strong>를 의미합니다. 헤더는 실제 요청 데이터의 앞쪽에 붙는 정보로, TCP, IP, 이더넷의 제어정보가 순차적으로 붙게 됩니다. 이 헤더는 항상 고정되어있기 때문에 접속단계뿐만 아니라 데이터를 송/수신할 때, 연결을 끊을 때와 같이 클라이언트와 서버가 통신을 할 때는 항상 헤더에 명시된 정보를 토대로 이루어집니다. 접속단계에서는 아직 데이터의 송/수신이 이루어지지 않기 때문에 이때 주고받는 패킷은 헤더(제어정보)로만 이루어져있습니다. 프로토콜 스택이 처음에 소켓을 생성한 직후에는 통신 상대에 대한 정보가 존재하지 않습니다. 그래서 접속 단계에서 애플리케이션이 통신 대상에 대한 정보를 connect()의 인자로 함께 전달합니다. 그럼 프로토콜 스택은 제어정보(ip주소, 포트번호 등..)를 담은 헤더로만 구성된 패킷을 서버로 보내게 됩니다. 클라이언트의 제어정보를 받은 서버도 클라이언트의 정보를 알 수 있게 되고 비로소 통신을 할 준비가 끝나게 됩니다.
다른 하나는 송/수신하는 데이터를 일시적으로 저장할 버퍼 메모리를 확보하는 것입니다.
위 두가지 준비가 끝나면 접속이 됐다고 이해하면 됩니다.</p>

<p>그럼 데이터의 송/수신을 위해 무엇을 준비해야하는지 알았으니 그 중에서도 클라이언트와 서버가 제어정보(헤더만으로 구성된 패킷)를 어떻게 교환하는지 구체적으로 살펴보겠습니다.</p>

<p><img src="https://user-images.githubusercontent.com/56672937/151005977-df270e91-1e6b-4bc6-8fa6-174c98a1c008.png" /></p>

<ul>
  <li>
    <p>프로토콜 스택의 TCP가 데이터 송/수신 동작의 개시를 나타내는 제어 정보를 기록한 TCP 헤더를 생성합니다. 이 헤더에 세팅하는 주요 값들은 <strong>송신처(클라이언트)의 포트 번호</strong>, <strong>수신처(서버)의 프토 번호</strong>, 그리고 컨트롤 비트 중 <strong>SYN 비트를 1로</strong> 설정합니다. SYN는 Sync의 약어로 상대방과 연결을 시작할 때 설정하는 비트입니다. 즉 연결을 통해 상대방과 동기화를 하겠다는 의미로 이해하면 됩니다. 사실 이때 헤더에 <strong>시퀀스 번호와 윈도우</strong>라는 값도 함께 설정해서 보내게 되는데 이건 뒤에서 살펴보겠습니다. 이렇게 TCP가 만든 패킷을 IP에게 건네주면 송신 동작을 실행해서 서버로 패킷을 전달합니다. IP가 패킷을 송신하는 동작은 뒤에서 구체적으로 살펴보겠습니다.</p>
  </li>
  <li>
    <p>서버가 패킷을 받으면 서버의 프로토콜 스택의 IP가 패킷을 TCP로 전달해줍니다. 그럼 패킷의 헤더를 조사해서 수신처 포트번호를 보고 그 번호에 해당하는 소켓을 찾고 그 소켓에 클라이언트의 제어 정보를 기록하고 접속 동작이 진행중이라는 상태로 바뀝니다. 그리고 서버의 TCP가 클라이언트에 응답을 해주게 됩니다. 이때 TCP 헤더에 <strong>SYN 컨트롤 비트와 ACK 컨트롤 비트를 1로</strong> 만듭니다. 서버도 클라이언트와 연결을 하겠다는 의미에서 <strong>SYN 비트를 시퀀스 번호, 윈도우와 함께 설정</strong>합니다. ACK는 Acknowledgement의 약어로 클라이언트의 SYN 요청 패킷을 잘 전달받았고 그것을 승인하겠다 의미를 지닙니다. 이때 ACK 번호도 헤더에 함께 세팅해서 보내게 되는데 이는 뒤에서 살펴보겠습니다. 이렇게 세팅된 TCP 헤더를 IP에 전달하여 클라이언트에 응답하게 됩니다.</p>
  </li>
  <li>
    <p>응답을 받은 클라이언트는 마찬가지로 IP에서 TCP로 패킷이 흘러가게 되고 서버측이 ACK 컨트롤 비트를 1로 설정했는지 확인해서 접속 동작이 성공했는지 확인합니다. 성공했으면 서버의 제어정보를 소켓에 저장하게 됩니다. 여기서 끝나지 않고, 클라이언트에서 서버쪽에 TCP 헤더의 <strong>ACK 컨트롤 비트를 1로</strong> 세팅해서 ACK 번호와 함께 한 번 더 패킷을 응답합니다. 서버쪽에도 클라이언트가 패킷을 잘 받았음을 알리기 위함입니다.</p>
  </li>
</ul>

<p>여기까지가 접속 동작의 구체적인 플로우입니다. 접속 동작에서 클라이언트와 서버 사이에서 3번의 패킷이 오가는데 이런 연결 동작을 <strong>3-way-handshake</strong>라고 합니다. 이제 서버와 클라이언트의 소켓은 데이터를 송/수신할 수 있는 상태입니다. 이런 걸 비유적인 표현으로 <strong>두 소켓이 파이프로 연결됐다</strong>고 하기도 합니다. 저 파이프를 <strong>커넥션, 세션</strong>이라고 하기도 합니다. 이는 네트워크에서 자주 등장하는 용어들이기 때문에 이런 용어들을 마주하면 양쪽의 소켓이 서로의 제어정보를 가지고 통신을 할 수 있는 상태라고 이해하면 될 것 같습니다.</p>

<h4 id="write를-호출했을-때-프로토콜-스택이-하는-일">write()를 호출했을 때 프로토콜 스택이 하는 일</h4>

<p>클라이언트가 서버에 접속했다면 이제 데이터를 송/수신해야 합니다. 먼저 송신을 위해 write()를 호출하면 프로토콜 스택은 전달받은 <strong>데이터를 송신용 버퍼 메모리에 저장하고 애플리케이션이 다음 데이터를 전달해주기를 기다립니다.</strong> 바로 전달을 하지 않는 이유는 한번 패킷을 보낼 때 최대한 많은 양의 데이터를 담아서 보내기 위함입니다. 애플리케이션별로 프로토콜 스택에 전달하는 데이터의 길이는 저마라 다르기 때문에 어떤 애플리케이션은 전체 데이터를 한번에 전달할 수도 있고 어떤 애플리케이션은 1바이트씩 쪼개서 전달할 수도 있습니다. 이는 프로토콜 스택에서 제어할 수 없는 것입니다. 만약 전체 데이터를 너무 작은 단위로 쪼개서 송신 의뢰를 할 때 버퍼에 쌓아두지 않고 매번 실제로 패킷을 보내버리면 네트워크의 효율이 저하되기 때문에 기다리는 것입니다. 이때 프로토콜 스택은 한 패킷에 저장할 수 있는 데이터의 최대 크기인 MTU(Maximum Transmission Unit)라는 매개변수를 기준으로 실제 전송 동작을 수행할 타이밍을 잡습니다. 보통 이더넷에서는 1500바이트가 됩니다. 여기서 헤더를 제외해야 실제로 전송할 수 있는 데이터의 최대 크기가 나오는데 이것을 MSS(Maximum Segment Size)라고 합니다. 보통 TCP, IP 헤더를 합치면 40바이트가 되기 때문에 MSS는 일반적으로 1460바이트가 됩니다. 애플리케이션에게 받은 데이터의 크기가 MSS를 초과하거나 MSS에 가까운 크기가 됐을 때 송신 동작을 수행하면 효율이 높은 송신을 수행할 수 있는 것입니다.
하지만 데이터의 크기에만 의존해서 송신 동작을 수행할 타이밍을 잡으면 안 됩니다. 애플리케이션의 송신 속도가 느려서 MSS에 가깝게 데이터를 송신 버퍼에 쌓는 시간이 오래 걸릴 수도 있기 때문입니다. 그래서 프로토콜 스택은 내부적으로 <strong>타이머를 두고 일정 시간이 경과하면 데이터가 MSS에 미치지 못하더라도 패킷을 송신</strong>합니다.
프로토콜 스택에는 이렇게 상충되는 송신 동작의 판단 요소를 적절하게 절충해서 송신 동작을 언제 수행할지 판단하게 됩니다. 이때 두 판단 요소를 어떻게 절충할지에 대한 명확한 규정이 없기 때문에 이는 전적으로 프로토콜 스택을 개발하는 개발자에게 달려있습니다.
이때 송신 타이밍을 애플리케이션이 제어하게 할 수도 있습니다. write()를 호출할 때 송신 버퍼에 쌓아두지 말고 바로 전송하라는 옵션을 전달하면 프로토콜 스택은 바로 송신 동작을 수행합니다. 보통 브라우저 같이 대화형 애플리케이션이 서버에 메시지를 보낼 때 버퍼에 머무는 시간만큼 응답 지연이 발생하기 때문에 이런 옵션을 많이 사용할 것입니다.</p>

<p>그럼 반대로 데이터가 MSS를 초과하는 크기를 가진 경우는 어떻게 될까요? 이때는 MSS를 초과하기 때문에 바로 송신 동작에 들어가는데 데이터를 MSS 크기에 맞게 분할해서 송신 버퍼에 저장합니다. 그럼 분할된 각각의 데이터 조각들에 TCP 헤더를 붙이고 조각별로 IP에게 건네서 송신 동작을 수행합니다. 이때 조각화된 패킷들이 서버에 도착하면 그 패킷들의 데이터를 다시 완결된 형태로 합칠 수 있어야 합니다. 이렇게 조각화된 데이터를 합칠 수 있는 단서들은 IP 헤더에 기록되어있고 이는 뒤에서 자세히 살펴보겠습니다.</p>

<p>TCP 통신은 데이터의 송신만 하고 끝나지 않습니다. 항상 상대방에게 송신한 패킷이 잘 도착했는지 <strong>확인하는 동작</strong>을 수행해서 도착하지 않았으면 다시 송신해서 <strong>신뢰성을 보장</strong>합니다. 이 확인 동작은 TCP 헤더의 <strong>시퀀스 번호</strong>와 <strong>ACK 번호</strong>를 통해서 하게 됩니다.
시퀀스 번호는 송신 데이터의 일련번호로 데이터 조각을 송신할 때 각 패킷의 맨 앞 위치의 데이터가 전체 데이터의 몇번째 바이트인지를 송신측에서 수신측으로 전달하기 위한 값입니다. ACK 번호는 수신 데이터의 일련번호로 수신측이 전체 데이터 중 몇바이트까지 수신했는지를 송신측에 전달하기 위한 값입니다. 구체적인 예로 살펴보겠습니다. 클라이언트에서 데이터를 1460바이트(MSS)로 조각화해서 여러 패킷을 전달한다고 가정하겠습니다. 그리고 초기 시퀀스 번호 1이라고 가정하겠습니다. 이 초기 시퀀스 값은 연결시점에 3-way-handshake에서 클라이언트가 SYN 컨트롤 비트를 1로 설정해서 패킷을 전송할 때 설정하게 됩니다. 참고로 이 시퀀스 번호는 항상 랜덤하게 생성됩니다. 시퀀스 번호가 고정되면 시퀀스 번호를 예측할 수 있게 되기 때문에 악의적인 공격이 발생할 수 있기 때문입니다.</p>

<p><img src="https://user-images.githubusercontent.com/56672937/151006334-6a0b33d8-aae6-485e-87b4-84c5f029c322.png" /></p>

<p>이제 클라이언트에서 시퀀스 번호를 1로 설정해서 서버로 첫번째 조각 패킷을 보내겠습니다. 그럼 서버는 데이터의 크기를 계산해서 1460바이트인 것을 확인하고 시퀀스 번호에 데이터 크기만큼 더한 1461로 ACK 번호를 세팅해서 클라이언트로 응답하게 됩니다.(ACK 컨트롤 비트도 1로 세팅) 이때 서버는 다음 패킷의 시퀀스 번호가 1461번일 것으로 기대하게 됩니다. 그럼 클라이언트는 다음 시퀀스 번호를 서버에게 받은 ACK 번호인 1461로 설정하고 다시 전송합니다. 그럼 서버는 ACK 번호를 시퀀스 번호에 데이터 크기만큼 더한 2921로 설정해서 응답합니다. 이렇게 응답측에서 ACK 번호를 돌려주는 것을 <strong>수신 확인 응답</strong>이라고 합니다. 즉, 송신측의 시퀀스 번호와 응답측의 ACK 번호는 계속 동기화되는 것입니다. 이를 통해 패킷의 누락을 검출할 수 있습니다. 가령 서버가 응답한 ACK 번호가 1461인데 그 다음 전달된 패킷의 시퀀스 번호가 2921이면 패킷이 누락되었음을 알 수 있기 때문입니다.
지금까지 살펴본 과정은 클라이언트에서 서버로만 패킷을 전달하는 흐름만 고려한 것인데 사실 서버에서 클라이언트로 패킷을 전달하는 흐름에서도 이런 과정은 동일하게 일어납니다. 서버에서 클라이언트에게 응답 데이터를 생성해서 보내면 클라이언트도 마찬가지로 ACK 번호를 산출해서 서버에 전달하게 됩니다.</p>

<p>그럼 시퀀스 번호와 ACK 번호를 중점으로 클라이언트와 서버의 연결부터 데이터 송/수신을 다시 한번 살펴보겠습니다.</p>

<ol>
  <li>
    <p>연결 동작</p>

    <ul>
      <li>클라이언트는 SYN비트를 1로 설정하고 시퀀스 번호 초기값을 서버에 전송</li>
      <li>서버는 SYN, ACK 비트를 1로 설정하고 ACK 번호와 시퀀스 번호 초기값을 클라이언트로 전송</li>
      <li>클라이언트는 ACK 비트 1로 설정하고 ACK 번호를 서버로 전송</li>
    </ul>
  </li>
  <li>
    <p>송/수신 동작</p>
    <ul>
      <li>클라이언트는 서버로 데이터와 함께 시퀀스 번호를 전송</li>
      <li>서버는 ACK 번호를 클라이언트로 전송</li>
      <li>서버는 응답 데이터와 함께 시퀀스 번호를 전송</li>
      <li>클라이언트는 ACK 번호를 서버로 전송</li>
    </ul>
  </li>
</ol>

<p>이처럼 클라이언트건, 서버건 서로가 보낸 패킷의 시퀀스 번호를 확인하고 ACK 번호를 반환합니다. 이때 클라이언트, 서버 모두 <strong>ACK 번호를 확인하기 전까지는 송신용 버퍼 메모리에 송신한 패킷을 보관</strong>합니다. 송신한 데이터에 대응하는 ACK 번호가 돌아오지 않으면 동일한 패킷을 다시 보내기 위함입니다. TCP는 이런 방식으로 신뢰성을 보장합니다. 그리고 TCP의 이런 동작 덕분에 LAN 어댑터, 버퍼, 라우터, 애플리케이션 모두 오류가 발생해도 회복 조치를 취하지 않습니다.</p>

<p>TCP가 오류를 검출하고 회복하는 과정을 좀 더 구체적으로 살펴보겠습니다. 가장 중요한 것은 ACK 번호가 돌아오는 것을 기다리는 대기시간(타임아웃)을 적절하게 설정하는 것입니다. 네트워크가 혼잡한 상황이면 ACK 번호 응답이 지연되기 때문에 대기시간을 넉넉하게 잡아야 합니다. 그렇지 않으면 ACK 번호가 돌아오기 전에 패킷을 다시 보내게 됩니다. 이는 불필요한 패킷 전송으로 인해 네트워크를 더 혼잡하게 만듭니다. 하지만 반대로 대기시간이 너무 길어도 정말 패킷을 다시 보내야 하는 상황에서 패킷을 다시 보내는 동작에 지연이 발생합니다. 하지만 서버와 클라이언트의 거리, 네트워크의 혼잡도 등의 다양한 변수 때문에 적절한 대기시간을 정하는 것은 매우 어려운 일입니다. 그래서 TCP는 대기시간을 동적으로 변경하는 전략을 취하고 있습니다. TCP는 데이터 송신 동작을 할 때 항상 ACK 번호가 돌아오는 시간을 항상 기록해두고, ACK 번호가 돌아오는 시간이 기록해둔 시간보다 지연되면 대기 시간도 늘리게 됩니다. 반대로 더 빨리 도착하면 대기시간을 짧게 설정합니다.</p>

<p>TCP는 윈도우 제어를 통해 ACK 번호가 돌아올 때까지 기다리는 시간 낭비를 줄입니다. 윈도우 제어 방식은 응답측에서 ACK 번호를 받기 전까지 기다리지 않고 보내야 하는 패킷을 계속 보내게 됩니다. 아주 효율적인 방식이지만 <strong>송신측의 패킷 전송 속도가 수신측의 수신 버퍼 처리 속도보다 빨라져서 수신 버퍼의 용량이 초과</strong>하는 문제가 발생할 수 있습니다. 이 문제를 해결하기 위해서 <strong>TCP 헤더의 윈도우 필드</strong>를 사용합니다.</p>

<p><img src="https://user-images.githubusercontent.com/56672937/151006561-f90a964e-c265-4717-a045-04cafbb2449c.png" /></p>

<p>윈도우 필드는 수신측의 수신 버퍼의 여유 공간을 담습니다. 수신측이 송신측에 수신 가능한 데이터의 양을 윈도우 필드에 세팅해서 통지하면 송신측은 수신측 버퍼에 공간이 얼마나 남았는지 알고, 자신이 패킷을 보낼때마다 데이터의 크기도 알기 때문에 스스로 계산을 해서 수신측 버퍼의 여유공간이 0이 되는 순간에 송신을 중단하게 됩니다. 수신측은 수신처리가 끝나서 수신 버퍼에 여유 공간이 생기면 다시 윈도우 필드를 세팅해서 송신측에 알리게 되고 송신측은 다시 패킷을 전송하기 시작합니다. 이렇게 해서 수신 버퍼의 용량 초과 없이 데이터를 전송할 수 있게 됩니다.</p>

<p>그런데 수신측의 입장에서 한가지 고려해야 할 것이 있습니다. 위의 그림에서는 수신측이 송신측에 윈도우 통지를 하는 플로우만 표현했지만 사실 송신측으로부터 받은 패킷에 응답하는 ACK 번호 통지도 함께 일어나게 됩니다. 그럼 효율성을 높이려면 왼도우와 ACK번호를 통지하는 타이밍을 잘 잡아야 합니다. 윈도우가 송신측으로 통지되는 타이밍은 수신측에서 애플리케이션에 데이터를 건네주고 수신 버퍼의 빈 영역이 늘어났을 때입니다. ACK 번호가 송신측으로 통지되는 타이밍은 데이터를 받았을 때 내용을 조사해서 정상 수신을 확인할 수 있는 경우 입니다. 다시 말해 데이터를 수신한 후 즉시 보내게 됩니다. 개념적으로만 보면 ACK 번호를 먼저 통지하고, 애플리케이션에 데이터를 전달해준 후 윈도우를 통지하는 게 맞지만, 이 둘을 따로따로 통지하는 건 비효율적입니다. 그래서 ACK 번호나 윈도우를 통지할 때 바로 보내지 않고 잠시 기다렸다가 다음 통지가 발생할 때 두 통지를 하나의 패킷으로 묶어서 보냅니다. 예를 들면 ACK번호 송신 대조를 하는 시점에 윈도우 통지도 발생하면 ACK번호와 윈도우를 하나의 패킷으로 묶어서 보내주는 것입니다. 또한 ACK 번호 통지가 연속해서 일어난 경우에도 마지막 통지만 해주면 됩니다. 윈도우 통지도 마찬가지입니다. 애플리케이션에 데이터를 전달하는 동작이 여러번 일어난다 하더라도 가장 마지막 통지 시점에 수신 버퍼 크기만 알려주면 됩니다.</p>

<h4 id="read를-호출했을-때-프로토콜-스택이-하는-일">read()를 호출했을 때 프로토콜 스택이 하는 일</h4>

<p>애플리케이션이 write()로 송신 동작을 의뢰했으면 read()를 호출하여 응답 메세지 수신을 프로토콜 스택에 의뢰합니다. 수신 데이터는 앞서 살펴본 수신 버퍼에 쌓이게 됩니다. 송신을 하자마자 수신이 되지는 않기 때문에 프로토콜 스택은 수신버퍼에 데이터가 쌓일 때까지 대기를 합니다. 대기를 하는동안 프로토콜 스택은 다른 작업을 수행하다가 패킷이 도착하면 작업을 다시 시작합니다. 수신한 데이터 조각과 TCP 헤더의 내용(시퀀스 번호와 ACK 번호)을 조사해서 데이터 누락이 되지 않았는지 검사합니다. 문제가 없으면 ACK 번호를 반송합니다. 그리고 데이터 조각은 수신 버퍼에 TCP가 설정한 시간만큼 보관하고 쌓인 조각들을 복원하여 애플리케이션에 건내줍니다. 이후 통지 타이밍을 가늠해서 윈도우를 송신측에 통지합니다.</p>

<h4 id="close를-호출했을-때-프로토콜-스택이-하는-일">close()를 호출했을 때 프로토콜 스택이 하는 일</h4>

<p>송/수신 동작까지 끝나면 애플리케이션은 close()를 호출하여 프로토콜 스택에게 연결 끊기 동작에 들어가게 됩니다. 연결 끊기 동작은 송신을 완료한 쪽에서 하게 됩니다. 어디에서 송신을 완료하는지는 애플리케이션마다 다르지만 웹의 경우에는 서버가 요청에 응답하면서 데이터의 송신이 완료되기 때문에 서버에서 연결 끊기에 들어갑니다. 그런데 이건 HTTP 1.0에 해당하는 내용이고 HTTP 1.1에서는 클라이언트가 하나의 소켓으로 계속해서 요청 메시지를 보낼 수 있기 때문에 더 이상 보낼 요청이 없다고 판단하는 순간 클라이언트에서 먼저 끊기 단계에 돌입할 수도 있습니다. 이 장에서는 서버가 연결 끊기를 시작하는 것으로 살펴보겠습니다.</p>

<p><img src="https://user-images.githubusercontent.com/56672937/151006774-b254bf09-f6fd-4a71-93b6-5d45e76908cb.png" /></p>

<p>서버측의 프로토콜 스택이 TCP 헤더의 FIN 컨트롤 비트를 1로 세팅하고 IP에게 클라이언트로 송신을 의뢰합니다. 동시에 소켓에 연결 끊기 동작에 들어갔다는 정보를 기록하게 됩니다. 패킷을 받은 클라이언트의 프로토콜 스택은 서버측의 TCP 헤더를 확인하고 자신의 소켓에 서버측이 연결 끊기 동작에 들어갔음을 기록합니다. 서버의 연결 끊기를 잘 수신했음을 통지하기 위해 ACK 번호를 서버에 통지하고 애플리케이션이 read()를 호출하여 데이터를 가지러 올 때까지 기다립니다. read()가 호출되면 데이터 수신을 완료했다는 사실을 애플리케이션에게 알립니다. 그럼 애플리케시연도 close()를 호출하고 프로토콜 스택은 서버와 같이 TCP 헤더에 FIN 비트를 1로 세팅하고 IP에 의뢰해서 서버로 송신합니다. 서버에서 ACK 번호가 돌아오면 끝입니다.</p>

<p>상대와의 연결이 끊기면 소켓을 말소하게 됩니다. 이때 오작동을 막기 위해 바로 말소하지 않고 좀 기다린 후 말소하게 됩니다. 오작동이 일어나는 한 가지 케이스를 살펴보겠습니다. 연결 끊기를 클라이언트에서 먼저 시작하면 마지막에 서버의 연결 끊기 통지에 대한 ACK 번호를 보낼 건데 이 마지막 ACK 번호가 잘 가지 않았다고 가정해보겠습니다. 그럼 서버에서는 다시 FIN 비트를 세팅해서 송신을 할 건데 이때 클라이언트 소켓이 말소되어있고, 직전에 다른 애플리케이션에 대해서 동일한 포트 번호로 소켓이 만들어진 상태면 그 애플리케이션의 소켓에 FIN이 도착하게 되어서 그 애플리케이션의 소켓이 바로 종료 동작을 수행하는 오작동을 일으키게 됩니다. 이런 이유로 소켓을 바로 말소시키지 않고 기다리는 것입니다. 이때 기다리는 시간은 패킷을 다시 보내는 동작이 지속되는 시간을 기준으로 판단합니다. 패킷을 다시 보내는 동작은 몇분 정도 계속되고 그 시간이 모두 경과하면 회복 불가로 판단하여 보내기 동작을 멈춥니다. 하지만 기존에 다시 보낸 패킷들이 네트워크에 존재할 가능성이 있기 때문에 다시 보내기 동작이 완전히 끝나는 시간만큼은 기다리는 것입니다.</p>

<h3 id="프로토콜-스택의-ip는-패킷을-만들어서-상대에게-송신한다">프로토콜 스택의 IP는 패킷을 만들어서 상대에게 송신한다</h3>

<p>앞서 TCP가 실제로 패킷을 송신하기 위해서는 IP에 의뢰해야 한다는 것을 알게 됐습니다. 그럼 실제로 어떻게 패킷을 상대에게 송신하는지 살펴보겠습니다.</p>

<h4 id="패킷이란">패킷이란</h4>

<p>그 전에 패킷에 대해서 알아보겠습니다. 패킷은 실제로 네트워크를 통해서 주고받는 데이터 그 자체입니다. 패킷은 크게 <strong>헤더와 데이터(페이로드)로 구성</strong>됩니다. 앞서 많이 살펴봤지만 헤더는 통신에 필요한 여러 제어 정보를 담고 있습니다. 이 헤더의 앞에는 하위 계층의 헤더가 계속 붙게 되는데 예를 들면 데이터에 TCP 헤더가 붙고나면 그 앞에는 IP 헤더, 그리고 그 앞에는 MAC 헤더가 붙게 됩니다. 이처럼 상위 계층 프로토콜에서 하위 계층 프로토콜 계층으로 내려오면서 헤더를 하나씩 붙이는 과정을 <strong>캡슐화</strong>라고 합니다. 실제로 패킷은 상위 계층에서 하위 계층으로 내려오면서 캡슐화를 통해 완성됩니다.</p>

<p>완성된 패킷은 중계장치(허브, 라우터..)에 송신됩니다. 각 중계장치들은 패킷의 목적지(수신처)가 어느 방향에 있는지에 대한 정보를 기록한 테이블을 가지고 있습니다. 그리고 중계장치는 자신의 계층에 해당하는 헤더까지 <strong>디캡슐화</strong>를 하여 헤더에 기록된 수신처와 테이블의 데이터를 통해 어떤 케이블로 패킷을 전송할지 결정하게 됩니다. 예를 들면 L2장비인 허브는 2계층인 이더넷 프로토콜 헤더까지 디캡슐화를 하고 L3 장비인 라우터는 3계층인 IP 프로토콜 헤더까지 디캡슐화하여 제어정보를 취득하게 됩니다. 즉 허브는 MAC 헤더의 맥 주소를 보고 패킷을 서브넷 내에서 이동시키고, 라우터는 IP 헤더의 ip 주소를 보고 패킷을 다음 라우터로 전달합니다.</p>

<p>이 동작을 좀 더 구체적으로 서술해보자면, 수신처 ip 주소를 확인해서 어느 방향에 있는지 조사하고 그 방향에 있는 다음 라우터를 조사하여 그 라우터의 맥 주소를 MAC 헤더의 수신처 맥 주소로 기록합니다. 그리고 그 라우터에 패킷을 보내도록 이더넷에 의뢰합니다. 패킷을 받은 이더넷은 허브로 패킷을 전송합니다. 패킷을 받은 허브는 앞서 말한 것처럼 MAC 헤더까지 디캡슐화를 해서 수신처 맥 주소(다음 라우터의 맥 주소)를 보고 자신이 관리하는 테이블에 기록된 정보와 결합하여 패킷의 다음 목적지를 중계합니다. 만약 서브넷 내의 허브가 여러 개라면 순차적으로 경유하여 라우터에 도착합니다. 라우터는 ip 헤더까지 디캡슐화를 하고 자신의 테이블 정보와 결합하여 중계해줄 다음 라우터를 결정합니다. 그럼 그 라우터의 맥 주소를 조사해서 그것을 다시 MAC 헤더의 수신처 맥 주소로 갱신해줍니다. 그럼 다시 허브를 타면서 다음 라우터에 도착하는 과정이 반복되고, 수신처까지 도착을 하게 됩니다.</p>

<p>잘 살펴보면 <strong>이더넷 프로토콜(2계층)은 같은 네트워크 대역 내의 장비로 패킷을 전달하기 위한 역할</strong>을 수행하고, <strong>ip 프로토콜(3계층)은 서로 다른 네트워크 대역으로 패킷을 전달하기 위한 역할</strong>을 수행합니다.</p>

<h4 id="ip의-패킷-송수신-동작">IP의 패킷 송수신 동작</h4>

<p>이제 프로토콜 스택의 IP가 하는 일을 구체적으로 살펴보겠습니다. 먼저 TCP가 IP에게 패킷 송신을 의뢰하는 지점부터 시작해야겠군요. TCP는 TCP 헤더를 추가한 패킷을 IP에 전달합니다. 그리고 IP는 IP 헤더와 MAC 헤더를 순차적으로 붙이게 됩니다. IP의 역할은 이렇게 완성한 패킷을 LAN 어댑터로 전달하는 것이 끝입니다. 반대로 상대로부터 패킷을 받은 경우에는 LAN 어댑터가 IP에게 패킷을 건네주고 TCP 헤더와 데이터를 TCP에게 건내주게 됩니다.</p>

<p>먼저 IP 헤더를 만드는 과정을 살펴보겠습니다. IP 헤더에는 수신처와 송신처의 IP 주소가 들어갑니다. 수신처 IP 주소는 애플리케이션이 접속동작을 TCP에 의뢰하면서 전달한 상대측 IP 주소를 TCP가 IP에 그대로 전달하는 것입니다. 그래서 그것이 잘못된 주소이더라도 IP주소는 그냥 그 주소로 세팅을 해서 보내게 됩니다. 이에 대한 잘못된 동작은 애플리케이션의 책임으로 간주합니다.
송신처 IP 주소는 LAN 어댑터에 할당된 IP 주소로 세팅하게 됩니다. 만약 LAN 어댑터가 여러 개 장착된 경우라면 어떤 어댑터의 IP로 설정할지를 판단해야 하는데, 그것은 어떤 라우터로 보내야할지를 통해 결정할 수 있습니다. 그 방법은 라우터에서 라우팅 테이블로 다음 라우터를 결정하는 것과 동일합니다. IP용 표를 라우팅 테이블이라고 하는데 <code class="language-plaintext highlighter-rouge">route print</code> 커멘드로 확인할 수 있습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>route print
Network Destination  Netmask           Gateway           Interface         Metric
0.0.0.0              0.0.0.0           125.129.69.254    125.129.69.101    20
125.129.69.0         255.255.255.0     125.129.69.101    125.129.69.101    20
125.129.69.101       255.255.255.255   127.0.0.1         127.0.0.1         20
125.255.255.255      255.255.255.255   125.129.69.101    125.129.69.101    20
127.0.0.0            255.0.0.0         127.0.0.1         127.0.0.1         1
224.0.0.0            240.0.0.0         125.129.69.101    125.129.69.101    20
255.255.255.255      255.255.255.255   125.129.69.101    125.129.69.101    1
</code></pre></div></div>

<p>Network Destination은 패킷의 최종 목적지로 수신처 IP를 이 행과 비교해서 대상 행을 찾습니다. Interface는 LAN 어댑터 등의 네트워크 인터페이스를 나타냅니다. ‘125.129.69.101’이 LAN 어댑터에 할당된 ip입니다. Gateway는 다음 중계 라우터 주소가 됩니다. 다음 라우터에서 패킷을 받으면 그 라우터는 마찬가지로 라우팅 테이블을 조회하여 다음으로 중계해줄 라우터를 찾게 됩니다. 만약 Interface와 Gateway가 같으면 이때는 라우터로 중계하지 않고 상대에게 직접 패킷을 전할 수 있음을 의미합니다. 예를 들어 Gateway, Interface가 ‘125.129.69.101’로 동일한 행의 목적지 주소인 ‘125.129.69.0’으로는 패킷을 바로 전달할 수 있음을 의미합니다. 최상단에는 목적지와 넷마스크가 ‘0.0.0.0’으로 등록되어있는데 이는 <strong>기본 게이트웨이</strong>라고 합니다. 다른 행에 일치하는 항복이 없으면 이 행에 해당하는 것으로 간주합니다. 바로 이 테이블을 보고 <strong>어떤 LAN 어댑터에서 패킷을 내보낼지 결정하고 그 LAN 어댑터에 할당된 주소로 송신처 IP 주소를 결정</strong>하게 됩니다.
IP 헤더에는 프로토콜 번호라는 필드에도 값을 설정합니다. 이 필드에는 상위 계층의 헤더가 어떤 프로토콜인지 지정합니다. 다르게 말하면 어디로부터 의뢰가 되었는지를 명시하는 것이기도 합니다. 예를 들어 TCP로부터 의뢰를 받았다면 06, UDP로부터 의뢰를 받았으면 17이 됩니다.</p>

<p>이제 MAC 헤더를 만드는 과정을 살펴보겠습니다. MAC 헤더에는 송신측 LAN 어댑터의 MAC 주소와 수신측 MAC 주소를 담습니다. 그리고 IP 헤더와 마찬가지로 상위 계층의 프로토콜 타입을 이더 타입이라는 필드에 세팅합니다. 보통 이 이더 타입에는 IP(0800)나 ARP(0806) 프로토콜이 들어갑니다. 송신측 MAC 주소는 LAN 어댑터 내부의 ROM이라는 공간에 기록되어 있어서 여기서 읽어들이게 됩니다. 이미 IP 헤더를 작성하는 과정에서 어떤 LAN 어댑터로 패킷을 내보낼지 결정된 상태이기 때문에 그 어댑터에서 읽어들이면 됩니다. 그럼 수신측 MAC 주소는 어떻게 지정할 수 있을까요? 바로 ARP(Address Resolution Protocol)를 통해서 지정하게 됩니다. 이더넷에는 연결된 모든 노드에게 패킷을 전달하는 브로드캐스트라는 구조가 존재합니다. ARP 헤더는 송신측과 수신측의 IP, MAC 주소를 모두 담습니다. 이때 수신측의 IP주소는 다음 중계 라우터의 IP 주소를 입력하고 MAC주소는 알지 못하기 때문에 0으로만 채워둡니다. 그리고 MAC 헤더의 수신측 MAC 주소를 브로드캐스트(255.255.255.255)로 설정해서 패킷을 내보내면 패킷을 받은 모든 노드들은 MAC 헤더의 브로드캐스트 주소를 보고 모든 노드들에게 보낸 패킷이라는 것을 알고 패킷을 확인하게 됩니다. 그리고 ARP 헤더의 수신처 IP 주소를 확인해서 자신에게 온 패킷임을 확인했으면 ARP 헤더에 자신의 MAC 주소를 채워서 응답하게 됩니다. 그럼 비로소 수신측의 MAC 주소까지 알게 되어 MAC 헤더도 완성됩니다. 그런데 패킷을 보낼 때마다 ARP 동작을 수행하면 비효율적이기 때문에 한번 조회한 MAC 주소는 ARP 캐시라는 메모리에 보관합니다. 그래서 먼저 ARP 캐시에서 목적지 IP에 대한 MAC 주소가 있는지 확인하고 없는 경우에만 ARP 패킷을 전송합니다. 이때 ARP 캐시에 특정 노드의 MAC 주소를 저장했는데 이후 그 노드의 MAC 주소가 변경되어 캐시에 있는 MAC 주소가 유효하지 않은 문제가 발생할 수 있기 때문에 ARP 캐시에 저장된 값은 일정 시간이 경과하면 삭제하게 되어있습니다.
이렇게 완성된 패킷은 LAN 어댑터로 전달하게 됩니다. 여기까지가 프로토콜 스택의 IP의 역할입니다.</p>

<h3 id="lan-어댑터의-역할">LAN 어댑터의 역할</h3>

<p>LAN 어댑터는 IP로부터 받은 <strong>디지털 데이터인 패킷을 전기나 빛의 신호로 변환하여 네트워크 케이블로 송출</strong>하는 역할을 수행합니다. LAN 어댑터는 LAN 어댑터 제조사에서 제공하는 LAN 드라이버 소프트웨어가 제어하게 됩니다.</p>

<h4 id="lan-어댑터의-구성요소">LAN 어댑터의 구성요소</h4>

<p>LAN 어댑터의 동작을 살펴보기 전에 어떻게 구성되어있는지 먼저 살펴보겠습니다. LAN 어댑터에는 버퍼 메모리, MAC 회로, PHY(MAU) 회로, RJ-45 커넥터, ROM 등으로 구성되어 있습니다. LAN 어댑터는 전원이 공급되면 다른 하드웨어들처럼 초기화 작업이 필요합니다. 그 동작을 LAN 드라이버가 수행합니다. LAN 어댑터의 MAC 주소는 ROM에 저장됩니다. 여기서 MAC 주소를 읽어서 MAC 회로에 설정하게 됩니다. MAC 회로는 이더넷의 송/수신 동작을 제어합니다. 다른 구성요소들은 실제로 LAN 어댑터의 동작을 살펴보면서 더 보도록 하겠습니다.</p>

<h4 id="ip로부터-전달받은-패킷에-3개의-제어용-데이터를-추가한다">IP로부터 전달받은 패킷에 3개의 제어용 데이터를 추가한다</h4>

<p>프로토콜 스택의 IP로부터 패킷을 받으면 우선 LAN 어댑터의 버퍼 메모리로 복사해둡니다. 그리고 MAC 회로에 패킷 송신 명령을 보내면 MAC 회로 버퍼 메모리에서 패킷을 읽어서 3개의 데어터를 붙이게 됩니다. 하나는 패킷의 맨 앞에 붙는 <strong>프리앰블</strong>입니다. 프리앰블은 수신측이 계속해서 흐르는 전기 신호 속에서 송신측으로부터 받은 패킷을 읽기 시작할 타이밍을 잡게 할 수 있게 도움을 주기 위한 데이터 입니다. 프리앰블은 ‘10101010..’같이 1, 0이 번갈아 나타나는 56비트 데이터 입니다. 이 비트 패턴을 신호로 바꾸면 파형이 일정한 모습이 되고 수신측에서 이 일정한 파형을 통해 패킷을 읽을 준비를 해야함을 알게 됩니다. 다음은 프리앰블 바로 뒤에 오는 <strong>스타트 프레임 딜리미터</strong>입니다. 이 데이터는 ‘101010….11’와 같이 1과 0이 반복되다가 마지막에 ‘11’로 끝이납니다. 수신측은 저 ‘11’로 끝나는 지점을 통해서 패킷의 시작점을 파악할 수 있게 됩니다. 즉 스타트 프레임 딜리미터는 패킷의 시작지점을 캐치할 수 있게 하기 위한 데이터가 됩니다. 나머지 하나는 패킷의 맨 뒤에 붙는 <strong>FCS</strong>라는 데이터 입니다. 이 데이터는 패킷이 네트워크를 타고 전달되는 과정에서 잡음 등의 영향으로 파형이 흐트러져 데이터가 손상된 경우 검출을 하기 위해 사용합니다. 이 값은 패킷의 맨 앞부터 맨 끝까지의 내용을 어떤 계산식을 이용해서 도출한 32비트의 비트열입니다. 그래서 패킷 데이터의 값이 1비트라도 변하면 계산한 결과도 달라진 값이 됩니다. 수신측은 전달받은 패킷을 계산식을 토대로 계산한 결과와 FCS의 값과 비교를 해서 데이터 손상 여부를 파악합니다.</p>

<h4 id="허브를-향해서-패킷을-송신한다">허브를 향해서 패킷을 송신한다</h4>

<p>앞서 언급한 3개의 데이터를 패킷에 부가했으면 이제 패킷을 허브로 송신하게 됩니다. 이때 리피터 허브일 때는 반이중 모드, 스위칭 허브일 때는 전이중 모드로 동작하는데 먼저 반이중 모드부터 살펴보겠습니다.
반이중 모드는 동시에 송신과 수신을 할 수 없습니다. LAN 어댑터의 PHY(MAU)는 케이블에 다른 기기가 송신한 신호가 흐르고 있는지 확인하고 신호가 흐르고 있으면 끝날 때까지 기다립니다. 만약 송신하고 있는 신호가 있는데 송신동작을 시작하면 충돌이 발생합니다. 그리고 신호가 흐르고 있지 않으면 송신 동작을 시작합니다. 송신 동작은 먼저 <strong>MAC 회로가 프리앰블의 맨 앞부터 1비트씩 차례로 디지털 데이터를 신호로 변환하고 PHY 혹은 MAU라는 송/수신 신호 부분에 보냅니다.</strong> 이때 디지털 데이터를 신호로 변환하는 속도가 전송 속도가 됩니다. 1초에 10메가비트 분량의 디지털 데이터를 신호로 변환하여 보내면 10메가비트/초 전송률이 됩니다. 그럼 <strong>PHY는 다시 이 신호를 실제 케이블에 송출하는 형식으로 변환해서 송신</strong>을 합니다. MAC에서 한번, PHY에서 한번 신호를 변환하는 절차를 2번으로 나눈 이유는 PHY는 여러 신호 형식의 종류에 구애받지 않고 공통 형식의 신호로만 변환해서 송신을 할 수 있게 하기 위함입니다. 이렇게 PHY가 송신을 완료할 때까지 수신 신호선에 신호가 들어오지 않으면 송신 동작은 끝납니다. 그런데 신호를 송신하는데 적은 확률로 복수의 기기가 송신 동작에 들어가서 수신 신호가 흘러들어오는 경우가 있습니다. 이렇게 신호가 충돌하게 되면 송신을 계속 해도 의미가 없기 때문에 송신 중단을 하고 충돌 사실을 다른 기기에 통지하기 위해 <strong>재밍 신호</strong>라는 특수한 신호를 잠시 흘리고 일정 시간 대기했다가 다시 송신 동작을 수행합니다. 이때 모든 기기의 대기 시간이 동일하면 다시 출돌이 일어나기 때문에 대기 시간은 기기들의 MAC 주소를 바탕으로 난수를 생성해서 계산하도록 고안되어 있습니다. 그런데도 이더넷의 혼잡으로 다시 충돌이 발생하면 대기 시간을 2배로 늘리고 다시 보내게 됩니다. 그렇게 열번까지 재시도가 일어나게 되었는데도 해결이 안 되면 오류로 판단합니다.
전이중 모드는 송신과 수신의 충돌이 일어나지 않기 때문에 반이중모드처럼 충돌에 대한 고민을 할 필요가 없습니다. 리피터, 스위칭 허브에 대한 내용은 3장에서 더 자세하게 살펴봅니다.</p>

<h4 id="lan-어댑터의-패킷-수신">LAN 어댑터의 패킷 수신</h4>

<p>패킷의 수신은 앞서 살펴본 송신과 반대로 일어난다고 이해하면 됩니다. 리피터 허브의 반이중 동작을 기준으로 살펴보겠습니다. 앞서 살펴봤듯이 이더넷에서는 1대가 송신을 하면 같은 허브에 접속된 모든 케이블로 신호가 흘러갑니다. 이렇게 신호를 받은 기기들은 패킷의 맨 앞에 붙은 프리앰블을 통해 파형을 계산하고 스타트 프레임 딜리미터가 나오면 그 다음 비트부터 PHY 회로에서 신호를 공통 형식 신호로 변환해서 MAC 회로로 보내고, MAC 회로에서 신호를 차례로 디지털 데이터로 변환합니다. 그리고 신호의 마지막에 다다르면 FCS를 검사합니다. 여기까지 통과하면 MAC 헤더의 수신처 MAC 주소를 조사해서 MAC 회로에 설정된 주소와 비교해서 자신에게 온 것인지 확인합니다. 이때 자신에게 온 것이 아니면 패킷을 폐기하고, 자신에게 온 것이면 버퍼 메모리에 저장합니다. MAC 회로가 일을 끝마치면 패킷 수신 사실을 컴퓨터 본체에 통지합니다.
통지는 인터럽트를 통해서 하게 됩니다. LAN 어댑터는 확장 버스 슬롯에 있는 인터럽트용 신호선에 신호를 보냅니다. 이 신호선은 컴퓨터 본체의 인터럽트 컨트롤러를 통해 CPU에 연결되어 있고, 신호를 받으면 CPU는 하던 작업을 보류하고 OS 내부의 인터럽트 처리용 프로그램으로 전환합니다. 여기서 LAN 드라이버가 호출되어서 LAN 어댑터를 제어하면서 송/수신 동작을 실행합니다.
LAN 어댑터의 버퍼 메모리에서 수신 패킷을 추출하면 LAN 드라이버는 MAC 헤더의 타입 필드 값을 통해서 상위 계층 프로토콜을 판별합니다. 그리고 프로토콜 스택의 해당 프로토콜 담당 부분에 패킷을 전달해줍니다.(보통 IP, TCP)</p>

<h3 id="프로토콜-스택-tcpip의-수신-동작">프로토콜 스택 TCP/IP의 수신 동작</h3>

<p>LAN 어댑터에게 건네받은 패킷을 프로토콜 스택의 IP, TCP가 어떻게 처리하는지 정리해보겠습니다. IP담당은 IP 헤더의 포맷에 문제가 없는지 확인하고, 수신처 IP 주소를 확인합니다. 만약 현재 기기가 라우터 같은 중계 장비가 아닌 클라이언트(엔드 노드)인 경우라면 수신처 IP가 자신의 IP와 다르다면 오류로 간주합니다. 클라이언트가 패킷 중계를 할 일은 없기 때문입니다. 그래서 이럴 때는 <strong>ICMP</strong>를 통해 상대에게 오류 통지를 하게 됩니다. 다양한 오류 케이스를 통지할 수 있는데 이 경우에는 Destination unreachable 메시지를 통지합니다. IP 주소까지 올바르면 IP 담당은 <strong>조각화된 패킷을 원래의 모습으로 합치는 리어셈블링 작업</strong>을 수행합니다. 리어셈블링에 필요한 정보는 ip 프로토콜 헤더에 기록되어있습니다. 플래그, ID 정보, 프래그먼트 오프셋이 바로 그 정보들인데, 플래그는 이 패킷이 조각화된 패킷인지 아닌지를 판별할 수 있는 정보입니다. 만약 이 패킷이 조각화된 패킷이면 IP 담당 내부의 메모리에 일시적으로 보관하게 됩니다. 그리고 ID 정보를 통해 조각화된 패킷들이 한몸임을 식별할 수 있습니다. 한몸이 되어야 하는 패킷들은 동일한 ID 정보를 가집니다. 그리고 이 패킷들이 어떤 순서로 합쳐져야 하는지에 대한 정보는 프래그먼트 오프셋이라는 항목으로 알 수 있습니다. 여기까지 수행하면 이제 패킷을 TCP 담당에 전달합니다.
TCP 담당은 IP 헤더의 수신처, 송신처 IP 주소와 TCP 담헤더의 수신처, 송신처 포트 번호를 조사해서 해당하는 소켓을 찾습니다. 소켓에는 현재 통신의 진행 상태가 기록되어 있기 때문에 적절한 동작을 수행하면 됩니다.</p>

<h3 id="udp-프로토콜의-송수신-동작">UDP 프로토콜의 송/수신 동작</h3>

<p>UDP 프로토콜은 TCP 프로토콜처럼 신뢰성을 보장하지 않아도 될 경우 사용하면 효율적입니다. TCP와 달리 패킷이 잘 도착했는지 확인하고 도착하지 않았으면 패킷을 다시 보내는 동작을 하지 않기 때문입니다. UDP는 TCP처럼 수신 확인, 윈도우 같은 것이 없기 때문에 송, 수신 전에 제어 정보를 주고 받을 필요가 없고, 접속, 연결 끊기 단계도 없습니다. 애플리케이션으로부터 데이터를 받으면 그냥 UDP 헤더를 붙이고 IP에 의뢰하고 바로 송신합니다. 수신도 IP 헤더의 수신처, 송신처의 IP 주소와, TCP 헤더의 수신처, 송신처의 포트 번호로 소켓을 찾아서 애플리케이션에게 데이터를 건네주고 끝입니다. 오류가 발생해도 UDP는 신경쓰지 않습니다. UDP는 DNS 서버에 IP 주소를 조회할 때나, 음성 및 동영상 데이터의 송수신에 사용됩니다.</p>
:ET