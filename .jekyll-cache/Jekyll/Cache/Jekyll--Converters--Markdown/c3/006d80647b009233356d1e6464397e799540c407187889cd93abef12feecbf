I".-<p>앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘3장 기본적인 도구’를 정리했습니다.</p>

<h1 id="3장-기본적인-도구">3장. 기본적인 도구</h1>

<hr />

<h3 id="14장-일반-텍스트의-힘">14장. 일반 텍스트의 힘</h3>

<p>프로그래밍은 인간이 하는 것이고 인간은 소위 일반 텍스트(plain text)를 통해서 소통하기 때문에 설계, 구현, 테스트, 문서화 등 대부분의 지식을 저장할 때는 일반 텍스트를 사용하는 것이 바람직합니다. 일반 텍스트가 아닌 이진수, 암호화된 무작위로 나열된 문자들은 그 데이터를 이해하는 데에 필요한 맥락이 없는한 의미를 파악할 수 없습니다. 물론 일반 텍스트를 사용하면 저장 공간에 대한 오버헤드가 생길 수 있고 다른 포맷에 비해 연산에 대한 오버헤드도 생길 수 있지만 그것을 일반 텍스트를 사용했을 때의 장점이 그것을 다 보상하고도 남습니다. 다음이 그 장점입니다.</p>

<ul>
  <li>
    <p>구식이 되는 것에 대한 보험: 사람이 읽을 수 있는 형태의 데이터를 사용하면 그 데이터를 생성한 애플리케이션이 죽더라도 살아남을 수 있습니다. 완전히 소멸해버린 레거시 시스템이 생성한 주민등록번호 데이터가 있을 때 그것이 이진 데이터로 표현되어있으면 그 레거시 시스템 없이는 그 데이터의 의미를 파악하지 못합니다. 하지만 일반 텍스트로 되어있다면 그 데이터를 파싱해서 새로운 애플리케이션에 적용하는 건 매우 간단한 작업이 됩니다.</p>
  </li>
  <li>
    <p>호환성: 소스코드 관리 시스템, 컴파일러, ide등과 같이 오늘날의 모든 도구들은 일반 텍스트를 다룰 수 있게 지원합니다.</p>
  </li>
  <li>
    <p>더 쉬운 테스트: 시스템 테스트를 구동하게 할 합성 데이터를 만들기 위해 일반 텍스트를 사용하면 별도의 도구 없이 테스트 데이터를 추가, 업데이트, 수정할 수 있습니다.</p>
  </li>
</ul>

<h3 id="15장-조개-놀이">15장. 조개 놀이</h3>

<p>오늘날의 많은 GUI 프로그램은 프로그래머들에게 편리함을 제공하지만, 그럼에도 여전히 셸 명령어들은 프로그래머에게 없어서는 안 될 작업대라고 할 수 있습니다. GUI나 IDE의 장점은 우리가 보는 것이 우리가 얻는 것(WYSIWYG-What You See Is What You Get)이라는 점입니다. 즉 매우 직관적으로 우리에게 필요한 것을 얻을 수 있다는 것이죠. 하지만 동시에 우리가 보는 것이 우리가 얻는 전부(WYSIAYG - What You See Is All You Get)라는 단점이 있습니다. 즉 GUI, IDE가 제공하는 기능 이상의 것은 얻을 수 없습니다.
하지만 셸의 명령어들을 조합하면 우리가 원하는 거의 모든 기능을 얻을 수 있습니다. 그렇기 때문에 반드시 셸과 친근해져야 합니다. 또 이런 자주 사용되는 조합을 스크립트로 작성하여 자동화할 수도 있습니다. 현재 회사에서 배포 자동화에도 셸 스크립트가 사용되고 있는데 이를 제대로 이해하지는 못 한 것 같습니다. 셸의 중요성에 대해서 인지하고는 있지만 그 특유의 지루함 때문에 미루어왔는데 앞으로는 억지로라도 공부를 해야겠습니다..</p>

<h3 id="16장-파워-에디팅">16장. 파워 에디팅</h3>

<p>에디터는 프로그래밍의 기본적인 원재료인 텍스트를 매우 효율적으로 조작할 수 있게 해주는 도구이기 때문에 마치 자신의 손을 움직이는 것과 같이 익숙한 수준으로 에디터에 대한 숙련도를 높일 필요가 있습니다. 특히 <strong>하나의 에디터를 마스터</strong>하는 것이 중요합니다. 그리고 모든 편집 작업에서 그 에디터를 사용합시다.
그럼 어떤 에디터를 선택하는지가 중요한데 다음의 요소를 만족해야 합니다.</p>

<ul>
  <li>모든 플랫폼에서 가능해야 한다.</li>
  <li>환경 설정이 가능해야 한다.(폰트, 색깔, 윈도우 크기, 키 입력 설정 등)</li>
  <li>확장이 가능해야 한다. 새 프로그래밍 언어가 나와도 에디터는 사용 가능해야 합니다. 즉 어떤 컴파일러 환경과도 결합 가능해야 합니다.</li>
  <li>복잡하고 다단계의 작업 수행이 가능하도록 에티터를 프로그램할 수 있어야 합니다.</li>
</ul>

<h3 id="17장-소스코드-관리">17장. 소스코드 관리</h3>

<p>소스코드 관리, 즉 형상관리는 프로젝트에서 발생한 실수를 되돌릴 수 있게 해주는 거대한 <code class="language-plaintext highlighter-rouge">undo</code> 키와 같습니다. 형상관리를 통해서 언제든지 소스코드를 원하는 시점으로 되돌릴 수 있다는 것은 프로젝트의 안정감을 극도로 높여주는 것을 의미합니다. 뿐만 아니라 특정 시점에 어떤 코드를 누가 수정했는지 알 수 있고, 무수히 많은 브랜치를 생성해서 저마다 독립적으로 코드를 작성하고 한 번에 합칠 수도 있기에 생산성도 높아집니다. 또한 결국 형상관리의 핵심은 <code class="language-plaintext highlighter-rouge">undo</code>에 있기 때문에 소스코드가 아닌 모든 컨텐츠(각종 문서, 메모, makefile, 셸 스크립트, 환경설정 등)는 다 형상관리 하에 두는 것이 좋습니다.
책에는 나오지 않지만 최근에는 많은 프로젝트가 git flow의 규칙에 따라 관리되는데 이런 형상관리가 당연하다고 생각하다가도 막상 이게 없다고 생각하면 너무 암담할 것 같습니다^^</p>

<h3 id="18장-디버깅">18장. 디버깅</h3>

<p>현존하는 모든 프로그램은 완벽하지 않고 우리가 만든 프로그램도 마찬가지 입니다. 항상 버그가 존재하기 때문에 디버깅을 잘해야 합니다. 디버깅을 잘 하려면 우선 마음가짐을 다잡아야 합니다. 디버깅은 단지 <strong>문제해결</strong> 그 이상, 이하도 아니라고 생각하고 접근해야 합니다. 버그를 만들어낸 장본인이 누구인지 색출하고, 비난하는 것은 아무 도움이 안 됩니다. 그렇게 한다고 버그가 고쳐지는 것도 아닙니다. 그 다음은, 디버깅을 할 때 당황하지 않아야 합니다. 일정이 촉박하거나 상사나 클라이언트의 압력에 시달리고 있는 상황에서 디버깅을 하는 것은 분명히 쉽지 않겠지만 그럼에도 불구하고 차분하게 원인을 생각해야 합니다. 그리고 디버깅을 할 때 표면에 보이는 문제를 해결하는 것이 아닌 몇 단계 더 깊이 있는 근본적인 문제를 해결하려고 노력해야 합니다.
이렇게 마음가짐을 다잡았다면 이젠 실제로 디버깅을 어떻게 할지 살펴보겠습니다. 당연한 얘기처럼 들릴 수도 있지만 수집할 수 있는 모든 정보를 수집해야 합니다. 필요하다면 최초로 버그를 발견한 사람을 인터뷰할 수도 있어야 합니다. 그리고 제한적인 테스트를 넘어 최종 사용자의 입장에서 모든 케이스를 철저하게 테스트해야 합니다.
이렇게 어떤 버그가 발생하고 있는지를 확실히 파악했으면 그게 프로그램의 입장에서 어떻게 발생하는지 찾아야 합니다. 그걸 알아내는 가장 쉬운 방법은 그 프로그램이 다루는 데이터를 살펴보는 것입니다. 이때 데이터들 간의 상호관계를 시각화해서 보여주는 디버거를 쓸 수 있다면 아주 쉽게 깊이 있는 파악이 가능합니다. 그리고 현재 상태를 넘어 시간별로 데이터의 상태가 어떻게 변하는지를 살펴봐야 할 수도 있습니다. 특히 실시간 시스템, 동시 프로세스, 이벤트 기반 애플리케이션 등에서 그런데, 이럴 때는 트래이싱을 이용합시다. 트레이스 메시지는 규칙적이고 일관된 형식으로 작성되어야 합니다. 왜냐하면 그 메시지에서 특정 영역만 자동으로 뽑아내서 해석하고 싶은 경우가 많기 때문입니다. 예를 들면 자원 누수가 있는지 확인하고 싶어서 open/close를 남겨서 open은 있는데 close는 없는 경우를 찾을 수 있습니다. 또 다른 방법으로는 버그가 발생한 코드에 대해서 다른 사람에게 설명을 해보는 것입니다. 그러면 혼자서 코드를 봤을 때 당연하게 생각하고 지나갈 것을 명시적으로 설명하게 되는데 여기서 의외의 통찰을 얻을 수도 있습니다. 그 외로 자신이 작성한 코드에 근거가 없는 신뢰와 믿음을 가지기보단 항상 증명하려고 하고 서드파티 모듈보단 자신의 코드에 문제가 있을 것이라고 가정하고 디버깅을 합시다.</p>

<h3 id="19장-텍스트-처리">19장. 텍스트 처리</h3>

<p>텍스트 처리를 위한 언어는 텍스트를 원하는 형태로 제어하기 위해서 꼭 숙달해야 합니다. 유닉스 계열에서는 awk, sed와 같은 명령어를 선호하기도 하고, 파이썬 같은 더 구조적이고 객체지향성을 갖춘 도구를 선호하기도 하는데 뭐가 됐든 이런 기반 언어들 중 하나를 익혀야 합니다. 이런 텍스트 처리 언어를 통해 다음과 같은 것을 할 수 있습니다.</p>

<ul>
  <li>데이터베이스 스키마가 들어있는 일반 텍스트 파일로 sql문 생성, 데이터베이스에 엑세스하는 c코드 생성 등..</li>
  <li>자바 클래스에서 특정 플래그가 달린 멤버에 대한 getter/setter 자동 생성</li>
</ul>

<h3 id="20장-코드-생성기">20장. 코드 생성기</h3>

<p>코드 작성하는 코드, 즉 코드 생성기를 만들면 똑같은 기능을 다른 맥락에서 사용할 때 반복할 필요가 없어집니다. 코드 생성기는 크게 두 가지 유형이 있습니다.</p>

<ul>
  <li>
    <p>수동적 코드 생성기: 결과를 내기 위해 한 번만 실행되는 생성기 입니다. 한번 생성되면 수동적 코드 생성기와는 독립적인 결과물이 됩니다. 즉 몇 개의 입력을 받으면 그에 맞게 출력을 생성해주는 템플릿이라고 생각하면 됩니다. 가령 새 소스 파일 생성, 언어 간 일회용 변환 수행 등이 수동적 코드 생성기 입니다.</p>
  </li>
  <li>
    <p>능동적 코드 생성기: 코드 생성이 필요할 때마다 작동하는 생성기 입니다. 단지 평하기 위해 사용하는 수동적 코드 생성기와 달리 능동적 코드 생성기는 DRY 원칙을 따르려면 필수 입니다. 이 생성기는 하나의 지식 뼈대를 만들어두면 그것을 사용하는 구체화된 형식으로 변환해줍니다. 가령 데이터베이스 애플리케이션을 만들 때 우리가 다루어야 할 환경은 데이터베이스와 데이터베이스에 접근하기 위한 언어 입니다. 이때 데이터베이스 스키마와 언어에서 데이터베이스 테이블 형식을 표현하는 구조체는 형태만 다를뿐 그 지식은 동일합니다. 이는 지식이 중복되는 것입니다. 이런 것을 능동적 코드 생성기로 해결할 수 있습니다. 스키마를 입력하면 그에 맞는 구조체들을 만들어주는 것입니다.</p>
  </li>
</ul>
:ET