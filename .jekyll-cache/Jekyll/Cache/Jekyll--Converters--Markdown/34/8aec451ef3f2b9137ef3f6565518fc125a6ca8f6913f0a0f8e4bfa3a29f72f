I"C<p>앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘5장 구부러지거나 부러지거나’을 정리했습니다.</p>

<h1 id="5장-구부러지거나-부러지거나">5장. 구부러지거나 부러지거나</h1>

<hr />

<h3 id="26장-결합도-줄이기와-디미터-법칙">26장. 결합도 줄이기와 디미터 법칙</h3>

<p>결합도를 줄이는 것은 최대한 적은 객체와 상호작용하는 것에서 시작됩니다. 모든 객체를 모듈화하고 한 모듈이 너무 많은 모듈과 상호작용하는 것을 제한합시다. 그러면 한 모듈이 변경되더라도 다른 모듈들은 큰 변경 없이 수행될 수 있습니다. 책에서 재밌는 예시를 들었는데요. 우리가 집을 지을 때 이를 도맡아서 해줄 주계약자라는 주체와만 계약을 할 것입니다. 그럼 이 주계약자는 또 다시 집을 짓기 위해 필요한 역할들을 담당할 하도급자들과 계약을 합니다. 이때 우리는 하도급자들과 직접 부딪힐 일도 없고 이들에게 무슨 일이 생긴다고 하더라도 신경쓸 것이 없습니다. 모든 건 주계약자가 처리할 거니까요. 이처럼 어떤 객체에게 특정한 서비스를 요청하면 그 서비스가 어떻게 처리되는지 요청자는 알 필요가 없게 하는게 중요합니다.
프로그램에서 모듈 간의 결합도를 최소화하고 싶다면 디미터 함수 법칙을 따르는 것도 좋은 방법입니다. 디미터 함수 법칙에 따르면 객체의 한 메서드 내에서 다음에 해당하는 메서드만 호출해야 합니다.</p>

<ul>
  <li>객체 자신이 가지는 다른 메서드</li>
  <li>인자로 전달된 객체의 메서드</li>
  <li>객체 자신이 포함하고 있는 멤버의 메서드</li>
  <li>지역 변수 객체의 메서드</li>
</ul>

<p>물론 이 법칙을 엄격하게 따르는 것에 대한 대가도 있습니다. 역할에 대한 위임을 위해서 위임하는 객체의 메서드를 호출하기 위한 위임용 메서드를 많이 만들어야 합니다. 하지만 그럼에도 불구하고 깨지기 쉽고, 유연하지 않은 프로그램을 만드는 것이 가져오는 후폭풍은 어마무시하기 때문에 가능하다면 디미터 함수 법칙을 잘 지키는 것이 좋을 것 같습니다.</p>

<h3 id="27장-메타프로그래밍">27장. 메타프로그래밍</h3>

<p>메타데이터는 최대한 많이 코드에서 분리하여 별도로 관리하도록 하는 것이 좋습니다. 데이터에 관한 데이터인 메타데이터는 애플리케이션 구성에 필요한 모든 데이터를 의미합니다. 다음과 같은 것들입니다.</p>

<ul>
  <li>데이터베이스 연동 정보</li>
  <li>api url</li>
  <li>컨텐츠 업로드/다운로드 경로</li>
</ul>

<p>위와 같은 데이터가 코드레벨에 뿌리내려 박혀있다면 그 프로그램은 매우 경직된, 변화에 쉽게 대응할 수 없는 프로그램이 될 것입니다. 우리의 애플리케이션의 db가 바뀌더라도 그것이 코드 바깥에 있다면 코드의 수정은 최소화될 것입니다. 메타데이터를 코드 바깥에서 별도로 관리하면 코드의 추상화 레벨은 올라갈 것이고, 애플리케이션의 설정 변경을 위해 다시 컴파일할 필요가 없어집니다.
저에게 가장 익숙한 스프링도 메타데이터 관리를 위한 지원을 아주 잘 해줍니다. properties나 yaml파일에 애플리케이션의 모든 메타 데이터를 몰아두고 코드에서는 그 설정 파일의 값을 동적으로 읽어들일 수 있게 구성해서 유연성을 높일 수 있습니다.</p>

<h3 id="28장-시간적-결합">28장. 시간적 결합</h3>

<p>시간적 결합은 어떤 메서드나 함수의 호출이 다른 것의 호출보다 이전, 혹은 이후에만 실행되어야 하는 순서에 의존하는 것을 의미합니다. 물론 이런 순서가 반드시 지켜져야하는 경우도 있지만 순서와 무관하게 호출되어도 되는(혹은 동시에 호출되어도 되는) 경우에도 순차적으로 호출되는 경우가 있습니다. 이런 경우에는 시간적 결합을 끊어낼 수 있는 방법을 고려해보는 것이 좋습니다. 주로 동시성을 허용하는 것인데요. 이 책에서는 아래와 같은 방법들을 제시합니다.</p>

<ol>
  <li>
    <p>작업 흐름
요구사항을 분석할 때 작업의 흐름을 모델화해서 분석해보는 것입니다. UML 활동 다이어그램을 통해 작업 흐름을 시각화하는 것이 하나의 방법이 되겠습니다. 그렇게 분석하다보면 <strong>동시에 일어나도 되는 것들</strong>이 보이는데요. 이를 통해 병렬성을 극대화할 수 있습니다.</p>
  </li>
  <li>
    <p>아키텍처
여러 시스템들이 결합되어 동작하는 분산 애플리케이션에서 동시에 처리되어도 되는 시스템들끼리 집합으로 묶고 순차적으로 처리되는 시스템 집합 사이에는 큐를 통해 순차적으로 실행되어야하는 시스템 집합들 간의 동기화를 할 수 있습니다. 이렇게 하면 같은 시스템 집합 속의 시스템들 간의 시간적 결합을 끊어내서 효율을 극대화할 수 있습니다.</p>
  </li>
  <li>
    <p>동시성을 고려한 설계
책은 자바의 스레드를 예로 들면서 동시성 제어를 위해 고려해야할 것들을 강조합니다. 가장 대표적으로 static한 변수들을 동시 접근으로부터 보호하는 것이 있는데요. 더 중요한 건 정적 변수가 정말 필요한지를 자문하는 것입니다. 다음은 여러 스레드의 손을 타는 전역 변수의 상태가 손을 탈 가능성이 있는 모든 시간대에 언제나 유효한 상태에 있도록 하는 것이 중요합니다.</p>
  </li>
</ol>
:ET