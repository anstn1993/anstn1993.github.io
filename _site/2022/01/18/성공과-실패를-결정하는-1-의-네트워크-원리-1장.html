<!DOCTYPE html>
<!--
    Type on Strap jekyll theme v2.3.0
    Copyright 2016-2020 Sylhare
    Theme free for personal and commercial use under the MIT license
    https://github.com/sylhare/Type-on-Strap/blob/master/LICENSE
-->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!-- Main JS (navbar.js, katex_init.js and masonry_init.js)-->
    <script defer src="/assets/js/main.min.js"></script>
    
    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <!--Favicon-->
    <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

    <!-- RSS -->
    <link rel="alternate" type="application/atom+xml" title="MunSooKim's devlog" href="https://anstn1993.github.io/feed.xml"/>
    
    

    <!-- KaTeX 0.12.0 -->
    
    <script defer src="/assets/js/vendor/katex.min.js"></script>
    <script defer src="/assets/js/vendor/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
    

    <!-- Mermaid 8.8.2 -->
    
    <!-- <script src=”https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.8.2/mermaid.min.js" onload="mermaid.initialize({startOnLoad:true});"></script> -->
    <script defer src="/assets/js/vendor/mermaid.min.js" onload="mermaid.initialize({startOnLoad:true});"></script>
    

    <!-- Simple-Jekyll-Search 1.17.12 -->
    <script src="/assets/js/vendor/simple-jekyll-search.min.js" type="text/javascript"></script>

    <!-- Google Analytics / Cookie Consent -->
    <script>
      const cookieName = 'cookie-notice-dismissed-https://anstn1993.github.io';
      const isCookieConsent = 'false';
      const analyticsName = '';
    </script>

    
    

    <!-- seo tags -->
    <meta property="og:image" content="https://anstn1993.github.io/assets/img/pexels/triangular.jpeg">
    
    <meta property="og:type" content="website" />
    
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>성공과 실패를 결정하는 1%의 네트워크 원리 1장 | MunSooKim’s devlog</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="성공과 실패를 결정하는 1%의 네트워크 원리 1장" />
<meta name="author" content="Mun Soo Kim" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘1장 웹 브라우저가 메시지를 만든다’를 정리했습니다." />
<meta property="og:description" content="Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘1장 웹 브라우저가 메시지를 만든다’를 정리했습니다." />
<link rel="canonical" href="https://anstn1993.github.io/2022/01/18/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-1%EC%9E%A5.html" />
<meta property="og:url" content="https://anstn1993.github.io/2022/01/18/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-1%EC%9E%A5.html" />
<meta property="og:site_name" content="MunSooKim’s devlog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-18T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="성공과 실패를 결정하는 1%의 네트워크 원리 1장" />
<script type="application/ld+json">
{"headline":"성공과 실패를 결정하는 1%의 네트워크 원리 1장","dateModified":"2022-01-18T00:00:00+09:00","datePublished":"2022-01-18T00:00:00+09:00","url":"https://anstn1993.github.io/2022/01/18/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-1%EC%9E%A5.html","mainEntityOfPage":{"@type":"WebPage","@id":"https://anstn1993.github.io/2022/01/18/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-1%EC%9E%A5.html"},"author":{"@type":"Person","name":"Mun Soo Kim"},"description":"Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘1장 웹 브라우저가 메시지를 만든다’를 정리했습니다.","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <!-- RSS -->
    <link type="application/atom+xml" rel="alternate" href="https://anstn1993.github.io/feed.xml" title="MunSooKim's devlog" />

    <!-- Twitter Cards -->
    <meta name="twitter:title" content="성공과 실패를 결정하는 1%의 네트워크 원리 1장">
    <meta name="twitter:description" content="Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘1장 웹 브라우저가 메시지를 만든다’를 정리했습니다.1장. 웹 브라우저가 메시지를 만든다.1장에서는 웹 브라우저가 url을 입력해서 요청할 때 메시지가 만들어...">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:image" content="https://anstn1993.github.io/assets/img/pexels/triangular.jpeg">
    <meta name="twitter:image:alt" content="성공과 실패를 결정하는 1%의 네트워크 원리 1장">
</head>

  <body>
    <header class="site-header">

    <!-- Logo and title -->
	<div class="branding">
        
		<a href="/">
			<img alt="logo img" class="avatar" src="/assets/img/triangle.png" />
		</a>
        
        <a class="site-title" aria-label="MunSooKim's devlog" href="/">
        MunSooKim's devlog
		</a>
	</div>

    <!-- Toggle menu -->
    <nav class="clear">
    <a aria-label="pull" id="pull" class="toggle" href="#">
    <i class="fa fa-bars fa-lg"></i>
    </a>

    <!-- Menu -->
    <ul class="hide">
        

        
            
            
        
            
            <li class="separator"> | </li>
            <li>
                <a class="clear" aria-label="About" title="About" href="/about">
                     About 
                </a>
            </li>
            
            
        
            
            
        
            
            
        
            
            
        
            
            <li class="separator"> | </li>
            <li>
                <a class="clear" aria-label="Search" title="Search" href="/search">
                     <i class="fa fa-search" aria-hidden="true"></i>
                    
                </a>
            </li>
            
            
        
            
            <li class="separator"> | </li>
            <li>
                <a class="clear" aria-label="Tags" title="Tags" href="/tags">
                     <i class="fa fa-tags" aria-hidden="true"></i>
                    
                </a>
            </li>
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    </ul>

	</nav>
</header>

    <div class="content">
      <article class="feature-image" >
  <header id="main" style="">
    <div class="title-padder">
      
      <h1 id="%EC%84%B1%EA%B3%B5%EA%B3%BC+%EC%8B%A4%ED%8C%A8%EB%A5%BC+%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94+1%25%EC%9D%98+%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC+%EC%9B%90%EB%A6%AC+1%EC%9E%A5" class="title">성공과 실패를 결정하는 1%의 네트워크 원리 1장</h1>
      


<div class="post-info">
    <p class="meta">
      January 18, 2022
    </p></div>

      
    </div>
  </header>

  <section class="post-content">
  
      <p>Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘1장 웹 브라우저가 메시지를 만든다’를 정리했습니다.</p>

<h1 id="1장-웹-브라우저가-메시지를-만든다">1장. 웹 브라우저가 메시지를 만든다.</h1>

<hr />

<p>1장에서는 웹 브라우저가 url을 입력해서 요청할 때 메시지가 만들어져서 바깥으로 나가는 순간까지를 추적합니다.</p>

<h3 id="dns가-ip주소를-찾는다">DNS가 ip주소를 찾는다</h3>

<h4 id="ip-주소란">ip 주소란?</h4>

<p>ip 주소는 네트워크의 대역을 식별하는 <strong>네트워크 번호</strong>와 그 대역 안에서 하나의 컴퓨터(노드)를 식별하는 <strong>호스트 번호</strong>의 조합으로 이루어진 32비트 데이터 입니다. 이때 ip주소 값에서 어디까지가 네트워크 번호이고 어디까지가 호스트 번호인지 그 경계를 구분해주는 역할을 하는 것이 <strong>서브넷 마스크</strong> 입니다. 서브넷은 작은 네틔워크 대역 하나를 의미하고, 이 대역 안에서의 장비들은 <strong>허브</strong>로 연결됩니다. 그리고 이 서브넷들은 <strong>라우터</strong>를 통해 서 연결되는데, 결국 전체 네트워크는 수많은 서브넷들이 연결된 형태라고 생각하면 됩니다. ip 주소는 결국 두 노드가 통신할 때 각 노드가 많은 서브넷들 중에서 어떤 서브넷의 어떤 장비인지를 식별하기 위한 값이라고 볼 수 있습니다.</p>

<h4 id="dns란-무엇인가">DNS란 무엇인가</h4>

<p>브라우저에서 실제로 통신을 할 대상을 지정할 때 ip주소를 입력해도 되지만 대부분의 경우에는 도메인 주소를 입력하게 됩니다. ip주소가 아님에도 불구하고 원하는 대상과 통신을 할 수 있는 이유는 DNS(Domain Name System)에게 적절한 ip를 받을 수 있기 때문입니다. DNS 서버는 도메인 주소와 그에 대응되는 ip주소를 저장하고 있는 서버 입니다. 브라우저에서 도메인을 입력해서 요청을 하는 순간 DNS 서버에 도메인 주소를 전달하면서 그에 대응되는 ip주소를 돌려달라고 요청을 먼저 하게 되고 그렇게 전달 받은 ip 주소를 이용해서 실제 네트워크 통신이 시작됩니다.</p>

<h4 id="dns-서버에-요청을-보내는-건-소켓-라이브러리의-dns-리졸버다">DNS 서버에 요청을 보내는 건 소켓 라이브러리의 DNS 리졸버다</h4>

<p>DNS 서버에 ip 주소를 찾기 위한 요청은 <strong>DNS 리졸버</strong>가 보내게 됩니다. DNS 서버를 통해서 ip 주소를 조사하는 것을 name resolution(이름 확인)이라고 하는데, 이를 실행하는 것이 DNS 리졸버 입니다.
리졸버는 소켓 라이브러리에 포함된 루틴(<code class="language-plaintext highlighter-rouge">gethostbyname(&lt;domain name&gt;)</code>) 입니다. 소켓 라이브러리는 애플리케이션 레벨에서 네트워크 통신에 필요한 동작을 OS에 의뢰하기 위한 많은 루틴들을 포함하고 있습니다. 리졸버도 애플리케이션에서 OS에 작업 의뢰를 하기 위한 많은 인터페이스들 중 하나라고 이해하면 되겠습니다.</p>

<p>애플리케이션에서 name resolution을 하기 위해서 소켓 라이브러리의 리졸버를 호출하면 다음과 같은 동작이 발생합니다.</p>

<ol>
  <li>DNS 서버에 보낼 요청 메시지를 만든다.</li>
  <li>프로토콜 스택에 의뢰하여 DNS 서버에 전송한다.</li>
  <li>프로토콜 스택이 DNS에서 돌아온 응답 메시지를 수신하면 리졸버에게 반환한다.</li>
  <li>리졸버는 응답 메시지에서 ip 주소를 추출해서 애플리케이션에게 반환하고 애플리케이션은 그 ip 주소를 자신이 관리하는 변수에 저장한다.</li>
</ol>

<p><strong>프로토콜 스택</strong>은 DNS 서버와의 통신뿐만 아니라 모든 네트워크 통신에 필요한 동작을 담당하는 OS에 포함되어있는 프로그램입니다. 프로토콜 스택이 실제로 어떻게 동작하는지는 뒤에서 살펴보겠습니다.</p>

<h3 id="ip주소는-여러-dns가-연대해서-찾는다">ip주소는 여러 DNS가 연대해서 찾는다</h3>

<h4 id="dns-서버가-ip를-찾는-과정">DNS 서버가 ip를 찾는 과정</h4>

<p>앞에서 클라이언트가 도메인 주소를 통해서 ip 주소를 찾기 위해서 DNS 서버에 요청을 보내는 과정을 살펴봤으면 이제 요청을 받은 DNS 서버가 실제로 ip를 어떻게 찾는지 알아보겠습니다.</p>

<p>클라이언트로부터 받은 조회 메시지에는 다음의 3가지 정보가 포함되어있습니다.</p>

<ul>
  <li>이름: 서버나 메일 배송 목적지(메일 주소에서 @ 뒷부분)와 같은 이름</li>
  <li>클래스: DNS의 구조를 고안했을 때 인터넷 이외의 네트워크에서의 동작까지 고려해서 만든 네트워크 식별을 위한 값으로, 지금은 인터넷 이외의 네트워크는 소멸했기에 클래스는 항상 인터넷을 의미하는 ‘IN’이 사용됨</li>
  <li>타입: 이름에 어떤 타입의 정보가 지원되는지를 표시한 것으로 ‘A’면 이름에 ip 주소가 지원됨을, ‘MX(Mail eXcahnge)’이면 이름에 메일 목적지가 지원됨을 나타냄</li>
</ul>

<p>DNS 서버는 위의 3가지 정보에 대응하는 ip주소나 메일의 배송 목적지를 설정 파일에 기록해두었습니다.</p>

<table>
  <thead>
    <tr>
      <th>이름</th>
      <th>클래스</th>
      <th>타입</th>
      <th>클라이언트에 회답하는 항목</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>www.lab.cyber.co.kr</td>
      <td>IN</td>
      <td>A</td>
      <td>192.0.2.226</td>
    </tr>
    <tr>
      <td>cyber.co.kr</td>
      <td>IN</td>
      <td>MX</td>
      <td>10 mail.cyber.co.kr</td>
    </tr>
    <tr>
      <td>mail.cyber.co.kr</td>
      <td>IN</td>
      <td>A</td>
      <td>192.0,2.227</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
      <td>…</td>
      <td>…</td>
    </tr>
  </tbody>
</table>

<p>위의 표가 DNS 서버가 관리하는 설정 파일에 들어있는 데이터 예시입니다. DNS 서버는 요청 메시지에 기재된 3가지 정보를 통해서 표에서 <code class="language-plaintext highlighter-rouge">클라이언트에 회답하는 항목</code>을 찾아서 응답하게 됩니다. 예를 들어 ‘www.lab.cyber.co.kr’의 ip주소를 조사하고 싶다면 클라이언트는 DNS 서버에 다음과 같은 정보를 포함해서 메시지를 보내는 겁니다.</p>

<ul>
  <li>이름: www.lab.cyber.co.kr</li>
  <li>클래스: IN</li>
  <li>타입: A</li>
</ul>

<p>그럼 DNS 서버는 192.0.2.226을 클라이언트에 응답해주게 됩니다. 그럼 메일 배송 목적지를 조회할 때 사용하는 MX에 대해서도 살펴보겠습니다. 예를 들면 ‘tone@cyber.co.kr’이라는 메일 주소가 있을 때 목적지 메일 서버의 이름은 @ 뒤에 있는 이름이 됩니다. 그럼 조회 메시지는 다음과 같습니다.</p>

<ul>
  <li>이름: cyber.co.kr</li>
  <li>클래스: IN</li>
  <li>타입: MX</li>
</ul>

<p>위 표를 기준으로 DNS 서버는 ‘10’과 ‘mail.cyber.co.kr’이라는 두 값을 담아서 응답합니다. 여기서 숫자는 메일 서버의 우선순위를 의미합니다. 메일의 전송 목적지로 복수의 메일 서버가 등록되어있으면 어느 메일 서버를 우선 선택할지 판단하기 위한 값으로, 값이 작을수록 우선순위가 높습니다.
그런데 잘 보면 여기서 끝이 아닙니다. 어떠한 경우가 되었든 네트워크 통신은 ip를 통해서 이루어지기 때문에 저 전송 목적지의 ip주소를 찾아서 함께 담아서 응답하게 됩니다. 위의 표에서는 ‘192.0.2.227’이 됩니다.</p>

<h4 id="dns-서버들은-도메인-주소를-기반으로-계층화되어있다">DNS 서버’들’은 도메인 주소를 기반으로 계층화되어있다</h4>

<p>사실 앞에서는 DNS 서버가 한대인 것을 가정해서 설명했습니다. 하지만 현실에는 엄청난 수의 서버가 있기에 1대의 DNS 서버만으로 운용하는 것은 불가능합니다. 그래서 실제로는 여러 대의 DNS 서버가 요청을 주고받으면서 최종적인 ip 주소를 찾게 됩니다. 하지만 각각의 DNS 서버가 응답할 값을 찾는 과정은 위에서 설명한 것과 동일하기 때문에 결국 DNS 서버들이 어떤 <strong>구조</strong> 속에서 통신하는지만 이해하면 됩니다.</p>

<p>DNS 서버들의 구조를 이해하려면 먼저 <strong>도메인의 계층</strong>에 대해서 이해해야 합니다. 도메인 주소는 <code class="language-plaintext highlighter-rouge">.</code>으로 구분되는데, 이 점이 계층을 구분합니다. 오른쪽 끝이 최상위, 왼쪽 끝이 최 하위 계층이 됩니다. ‘www.lab.cyber.com’을 예로 들면, ‘com’이 최상위 계층이 되고, ‘www’는 최하위 계층이 됩니다. 회사의 조직으로 비유해보면, ‘com 사업부 cyber 부 lab과의 www씨’ 정도가 됩니다. 그리고 저 각각의 계층화된 주체가 바로 <strong>도메인</strong>입니다. 결국 도메인 주소는 com, cyber, lab, www와 같은 도메인들을 <code class="language-plaintext highlighter-rouge">.</code>으로 계층화한 값이라고 볼 수 있습니다.</p>

<p>다시 DNS 서버로 돌아와보면 DNS 서버들은 계층화된 도메인들을 하나씩 맡아서 저장하게 됩니다. 이때 <strong>하위의 도메인을 담당하는 DNS 서버의 주소를 그 상위의 DNS 서버에 등록합니다.</strong> 예를 들면 <code class="language-plaintext highlighter-rouge">lab.glasscom.com</code>이라는 도메인을 담당하는 DNS 서버를 <code class="language-plaintext highlighter-rouge">glasscom.com</code>의 DNS 서버에 등록하고, <code class="language-plaintext highlighter-rouge">glasscom.com</code>의 DNS 서버를 <code class="language-plaintext highlighter-rouge">com</code> 도메인의 DNS 서버에 등록하는 식입니다. 그럼 상위의 DNS 서버에서 하위 DNS 서버의 ip 주소를 알 수 있고, 그 서버에 조회 메시지를 보내서 다시 그 하위 DNS 서버의 ip주소를 받음으로써 실제 타겟 서버의 ip주소를 조회할 때까지 계층적으로 타고 내려갈 수 있게 됩니다. 결국 <strong>DNS 서버는 도메인 주소와 같은 계층화된 구조를 가지는 것</strong>입니다.</p>

<h4 id="세상의-모든-dns-서버는-root-도메인의-dns-서버-주소를-알아야-한다">세상의 모든 DNS 서버는 root 도메인의 DNS 서버 주소를 알아야 한다</h4>

<p>그럼 DNS 서버가 실제로 ip 주소를 찾는 과정을 좀 더 구체적으로 살펴보기에 앞서 DNS 서버들이 갖추어야 할 준비사항을 살펴보겠습니다. 우리가 살펴봤던 ‘lab.glasscom.com’에서 ‘com’이 최상위 계층이지만 사실 그 위에는 <strong>root 도메인</strong>이 존재합니다. 이 도메인이 진짜 최상위 도메인이고 이 루트 도메인의 DNS 서버에 ‘com’, ‘kr’같은 도메인의 DNS 서버를 등록하게 됩니다. ip 조회 작업은 항상 root 도메인의 DNS 서버에서부터 시작하고 그 하위 DNS 서버로 타고 내려가면서 진행됩니다. 항상 root 도메인에서부터 조회가 시작되어야하기 때문에 <strong>세상에 존재하는 모든 DNS 서버는 root 도메인의 DNS 서버를 등록한 상태</strong>입니다. 그래야 어떤 지역의 DNS서버로 요청을 보내도 그 요청을 다시 root 도메인의 DNS 서버로 보낼 수 있기 때문입니다.</p>

<h4 id="dns-서버가-ip를-찾는-실제-과정">DNS 서버가 ip를 찾는 실제 과정</h4>

<p>이제 모든 준비가 끝났습니다. 클라이언트가 ‘www.lab.glasscom.com’이라는 웹 서버에 관한 정보를 조회하기 위해서 클라이언트 pc에 설정된 DNS 서버로 조회 요청을 보내면 다음과 같은 일들이 벌어집니다. 편의상 클라이언트에게 최초 요청을 받은, 즉 클라이언트에게 ip를 찾아서 응답해줄 의무를 가지는 DNS 서버를 ‘A 서버’라고 칭하도록 하겠습니다.</p>

<ul>
  <li>최초 요청을 받은 A 서버에는 ‘www.lab.glasscom.com’이라는 이름이 등록되어 있지 않기에 root 도메인의 DNS 서버에 클라이언트로부터 받은 메시지를 전송</li>
  <li>root 도메인의 DNS 서버는 마지막 도메인이 ‘com’인 것을 확인하고 ‘com’ 도메인의 DNS 서버의 ip 주소를 A 서버에 응답</li>
  <li>A 서버는 응답받은 ip를 이용하여 ‘com’ 도메인이 있는 DNS 서버에 조회 요청</li>
  <li>‘com’ 도메인의 DNS 서버에도 ‘www.lab.glasscom.com’는 등록되어있지 않기 때문에 ‘com’의 아래에 있는 ‘glasscom.com’ 도메인의 DNS 서버의 ip 주소를 A 서버에 응답</li>
  <li>A 서버는 응답받은 ip를 이용하여 ‘glasscom.com’ 도메인의 DNS 서버에 조회 요청</li>
  <li>‘glasscom.com’ 도메인의 DNS 서버에도 ‘www.lab.glasscom.com’는 등록되어있지 않기 때문에 ‘glasscom.com’의 아래에 있는 ‘lab.glasscom.com’ 도메인의 DNS 서버의 ip 주소를 A 서버에 응답</li>
  <li>A 서버는 응답받은 ip를 이용하여 ‘lab.glasscom.com’ 도메인이 있는 DNS 서버에 조회 요청</li>
  <li>‘lab.glasscom.com’ 도메인의 DNS 서버에는 ‘www.lab.glasscom.com’의 ip 주소가 있기 때문에 여기서 ip 주소를 응답받으면 A 서버는 클라이언트에 해당 ip 주소를 반환</li>
</ul>

<p>이처럼 하나의 도메인 이름에 대응되는 ip를 찾으려면 여러 개의 DNS 서버에 요청을 보내야 합니다. 그런데 지금까지 살펴본 DNS 서버의 탐험은 DNS 서버 하나에 도메인 하나를 저장한 경우를 가정했지만, 현실에서는 한 대의 DNS 서버에 복수의 도메인 정보를 가질 수도 있습니다. 즉 상위와 하위 도메인을 같은 DNS 서버에 등록할 수도 있는데, 이 경우에 상위 DNS 서버에 조회를 하면 하위 DNS 서버를 하나 건너뛰고 그 아래의 DNS 서버에 관한 정보가 돌아옵니다.</p>

<h4 id="dns-서버는-캐싱을-통해-응답-속도를-높일-수-있다">DNS 서버는 캐싱을 통해 응답 속도를 높일 수 있다</h4>

<p>앞선 DNS 서버의 ip 조회 과정에서 꽤나 많은 요청과 응답이 필요하다는 것을 알게 됐습니다. 다소 비효율적인 것처럼 보이는데, 여기에 한 번 조사한 이름을 캐시에 기록하여 root 도메인의 DNS 서버부터 최하위 도메인의 DNS서버까지 요청을 보내지 않고 바로 응답을 내려줄 수 있습니다. 이렇게 하면 캐시 미스가 나는 경우에 한해서만 앞서 살펴본 과정을 거쳐서 ip를 획득하면 됩니다.</p>

<p>하지만 캐싱을 적용할 때는 DNS 서버의 정보와 캐시에 저장된 정보의 동기화에 주의해야 합니다. 캐시에 정보를 저장한 후에 DNS 서버의 등록 정보가 변경되면, 캐시에 저장된 정보는 더 이상 유효하다고 할 수 없기 때문입니다. 그래서 DNS 서버에 등록하는 정보에는 유효기간을 설정하고, 캐시에 저장한 데이터의 유효기간이 지나면 캐시에서 삭제하게 됩니다. 그리고 조회에 응답할 때 정보가 캐싱된 정보인지, 등록처 DNS 서버에서 직접 응답을 받은 것인지 알려주게 됩니다.</p>

<h3 id="os의-프로토콜-스택에-메시지-송신을-의뢰한다">OS의 프로토콜 스택에 메시지 송신을 의뢰한다</h3>

<p>ip 주소까지 구했으면 이제 통신 대상 서버에 메시지를 송신하도록 OS의 <strong>프로토콜 스택</strong>에 의뢰하게 됩니다. 이 과정에서도 소켓 라이브러리의 루틴들을 호출하게 됩니다. 메시지를 송신하는 일련의 절차들을 알아보면서 각 절차들에서 호출되어야 하는 루틴들을 함께 살펴보겠습니다. 앞서 DNS 리졸버에서도 살펴봤지만 소켓 라이브러리는 애플리케이션이 OS의 프로토콜 스택에 필요한 동작을 의뢰하는 인터페이스 역할을 담당합니다. 소켓 라이브러리 자체가 통신에 필요한 직접적인 동작을 하지 않는다는 것을 명심하세요.</p>

<h4 id="소켓의-작성-단계">소켓의 작성 단계</h4>

<p><code class="language-plaintext highlighter-rouge">gethostbyname</code>을 호출하고나면 다음으로는 소켓 생성을 위해서 <code class="language-plaintext highlighter-rouge">socket(&lt;IPv4 사용&gt;, &lt;스트림형&gt;, ...)</code>을 호출하게 됩니다. 여기서 ‘소켓’은 ‘소켓 라이브러리’에서의 소켓과는 조금 다른 의미로 쓰였는데요. 여기서는 간단하게 ‘통신의 출입구’ 정도로 이해하면 됩니다. 자세한 의미는 2장에서 살펴봅니다. <code class="language-plaintext highlighter-rouge">socket()</code>을 호출해서 소켓을 생성하면 <strong>디스크립터</strong>가 반환됩니다. 디스크립터는 소켓을 식별하기 위한 식별값입니다. 컴퓨터는 동시다발적으로 여러 서버와 통신하는 일이 비일비재하기 때문에 복수의 소켓이 동일한 시점에 존재할 가능성이 높습니다. 이런 상황에서 프로토콜 스택이 각각의 소켓을 식별할 필요가 있기 때문에 디스크립터를 쓰는 것입니다. 이 디스크립터는 애플리케이션의 메모리에 저장한 후 이후 루틴의 인자로 전달됩니다.</p>

<h4 id="두-노드-간의-파이프를-연결하는-접속-단계">두 노드 간의 파이프를 연결하는 접속 단계</h4>

<p>소켓을 만들었으면 그 소켓을 서버측의 소켓에 접속하도록 프로토콜 스택에 의뢰합니다. 이때 사용하는 루틴은 <code class="language-plaintext highlighter-rouge">connect(&lt;디스크립터&gt;, &lt;서버의 ip 주소와 포트 번호&gt;)</code>입니다. 앞서 소켓 생성의 결과로 반환받은 디스크립터를 인자로 전달하여 어떤 소켓으로 서버 소켓에 연결해야하는지 찾습니다. ip 주소와 포트 번호도 인자로 전달하는데, ip 주소로는 통신 대상 노드를 찾고, 포트 번호로 그 노드의 연결할 소켓을 찾게 됩니다. 이때 소켓을 찾는다는 말은 결국 애플리케이션을 찾는다는 말과 같기 때문에 포트 번호를 통해서 통신 노드 내에서 어떤 애플리케이션과 연결을 할지를 결정한다고 봐도 좋습니다.</p>

<p>그럼 서버도 클라이언트의 어떤 소켓과 통신해야할지 알아야 하기 때문에 클라이언트의 포터번호가 필요할 것입니다. 클라이언트 소켓의 포트 번호는 소켓을 생성할 당시에 프로토콜 스택이 적당한 값을 골라서 할당하게 됩니다. 그리고 접속 동작 시에 서버측에 통지해줍니다. 자세한 과정은 2장에서 설명합니다.</p>

<p>이렇게 <code class="language-plaintext highlighter-rouge">connect()</code>를 호출해서 프로토콜 스택이 접속 동작을 실행하고 상대와 연결되면 프로토콜 스택은 연결된 상대의 ip 주소나 포트 번호 등의 정보를 소켓에 기록합니다. 이제 데이터의 송/수신이 가능한 상태가 됐습니다.</p>

<h4 id="메시지를-주고-받는-송수신-단계">메시지를 주고 받는 송/수신 단계</h4>

<p>양쪽 소켓이 연결되었으면 <code class="language-plaintext highlighter-rouge">write(&lt;디스크립터&gt;, &lt;송신 데이터&gt;, &lt;송신 데이터 길이&gt;)</code> 루틴을 호출해서 프로토콜 스택이 송신 데이터를 서버에게 송신하게 합니다. 이미 소켓에는 통신 상대 소켓에 대한 정보가 기록되어 있기 때문에 바로 전송을 할 수 있습니다. 서버는 수신 동작을 통해 받은 데이터에 대한 적절한 처리를 하고 응답 메시지를 반송합니다. 그럼 <code class="language-plaintext highlighter-rouge">read(&lt;디스크립터&gt;, &lt;수신 버퍼&gt;, ...)</code>라는 루틴을 통해서 프로토콜 스택에 수신 동작을 의뢰할 수 있습니다. 수신한 응답 메시지는 <strong>수신 버퍼</strong>라는 메모리 영역에 저장합니다. 이 버퍼는 애플리케이션에 할당된 메모리 공간이기 때문에 애플리케이션이 접근해서 읽게 됩니다.</p>

<h4 id="송수신을-종료하는-연결-끊기-단계">송/수신을 종료하는 연결 끊기 단계</h4>

<p>통신이 모두 끝나면 <code class="language-plaintext highlighter-rouge">close(&lt;디스크립터&gt;)</code> 루틴을 호출해서 프로토콜 스택이 연결 끊기 동작을 수행하게 합니다. 일반적으로 HTTP1.0에서는 서버쪽에서 먼저 연결 끊기 동작을 실행합니다.(HTTP 1.1 버전에서는 요청할 데이터가 없어진 상태가 되면 브라우저에서 연결 끊기를 먼저 들어갈 수도 있습니다.) 이때 끊기 동작이 수행되었다는 것을 클라이언트에 전달하게 되는데, 그럼 클라이언트 애플리케이션도 <code class="language-plaintext highlighter-rouge">read()</code> 루틴으로 그 사실을 전달받고 <code class="language-plaintext highlighter-rouge">close()</code>를 호출해서 연결 끊기 단계에 들어갑니다. 디스크립터를 인자로 전달하는 것은 여러 소켓 중에 말소시킬 소켓을 찾아야하기 때문입니다.</p>

    
  </section>

  <!-- Social media shares -->
  

<div class="share-buttons">
    <ul class="share-buttons">
        <div class="meta">Share</div>
        
        <li>
            <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fanstn1993.github.io%2F2022%2F01%2F18%2F%25EC%2584%25B1%25EA%25B3%25B5%25EA%25B3%25BC-%25EC%258B%25A4%25ED%258C%25A8%25EB%25A5%25BC-%25EA%25B2%25B0%25EC%25A0%2595%25ED%2595%2598%25EB%258A%2594-1-%25EC%259D%2598-%25EB%2584%25A4%25ED%258A%25B8%25EC%259B%258C%25ED%2581%25AC-%25EC%259B%2590%25EB%25A6%25AC-1%25EC%259E%25A5.html" target="_blank" title=" Facebook">
			<i class="fa fa-facebook-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Share on Facebook</span>
		</a>
        </li>
         
        <li>
            <a href="https://twitter.com/intent/tweet?text=%EC%84%B1%EA%B3%B5%EA%B3%BC+%EC%8B%A4%ED%8C%A8%EB%A5%BC+%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94+1%25%EC%9D%98+%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC+%EC%9B%90%EB%A6%AC+1%EC%9E%A5%20https%3A%2F%2Fanstn1993.github.io%2F2022%2F01%2F18%2F%25EC%2584%25B1%25EA%25B3%25B5%25EA%25B3%25BC-%25EC%258B%25A4%25ED%258C%25A8%25EB%25A5%25BC-%25EA%25B2%25B0%25EC%25A0%2595%25ED%2595%2598%25EB%258A%2594-1-%25EC%259D%2598-%25EB%2584%25A4%25ED%258A%25B8%25EC%259B%258C%25ED%2581%25AC-%25EC%259B%2590%25EB%25A6%25AC-1%25EC%259E%25A5.html" target="_blank" title="">
			<i class="fa fa-twitter-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Tweet</span>
		</a>
        </li>
            
        <li>
            <a href="http://www.reddit.com/submit?url=https://anstn1993.github.io/2022/01/18/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-1%EC%9E%A5.html&title=%EC%84%B1%EA%B3%B5%EA%B3%BC+%EC%8B%A4%ED%8C%A8%EB%A5%BC+%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94+1%25%EC%9D%98+%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC+%EC%9B%90%EB%A6%AC+1%EC%9E%A5%20%7C%20MunSooKim%27s+devlog" target="_blank" title=" Reddit">
			<i class="fa fa-reddit-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Share on Reddit</span>
		</a>
        </li>
           
        <li>
            <a href="mailto:?subject=%EC%84%B1%EA%B3%B5%EA%B3%BC+%EC%8B%A4%ED%8C%A8%EB%A5%BC+%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94+1%25%EC%9D%98+%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC+%EC%9B%90%EB%A6%AC+1%EC%9E%A5%20%7C%20MunSooKim%27s+devlog&body=:%20https://anstn1993.github.io/2022/01/18/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-1%EC%9E%A5.html" target="_blank" title="">
			<i class="fa fa-envelope-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Email</span>
		</a>
        </li>
        
    </ul>
</div>




   <!-- Tag list -->
  
  


<footer>
  <div class="tag-list">
    
      <div class="meta">Tags</div>
    

    
    <a class="button" href="/tags#CS">
      <p><i class="fa fa-tag fa-fw"></i> CS</p>
    </a>
    
    <a class="button" href="/tags#%EA%B8%B0%EC%88%A0">
      <p><i class="fa fa-tag fa-fw"></i> 기술</p>
    </a>
    
  </div>
</footer>


</article>

<!-- Disqus -->

<div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname = 'https-anstn1993-github-io';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view comments.</noscript>
</div>


<!-- Post navigation -->

  <div id="post-nav">
    
    <div id="previous-post">
        <a alt="성공과 실패를 결정하는 1%의 네트워크 원리 2장" href="/2022/01/25/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-2%EC%9E%A5.html">
            <p>Previous post</p>
            성공과 실패를 결정하는 1%의 네트워크 원리 2장
        </a>
    </div>
    

    
    <div id="next-post">
        <a alt="실용주의 프로그래머 8장" href="/2021/12/22/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-8%EC%9E%A5.html">
            <p>Next post</p>
            실용주의 프로그래머 8장
        </a>
    </div>
    
</div>



<!-- To change color of links in the page -->
<style>
  
  .feature-image a { color: brown !important; }
  div#post-nav a { color: brown !important; }
  footer a { color: brown !important; }
  .site-header nav a:hover {  color: brown !important; }
  header#main { background-color: brown !important; }
  

  header#main {
    background-repeat:no-repeat;
  background-image: url('/assets/img/lineart.png');  
  }
</style>

    </div>
    <footer class="site-footer">
    <p class="text">
         </p>
            <div class="footer-icons">
                <ul>
                <!-- Social icons from Font Awesome, if enabled -->
                


<li>
    <a href="mailto:anstn1993@gmail.com" title="Email">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
        </span>
    </a>
</li>













<li>
    <a href="https://github.com/anstn1993" title="Follow on GitHub">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-github fa-stack-1x fa-inverse"></i>
        </span>
    </a>
</li>
































                </ul>
            </div>
</footer>



  </body>
</html>
