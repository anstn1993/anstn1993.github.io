[
  
  {
    "title"    : "spring boot에 대하여",
    "category" : "",
    "tags"     : " 기술, spring",
    "url"      : "/2020/02/04/spring-boot%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC.html",
    "date"     : "February 4, 2020",
    "excerpt"  : "spring boot는 순수 spring으로만 개발할 때 개발자가 직접 해야 할 아주 많은 일들을 대신 해줌으로써 생산성을 많이 높여줍니다. 그럼 spring boot가 개발자들을 위해서 어떤 것들을 해주는지 살펴보겠습니다.\n\n의존성 관리\n\nspring boot는 주요 프로젝트들의 의존성을 편리하게 관리해줍니다. 일반적으로 pom.xml파일에 dependency를 추가할 때는 버전 정보를 함께 명시해야 하는데요. spring boot의 d...",
  "content"  : "spring boot는 순수 spring으로만 개발할 때 개발자가 직접 해야 할 아주 많은 일들을 대신 해줌으로써 생산성을 많이 높여줍니다. 그럼 spring boot가 개발자들을 위해서 어떤 것들을 해주는지 살펴보겠습니다.\n\n의존성 관리\n\nspring boot는 주요 프로젝트들의 의존성을 편리하게 관리해줍니다. 일반적으로 pom.xml파일에 dependency를 추가할 때는 버전 정보를 함께 명시해야 하는데요. spring boot의 dependency를 보시면 버전 정보가 없는 것을 확인하실 수 있습니다.\n\n\n  pom.xml\n      ...\n  &amp;lt;parent&amp;gt;\n          &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n          &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;\n          &amp;lt;version&amp;gt;2.3.8.RELEASE&amp;lt;/version&amp;gt;\n          &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;\n  &amp;lt;/parent&amp;gt;\n  ...\n  &amp;lt;dependencies&amp;gt;\n      &amp;lt;dependency&amp;gt;\n          &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n          &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;\n      &amp;lt;/dependency&amp;gt;\n      &amp;lt;dependency&amp;gt;\n          &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n          &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;\n      &amp;lt;/dependency&amp;gt;\n  &amp;lt;dependencies&amp;gt;\n    \n    위에서 확인할 수 있듯이 버전에 대한 정보를 명시하지 않고 있습니다. spring boot가 알아서 적절한 버전을 가져와주기 때문입니다. 각 프로젝트들의 버전 정보는 parent태그에 명시된 spring-boot-starter-parent artifact에 정의되어 있습니다. 맥은 command를, 윈도우는 control키를 누르고 artifact명을 클릭하면 아래의 파일에 접근하게 됩니다.\n  \n\n\n\n\n\n  spring-boot-starter-parent-2.3.8.RELEASE.pom\n      ...\n  &amp;lt;parent&amp;gt;\n      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n      &amp;lt;artifactId&amp;gt;spring-boot-dependencies&amp;lt;/artifactId&amp;gt;\n      &amp;lt;version&amp;gt;2.3.8.RELEASE&amp;lt;/version&amp;gt;\n  &amp;lt;/parent&amp;gt;\n  ...\n    \n    여기서 다시 한 번 spring-boot-dependencies를 타고 들어가봅니다.\n  \n\n\n\n\n\n  spring-boot-dependencies-2.3.8.RELEASE.pom\n      ...\n  &amp;lt;dependencyManagement&amp;gt;\n      ...\n      &amp;lt;dependency&amp;gt;\n          &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n          &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;\n          &amp;lt;version&amp;gt;2.3.8.RELEASE&amp;lt;/version&amp;gt;\n      &amp;lt;/dependency&amp;gt;\n      ...\n  &amp;lt;/dependencyManagement&amp;gt;\n  ...\n    \n    네 드디어 도착입니다. 위 파일의 dependencyManagement태그에 각 프로젝트들에 대한 버전 정보를 명시해두고 있습니다. 저희가 pom.xml에 직접 추가하는 의존성들에 대한 버전은 이 파일에 명시된 버전으로 설정됩니다. 즉 pom.xml파일은 위의 부모 설정들을 상속받아서 버전을 정의하게 되는 겁니다.\n  \n\n\n그리고 이렇게 버전을 대신 관리해주게 되면 의존성 간의 버전 호환성에 대한 걱정도 할 필요가 없어집니다. spring boot가 의존성을 추가할 때 알아서 설정된 버전과 호환되는 버전으로 추가를 해주기 때문입니다.\n\n만약 pom.xml파일에 의존성을 추가할 때 개발자가 직접 버전을 명시하게 되면 부모 설정을 오버라이딩하여 개발자가 명시한 버전으로 의존성을 추가하게 됩니다.\n\n@SpringBootApplication\n\nspring은 xml이나 자바 설정을 통해서 빈을 ioc컨테이너에 등록할 수 있습니다. 특히 자바 설정을 이용할 때는 자바 config파일을 만들어서 @Configuration, @ComponentScan과 같은 annotation을 사용해서 아래와 같이 만들 수 있습니다.\n\n\n  AppConfig.java(제가 임의로 만든 파일입니다. spring boot프로젝트에는 존재하지 않습니다.)\n      @Configuration\n  @ComponentScan(basePackageClass = SampleTicketApplication.class)\n  public class AppConfig {\n        \n  }\n    \n    위의 파일을 패키지의 루트에 위치시키면 그 파일과 같은 depth에 위치한 자바 파일과 패키지들에 존재하는 자바 파일까지 스캔을 하면서 @Controller, @Service, @Configuration, @Repository와 같은 컴포넌트 annotation이 붙은 클래스들을 모두 빈으로 등록하게 됩니다.\n\n    하지만 spring boot프로젝트를 만들면 위와 같은 설정 파일이 없음에도 불구하고 빈들이 잘 등록됩니다. 그 역할을 @SpringBootApplication이 하게 됩니다. 이 annotation은 프로젝트를 처음 생성하면 루트 패키지의 Application 클래스에 붙게 됩니다.\n  \n\n\n\n\n\n  SampleTicketApplication.java\n      @SpringBootApplication\n  public class SampleTicketApplication {\n      public static void main(String[] args) {\n          SpringApplication.run(SampleTicketApplication.class, args);\n      }\n  }\n    \n    spring boot프로젝트를 처음 생성하면 패키지의 루트에 위치하는 Application 클래스 입니다. 이 클래스에서 애플리케이션을 실행하게 되죠. @SpringBootApplication을 타고 들어가보면 아래와 같은 파일이 나오게 됩니다.\n  \n\n\n\n\n\n  SpringBootApplication.java\n      @Target({ElementType.TYPE})\n  @Retention(RetentionPolicy.RUNTIME)\n  @Documented\n  @Inherited\n  @SpringBootConfiguration\n  @EnableAutoConfiguration\n  @ComponentScan(\n      excludeFilters = {@Filter(\n      type = FilterType.CUSTOM,\n      classes = {TypeExcludeFilter.class}\n  ), @Filter(\n      type = FilterType.CUSTOM,\n      classes = {AutoConfigurationExcludeFilter.class}\n  )}\n  )\n  public @interface SpringBootApplication {\n      ...\n  }\n    \n    @SpringBootApplication에 @ComponentScan과 @SpringBootConfiguration이 붙은 것을 확인하실 수 있습니다. @SpringBootConfiguration을 타고 들어가보시면 @Configuration이 붙은 것을 확인하실 수 있습니다. 즉 @SpringBootApplication이 붙은 Application 클래스가 빈을 등록하기 위한 자바 설정 파일의 역할을 겸하고 있는 것입니다.\n  \n\n\n자동 설정\n\n@SpringBootApplication을 통해서 컴포넌트 annotation이 붙은 클래스들을 알아서 빈으로 등록해준다는 것을 확인했습니다. 그런데 이렇게 개발자가 직접 정의한 빈 이외에도 spring boot가 정의해둔 유용한 빈들이 ioc컨테이너에 추가됩니다. 이 기능도 @SpringBootApplication에 붙은 @EnableAutoConfiguration 때문에 동작합니다.\n\n그럼 이 자동으로 등록되는 빈은 어디에서 스캔되는 걸까요?\n\n    \n\n\n    \n\nIntelliJ의 좌측 프로잭트 구조에서 하단의 External Libraries에 여러 의존성들 중 위의 이미지에 보이는 spring-boot-autoconfigure프로젝트의 spriing.factories파일에 명시되어 있습니다.\n\n\n  \n    spring.factories\n\n      # Auto Configure\n  org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\n  ...\n  org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\\n  org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\\n  org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\\n  org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\\n  org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\\n  ...\n    \n    위와 같이 EnableAutoConfiguration에 명시된 Configuration파일들이 빈으로 등록됩니다. 대표적으로 WebMvcAutoConfiguration만 살펴보겠습니다.\n  \n\n\n\n\n\n  WebMvcAutoConfiguration.java\n      @Configuration(\n      proxyBeanMethods = false\n  )\n  @ConditionalOnWebApplication(\n      type = Type.SERVLET\n  )\n  @ConditionalOnClass({Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class})\n  @ConditionalOnMissingBean({WebMvcConfigurationSupport.class})\n  @AutoConfigureOrder(-2147483638)\n  @AutoConfigureAfter({DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class})\n  public class WebMvcAutoConfiguration {\n\n      ...\n\n      @Configuration(\n          proxyBeanMethods = false\n      )\n      public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware {\n\n          ...\n\n          @Bean\n          public RequestMappingHandlerAdapter requestMappingHandlerAdapter(@Qualifier(&quot;mvcContentNegotiationManager&quot;) ContentNegotiationManager contentNegotiationManager, @Qualifier(&quot;mvcConversionService&quot;) FormattingConversionService conversionService, @Qualifier(&quot;mvcValidator&quot;) Validator validator) {\n              RequestMappingHandlerAdapter adapter = super.requestMappingHandlerAdapter(contentNegotiationManager, conversionService, validator);\n              adapter.setIgnoreDefaultModelOnRedirect(this.mvcProperties == null || this.mvcProperties.isIgnoreDefaultModelOnRedirect());\n              return adapter;\n          }\n\n          ...\n\n          @Bean\n          @Primary\n          public RequestMappingHandlerMapping requestMappingHandlerMapping(@Qualifier(&quot;mvcContentNegotiationManager&quot;) ContentNegotiationManager contentNegotiationManager, @Qualifier(&quot;mvcConversionService&quot;) FormattingConversionService conversionService, @Qualifier(&quot;mvcResourceUrlProvider&quot;) ResourceUrlProvider resourceUrlProvider) {\n              return super.requestMappingHandlerMapping(contentNegotiationManager, conversionService, resourceUrlProvider);\n          }\n\n          ...\n      }\n  }\n    \n    위 설정 파일을 보면 @Configuration이 붙어있습니다. 즉 spring.factories에 명시된 설정 파일을 빈으로 등록하고 그 설정 파일에 있는 빈들이 등록되는 것입니다. 여러 빈들 중 HandlerMapping, HandlerAdapter와 같이 spring mvc가 제공하는 dispatcher servlet의 전략 인터페이스들이 빈으로 등록되는 것을 확인할 수 있습니다.\n  \n\n\n정리해보면 spring boot는 사용자가 정의한 빈을 등록하고 자동 설정에 등록된 빈을 등록하는 두 단계를 거치게 되는 겁니다.\n\n내장 was\nspring boot는 was가 프로젝트에 내장되어 있습니다. 즉 jar로 패키징을 해서 실행을 하는 것만으로 서버에 애플리케이션을 바로 띄울 수 있게 됩니다. 이 기능도 앞서 살펴본 자동 설정과 관련됩니다.\n\n\n  \n    spring.factories\n\n      # Auto Configure\n  org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\n  ...\n  org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\\n  ...\n    \n    앞서 살펴본 spring.factories파일에 명시된 ServletWebServerFactoryAutoConfiguration.java에 내장 was와 관련된 빈들이 등록되어 있습니다.\n  \n\n\n마치며\n지금까지 spring boot가 어떤 역할을 하는지 몇 가지 살펴봤는데요. 저의 글이 조금이나마 도움이 됐으면 좋겠습니다. 이외에도 spring boot가 우리에게 제공해주는 효용은 더 많습니다. 저도 공부를 하는 입장이다보니 다 알지 못 하고 틀린 내용이 있을 수 있습니다. 틀린 내용이 있거나 다른 좋은 기능이 있다면 댓글로 알려주시면 굉장히 감사할 것 같습니다. 긴 글 읽어주셔서 감사합니다~!\n"
} ,
  
  {
    "title"    : "nhn 기술교육 2주차 회고",
    "category" : "",
    "tags"     : " 회고",
    "url"      : "/2020/02/04/nhn-%EA%B8%B0%EC%88%A0%EA%B5%90%EC%9C%A1-2%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0-copy.html",
    "date"     : "February 4, 2020",
    "excerpt"  : "기술 교육 2주차에 대한 회고록이다. 1주차는 사전 과제를 주로 진행했다면 2주차부터는 본격적으로 서비스 개발의 프로세스를 직접 밟아가기 시작했다.\n\n기획은 처음이라..\n\n2주차의 메인 과제는 서비스에 대한 기획을 하는 것이었다. 서비스에 대한 주요 스펙이 주초에 공개됐고, 그 서비스에 대해서 기획을 했는데, 이때 운영진분들이 강조하신 것은 바로 ‘이번주는 우리 모두가 개발자가 아닌 기획자’라는 점이다. 이런 점을 강조하신 이유도 설명해주...",
  "content"  : "기술 교육 2주차에 대한 회고록이다. 1주차는 사전 과제를 주로 진행했다면 2주차부터는 본격적으로 서비스 개발의 프로세스를 직접 밟아가기 시작했다.\n\n기획은 처음이라..\n\n2주차의 메인 과제는 서비스에 대한 기획을 하는 것이었다. 서비스에 대한 주요 스펙이 주초에 공개됐고, 그 서비스에 대해서 기획을 했는데, 이때 운영진분들이 강조하신 것은 바로 ‘이번주는 우리 모두가 개발자가 아닌 기획자’라는 점이다. 이런 점을 강조하신 이유도 설명해주셨다. 기획 단계에서 개발자의 시선이 들어가버리면 사용자에게 유익한 서비스가 아닌, 개발하기 편한 서비스가 만들어질 가능성이 높아지기 때문이다. 그로 인해 더 좋은 서비스가 나올 수 있는 가능성이 기획 단계부터 차단될 수 있다.\n\n위의 사실을 명심하면서 기획을 시작했지만, 우린 개발자들이다보니 개발자의 시선을 완전히 배재하는 것이 말처럼 쉽진 않았다. 구현, 일정에 대한 생각이 조금씩은 개입될 수밖에 없었다. 하지만 아주 초보적이고 투박한 기획이지만 멘토님의 피드백을 많이 받으면서 나름대로 완성할 수 있었고 그 과정에서 느낀 점은 다음과 같다.\n\n\n  \n    기획에서 서비스의 플로우, 예외 상황에 대해서 아주 구체적으로 생각하는 시간을 가지다보니 실제 구현 단계에서는 빠르게 구현에만 집중할 수 있다.\n  \n  \n    기획자분들의 노고에 박수를….기획이 생각보다 서비스 전반의 모든 플로우를 매우 깊은 레벨까지 고려하게 되는데 이 작업이 생각보다 쉽지 않다는 것을 느꼈다.\n  \n\n\n결국 기획자분들의 기획 덕분에 개발자가 개발에 더 집중할 수 있게 되는 측면도 있다고 생각하기 때문에 실제로 부서에 배치받게 되면 기획자분들과도 상호 존중을 통해서 더 좋은 시너지를 내야겠다고 다짐한 한 주였다.\n\n동기들과의 친밀감\n\n기획을 하는 한주동안 TF 팀원들과 회의를 아주 많이 했다. 회의를 하니까 자연스럽게 대화를 많이 하게 됐고 중간중간 사적인 대화들도 하다보니 더 많이 친해진 것 같다. 그리고 각자의 좋은 성향이나 특징이 서로의 부족한 부분을 채워줘서 더 완전한 팀을 이루는 느낌을 많이 받았다. 그 점이 너무 좋았다. 앞으로 함께 할 시간이 훨씬 길기 때문에 더 친해지고 더 완전해질 미래가 기대된다!\n\n그리고 다른 TF의 동기들과도 조금씩 대화도 많이 하고 친해지는 중이다. 특히 퇴근 후 판교역까지 걸어가는 파티원들이 있는데 그 인원이 점점 많아지고 있다ㅋㅋㅋㅋ 인원이 많다보니 모든 사람들과 친해지는 것이 쉽진 않겠지만 기술교육이 끝날 때가 되면 더 많은 동기들과 서로 의지할 수 있는 사이가 됐으면 좋겠다.\n\nps. TF 팀원의 영업으로 노트북 받침대를 하나 샀는데 가격도 착하고 접으면 크기도 아주 작아지는 것이 대만족이다. 고맙다 또 좋은 거 있으면 추천해다오..(tmi)\n\n2주차 회고 끝!\n\n"
} ,
  
  {
    "title"    : "nhn 기술교육 1주차 회고",
    "category" : "",
    "tags"     : " 회고",
    "url"      : "/2020/01/21/nhn-%EA%B8%B0%EC%88%A0%EA%B5%90%EC%9C%A1-1%EC%A3%BC%EC%B0%A8-%ED%9A%8C%EA%B3%A0-copy.html",
    "date"     : "January 21, 2020",
    "excerpt"  : "기술 교육 1주차 일정이 모두 끝났다. 방금 사전과제에 대한 시험을 마치고 이 글을 바로 작성한다. 기억은 시간이 지나면 지날수록 희석되기 때문에 최대한 선명할 때 지난 일주일 간의 기억을 바로 기록하겠다.\n\n처음 써보는 맥북\n\n\n\n나는 평생을 윈도우 os 노트북만 사용해왔던 사람이다. 하지만 현업의 개발자분들은 대부분 맥북으로 개발을 하시고 그것을 보면서 나도 취업하고 빨리 맥북을 써보고 싶다는 나름의 동경?을 하면서 살아왔는데 그 동경...",
  "content"  : "기술 교육 1주차 일정이 모두 끝났다. 방금 사전과제에 대한 시험을 마치고 이 글을 바로 작성한다. 기억은 시간이 지나면 지날수록 희석되기 때문에 최대한 선명할 때 지난 일주일 간의 기억을 바로 기록하겠다.\n\n처음 써보는 맥북\n\n\n\n나는 평생을 윈도우 os 노트북만 사용해왔던 사람이다. 하지만 현업의 개발자분들은 대부분 맥북으로 개발을 하시고 그것을 보면서 나도 취업하고 빨리 맥북을 써보고 싶다는 나름의 동경?을 하면서 살아왔는데 그 동경의 순간을 월요일에 만끽할 수 있었다. 맥북의 실물을 영접한 순간 너무 예뻐서 소리를 지르고 싶었지만 사무실이라 그러진 못 했다.. ㅎㅎ 나의 더러운 손으로 만지기가 아까울 지경이었으니..\n\n하지만 저런 기쁨도 잠시.. 부팅을 하고 본격적으로 이것 저것 해보는 순간부터 손에 마비가 오고 뇌정지가 왔다. 키보드도 익숙하지 않고, 익히 알던 디렉토리 구조도 다르고 모든 것이 다 달랐기 때문이다. 그래서 첫 날에는 맥북에 익숙해지는 데 시간을 다 쓴 것 같다. 특히 Intelli J의 단축키를 새롭게 익혔어야 했던 점이 가장 멘붕이었다. 그래도 이미 맥북을 쓰고 계시던 여러 동기분들께서 꿀팁들을 많이 알려주셔서 생각보다 빨리 적응할 수 있었다. 지금은 트랙패드도 내 기준에선 나름? 많이 활용하고 있고 생산성도 처음보다 많이 올라온 것 같다. 이 글을 통해 동기들에게 감사인사를 전한다.\n\n그리고 이건 여담이지만 스피커 성능이 미친 것 같다. 내가 그램을 쓰다가 와서 그런진 모르겠지만, 노트북 스피커에서 이런 소리가 나다니… 앞으론 블루투스 스피커 필요 없을듯..?\n\n사전과제\n\n\n\n1주차에는 개인 과제가 주어졌다. 책을 보면서 스프링 부트 프로젝트를 만들고 깃허브로 제출하는 과제였다. 여기에 추가적인 요구사항이 있었다. 깃허브에서 issue를 기능 스펙별로 등록하면서 프로젝트를 진행하는 것이었는데, 난 지금까지 혼자서 개발을 해왔던 터라 사실 나 혼자 커밋하고 푸시하는 것만 해봤지 그 외에 다른 기능은 거의 사용해본 적이 없었다. 그래서 처음에는 많이 당황했다. 하지만 주변에 훌륭한 동기들이 너무나도 많이 있었고 그분들에게 많이 배울 수 있었다. 그 덕분에 처음으로 브랜치를 별도로 나누어서 개발하고 마스터 브랜치로 pull request를 통해 merge하면서 issue들을 하나씩 해결해나갔다. 협업을 할 때 pull request는 필수라고 듣기만 했지 직접 해보지는 못했는데 이 기회에 비록 혼자서 북치고 장구친 격으로 한 것이지만 대략적인 흐름을 알 수 있어서 좋았다.\n\n위에서도 말했지만 사전과제를 하면서 느낀 점은 훌륭한 사람들과 함께 공부를 한다는 것은 정말 큰 행운이라는 점이다. 서로의 부족한 부분을 서로의 지식으로 공유하면서 채워주기 때문에 정말 짧은 시간동안 많은 것을 배울 수 있다. 그리고 함께 서로의 진행 상황을 공유하다보니 자극도 되고 동기부여도 돼서 좋은 것 같다. (그렇지만 추가 과제는 결국 제출 못 한 나란 녀석….분발하자) 그리고 이런 교류가 잘 일어날 수 있는 이유는 그렇게 되게끔 유도하는 환경을 기술 교육 운영진분들이 너무 잘 만들어주셨기 때문이라고 생각한다. 다음 1주일도 너무 기대가 된다..? 하하하\n\nGithub 페이지\n\n\n\n정말 지난 몇 달을 해야지.. 나도 하나 만들어야지.. 라고 생각만 하고 지금까지 실천으로 옮기지 못 했던 Github 페이지로 블로그 만들기를 이번 주에 했다. 나는 사실 사전 과제도 사전 과제지만 이 과제를 내주신 운영진분들께 너무 감사드린다. 그분들의 푸시가 이런 결과를 만들어 냈으니 말이다ㅋㅋㅋㅋ 사실 예전에도 jekyll을 이용해서 페이지를 만들기까진 했었는데 그 뒤로 게시물을 추가하거나 커스터마이징은 하지 못 하고 끝났었다. jekyll의 기본적인 사용법, 구조를 전혀 이해하지 않은 상태였기 때문이다. 그런데 이번엔 그게 과제로 주어졌으니 확실히 마음가짐이 달라졌던 것 같다. 동기가 보내준 jekyll 공식 문서를 읽으면서 기본적인 사용법, 구조를 이해할 수 있었다. 생각보다 어렵지 않았고 ‘진작 좀 할걸..’이라는 생각도 들었다. 아무튼 지금이라도 만들었으니 앞으로는 꾸준히 글을 써볼 생각이다..!!\n\n루키하마\n\n\n\n내가 속한 TF는 ‘루키하마’다. 세상 이렇게 귀여운 이름을 가진 TF는 이 세상에 없을 것이다. 입문교육이 끝나고 새롭게 조가 편성되는데 TF조원들이 입문교육 때 조원들과 하나도 겹치지 않았다. 모두 처음 대하는 분들이다 보니 첫 날에는 어색한 기류가 흘렀다.. ㅋㅋㅋㅋ 그래서 다음날에 빨리 친해질수록 좋을 것 같아서 조심스럽게 말을 편하게 하자고 제안을 했는데 다행히도 모두 이구동성으로 ‘나도 그러고 싶었다’고 해줬다. 확실히 말의 힘은 너무 강해서 작은 차이임에도 분위기에 큰 변화를 가져온다. 아직 훨씬 더 많이 친해져야 하지만 그래도 조금은 가까워진 것 같다. 우리 얼른 더 많이 친해지자!! 다른 조원 분들과도 얼른 친해지고 싶어요!!\n\n기술교육 과정 중 매주 돌아가면서 조장을 맡아야 하는데 이번주에는 내가 조장을 맡았다. 조장이라서 처음엔 마음에 아~주 경미한 부담이 있었던 건 사실이다. 그런데 팀원들이 알아서 너무 다 잘해서 내가 특별히 할 게 없었다.(나만 잘 하면 됐다) 할 게 없는데도 뭐 하나 하는 데 시간이 많이 걸렸다. 사내 시스템인 두레이에 익숙하지 않고, 맥북에도 익숙하지 않다보니 프로젝트에 슝슝 올라오는 할일들을 체크하고 처리하는 것만으로도 시간이 너무 금방 갔다. 거기다 사전과제까지 동시에 진행하려다보니 더 정신이 없었다. 얼른 익숙해져야겠다. 이번주에 한 일은 몇 가지 필요한 정보들을 모아서 대표로 메일 보내는 거랑 재택근무하는 날 아침에 운영진분들과 팀의 상황을 보고드리는 것이었다. 아침에 보고드리는 것은 앞으로 회사 생활하면서 매일같이 하게 될 일일 것이기에 빨리 익숙해져야 할 것 같고 아주 소중한 경험이었다고 생각한다.\n\n이번주 회고 끝!\n\n"
} 
  
  
  
]
