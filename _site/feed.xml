<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://anstn1993.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://anstn1993.github.io/" rel="alternate" type="text/html" /><updated>2022-02-09T11:09:36+09:00</updated><id>https://anstn1993.github.io/feed.xml</id><title type="html">MunSooKim’s devlog</title><subtitle>일상, 회고, 개발 지식을 기록하기 위한 공간 입니다.</subtitle><entry><title type="html">성공과 실패를 결정하는 1%의 네트워크 원리 5장</title><link href="https://anstn1993.github.io/2022/02/09/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-5%EC%9E%A5.html" rel="alternate" type="text/html" title="성공과 실패를 결정하는 1%의 네트워크 원리 5장" /><published>2022-02-09T00:00:00+09:00</published><updated>2022-02-09T00:00:00+09:00</updated><id>https://anstn1993.github.io/2022/02/09/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1%25%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-5%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2022/02/09/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-5%EC%9E%A5.html">&lt;p&gt;Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘5장 서버측의 LAN에는 무엇이 있는가’를 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;5장-서버측의-lan에는-무엇이-있는가&quot;&gt;5장. 서버측의 LAN에는 무엇이 있는가.&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;5장에서는 방화벽, 캐시, 콘텐츠 배포 서비스 등과 같은 서버 측의 네트워크 구조를 살펴봅니다.&lt;/p&gt;

&lt;h3 id=&quot;웹-서버의-설치-장소&quot;&gt;웹 서버의 설치 장소&lt;/h3&gt;

&lt;p&gt;웹 서버는 크게 회사 내의 LAN과 데이터센터에 설치됩니다. 각각에 대해 간단하게 살펴보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;사내에-설치하는-경우&quot;&gt;사내에 설치하는 경우&lt;/h4&gt;

&lt;p&gt;웹 서버가 사내 LAN에 설치되어 인터넷에서 직접 엑세스하는 경우입니다. 결론부터 말하면 현재 이 방법은 여러 문제들 때문에 주류가 아닙니다. 문제 중 하나는 IP 부족입니다. 사내 LAN에 서버를 설치하면 글로벌 주소를 할당해야 하지만 그럴 여유가 없습니다. 또 하나의 문제는 보안적으로 취약하다는 것입니다. 인터넷에서 바로 접근이 가능하기 때문에 서버 자체적으로 방어를 강화하는 것 말고는 어떠한 보안적 대비를 할 수 없습니다.&lt;/p&gt;

&lt;p&gt;그래서 최근에는 웹 서버 앞에 &lt;strong&gt;방화벽&lt;/strong&gt;을 두는 것이 일반적입니다. 방화벽은 특정 서버에서 동작하는 특정 애플리케이션에 접근하는 패킷만 통과시키고 그 외의 패킷은 모두 차단하는 관문 역할을 합니다. 이렇게 되면 최소한으로면 애플리케이션의 접근 범위를 설정해서 보안 구멍이 생길 위험성을 줄일 수 있습니다. 물론 접근을 허용한 애플리케이션에 보안 구멍이 있으면 공격받을 위험성은 여전히 존재합니다. 그렇지만 방화벽이 없는 것보단 낫습니다.&lt;/p&gt;

&lt;h4 id=&quot;데이터센터에-웹-서버를-설치하는-경우&quot;&gt;데이터센터에 웹 서버를 설치하는 경우&lt;/h4&gt;

&lt;p&gt;프로바이더 등의 데이터센터에 웹 서버를 설치하는 경우입니다. 데이터센터는 인터넷 중심부의 고속 회선으로 접속되어있기 때문에 여기에 서버를 설치하면 고속으로 액세스가 가능합니다. 트래픽이 많은 서비스를 운영할 때 효과적입니다. 또한 데이터센터는 그 역할 상 내진 설계, 자가 발전 장치 비치, 24시간 입/퇴실 등은 물론이고 기기의 가동 상태 감시, 방화벽 설치 운영, 부정 침입 감시 등의 부가 서비스도 제공하기 때문에 안전성도 높습니다.&lt;/p&gt;

&lt;h3 id=&quot;방화벽의-원리와-동작&quot;&gt;방화벽의 원리와 동작&lt;/h3&gt;

&lt;p&gt;방화벽의 기본 원리는 허용된 서버와 그 서버 내의 허용된 애플리케이션에 액세스하는 패킷만 통과시키고 나머지는 전부 차단하는 것입니다. 원리는 간단하지만 그것을 네트워크에는 다양한 종류의 패킷이 흐르기 때문에 구현하는 것은 그리 간단하지 않습니다. 그래서 그동안 패킷 필터링형, 애플리케이션 게이트웨이형, 서킷 게이트웨이형과 같은 다양한 방법이 고안되었지만 성능, 가격, 사용 편의성 등의 이유로 &lt;strong&gt;패킷 필터링형&lt;/strong&gt;이 가장 보편화되었습니다. 그래서 이 장에서는 패킷 필터링형에 초점을 맞추겠습니다. 서버의 구성은 공개용 LAN과 사내 LAN이 분리되어있고, 웹 서버는 공개용 LAN에 접속되어있다고 가정하겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;패킷-필터링의-조건-설정&quot;&gt;패킷 필터링의 조건 설정&lt;/h4&gt;

&lt;p&gt;인터넷에서 공개용 LAN의 웹 서버로의 액세스는 허용하고, 웹 서버에서 인터넷으로의 액세스는 금지(부정 소프트웨어로 인한 감염을 막기 위함)하기 위한 패킷 필터링의 조건 설정을 어떻게 해야할지 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;서버의 접근 액세스 허용 우무는 IP헤더의 송신처 IP와 수신처 IP로 판단&lt;/strong&gt;합니다. 송신처 IP는 시점이 되고 수신처 IP는 종점이 됩니다. 인터넷에서 웹 서버를 향해 흐르는 패킷이면 패킷의 시점을 지정할 수는 없지만, 흐름의 종점은 웹 서버가 되기 때문에 수신처 IP가 종점과 일치하는 패킷은 통과시킨다는 조건을 설정하면 됩니다. 만약 송신처 IP 주소에 따라 시점을 지정할 수있으면 이것도 조건에 추가하면 됩니다. 그런데 TCP 통신은 항상 패킷을 잘 받았다는 수신 확인 응답 구조를 가지기 때문에 패킷이 웹서버로 들어왔으면 웹서버에서 인터넷으로 흐르는 패킷도 생기게 됩니다. 이때는 반대로 웹 서버의 IP 주소를 송신처 IP로 설정해두면 됩니다.&lt;/p&gt;

&lt;p&gt;IP 주소로만 필터링을 하면 웹 서버의 애플리케이션 액세스를 필터링할 수는 없습니다. &lt;strong&gt;애플리케이션의 액세스 허용 유무는 TCP 헤더의 송신처 포트번호와 수신처 포트번호로 판단&lt;/strong&gt;합니다. 수신처 IP 주소 및 송신처 IP 주소에 수신처 포트가 80번으로 설정되어있으면 수신처 주소가 웹 서버의 주소와 일치하면서 포트 번호가 80번인 패킷은 통과하게 됩니다. 또한 송신처 IP 주소가 웹 서버의 주소와 일치하고 송신처 포트 번호가 80번인 패킷도 통과하도록 설정하면 됩니다.&lt;/p&gt;

&lt;p&gt;그런데 아직 이것으로도 좀 부족합니다. IP 주소와 포트 번호만으로는 접속 방향을 판단할 수는 없기 때문입니다. 우리의 목표는 &lt;strong&gt;웹 서버에서 인터넷측으로 패킷이 흐르는 것을 막는 것인데, 이 판단에 사용하는 데이터가 바로 TCP 헤더의 컨트롤 비트&lt;/strong&gt;입니다. TCP는 최초에 접속 단계에서 3개의 패킷이 흐릅니다. 이때 가장 첫번째 패킷은 SYN비트는 1, ACK비트는 0입니다. 그런데 송신처 주소와 포트번호가 웹 서버의 것으로 설정된 상태에서 SYN비트가 1이고 ACK 비트는 0인 경우만 차단을 해주면 접속 동작이 필히 실패하게 될 것이고 이를 통해 웹 서버에서 인터넷으로 액세스하는 동작을 정지시킬 수 있습니다.
그런데 UDP의 경우 TCP와 달리 접속 단계가 없기 때문에 TCP처럼 컨트롤 비트에 의한 액세스 방향을 판별할 수 없습니다. 대표적으로 DNS 서버의 경우 사내에서 DNS 서버에 액세스하는 것은 허가하면서 인터넷에서 사내의 DNS 서버에 액세스하는 패킷은 차단한다는 조건 설정을 할 수 없습니다. 이런 경우에는 어느 정도 위험을 각오하고 모든 애플리케이션에 대한 패킷을 모두 통과시키거나 전면적으로 차단하는 방법을 택해야 합니다.(패킷 필터링 이외의 방법을 사용하면 UDP의 접속 방향을 판단할 수 있는 경우도 있습니다.)&lt;/p&gt;

&lt;p&gt;지금까지 인터넷과 공개용 서버 LAN을 오가는 패킷에 대한 조건 설정을 살펴봤습니다. 그런데 이때 사내 LAN과 인터넷, 사내 LAN과 공개 서버용 LAN 사이를 오가는 패킷 조건도 설정해야 합니다. 이때 조건의 누락이 없는지 잘 살펴야 합니다. 사내 LAN과 공개 서버용 LAN 사이의 패킷은 자유롭게 오갈 수 있게 하려고 수신처 IP 주소가 공개 서버용 LAN과 일치하는 패킷을 전부 통과시키게 설정했다고 가정하겠습니다. 근데 이때 깜박하고 송신처 IP 주소를 조건으로 주지 않으면 이 조건 행으로 인해서 인터넷에서 흘러온 패킷도 무조건 공개 서버용 LAN으로 유입이 가능해지는 취약점이 발생하게 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;방화벽의-주소-변환-기능&quot;&gt;방화벽의 주소 변환 기능&lt;/h4&gt;

&lt;p&gt;패킷 필터링 방화벽은 주소 변환의 기능도 가지고 있습니다. 사내 LAN과 인터넷을 왕래하는 패킷은 주소 변환 설정이 필요합니다. 이 주소 변환 설정을 이용하면 당연히 인터넷에서 사내 LAN으로는 액세스할 수 없게 됩니다. 그래서 사내 LAN에 대한 액세스 금지 패킷 필터링 조건은 설정할 필요가 없습니다.&lt;/p&gt;

&lt;h4 id=&quot;방화벽도-사실은-라우터다&quot;&gt;방화벽도 사실은 라우터다&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;방화벽은 패킷 필터링이라는 부가적인 기능을 수행하는 라우터&lt;/strong&gt;라고 생각해야 합니다. 단지 필터링의 조건이 복잡하고, 버린 패킷을 기록으로 남기는 등의 작업이 라우터에게 부담스러운 작업이라서 전용 하드웨어나 소프트웨어를 사용하는 것 뿐입니다. 만약 조건이 매우 간단하고, 버린 패킷에 대한 기록도 필요없다면 패킷 필터링 기능을 가진 라우터를 방화벽으로 사용해도 무방합니다.&lt;/p&gt;

&lt;h3 id=&quot;서버의-부하-분산&quot;&gt;서버의 부하 분산&lt;/h3&gt;

&lt;p&gt;서버에 액세스가 증가할 때는 서버로 통하는 회선을 빠르게 하면 효과적이지만, 아무리 회선의 성능이 좋아도 서버의 처리 능력이 그에 상응하지 못하면 부하는 점점 증가하게 됩니다. 이때 서버의 하드웨어를 고성능으로 교체하는 scale up 방식으로 부하를 줄일 수 있겠지만 서버 한대로 모든 요청을 견뎌내는 것은 한계가 있습니다. 그래서 결국은 서버 한대당 요청 처리량을 줄이는 scale out 방식으로 문제를 해결해야 합니다. 이를 분산 처리라고 합니다. 분산 처리를 하는 방법은 크게 DNS 서버를 통해 요청을 분산하는 방법과 로드 밸런서 같은 부하분산장치를 통해 요청을 분산하는 방법이 있습니다. 각각의 방법을 살펴보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;dns-서버를-통한-부하-분산&quot;&gt;DNS 서버를 통한 부하 분산&lt;/h4&gt;

&lt;p&gt;DNS 서버에 같은 도메인에 대해 여러 웹 서버 IP 주소를 등록해두면 DNS 서버는 해당 도메인 조회가 있을 때마다 라운드 로빈 방식으로 IP 주소를 돌려주게 됩니다. 가령 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.cyber.co.kr&lt;/code&gt;이라는 도메인에 대해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.0.2.60&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.0.2.70&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.0.2.80&lt;/code&gt;이라는 3개의 주소를 등록하면 해당 도메인을 요청할 때 3개의 주소를 순환하면서 반환해줍니다. 이렇게 하면 균등하게 부하를 분산할 수 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 이 방식에는 결점들이 존재합니다. 먼저 서버 한 대에 문제가 생기더라도 그 서버에 요청이 가게 된다는 것입니다. 그 외에도 복수의 페이지에 걸쳐서 서버와 클라이언트 간의 상호작용이 일어나야 하는 경우에도 요청마다 요청이 가는 웹 서버가 달라지게 됩니다. 예를 들면 쇼핑 사이트에서 여러 페이지에 걸쳐서 주문 정보를 받는 경우가 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;부하-분산-장치를-통한-부하-분산&quot;&gt;부하 분산 장치를 통한 부하 분산&lt;/h4&gt;

&lt;p&gt;DNS 서버를 통한 방식의 문제를 피하기 위해 로드 밸런서 같은 부하 분산 장치 같은 기기가 고안됐습니다. 부하 분산 장치는 실제 웹 서버 앞에서 프록시 형태로 위치하여 요청을 받아서 적절하게 분배해줍니다. 그래서 DNS 서버에 등록할 때는 이 부하 분산 장치의 IP 주소를 등록해줍니다. 그러면 클라이언트에서 보낸 요청은 부하 분산 장치가 받고 웹 서버로 전달해주게 됩니다.
이때 어떤 웹 서버에 요청을 전달할지에 대한 판단 근거는 여러 가지가 있습니다. 만약 복수 페이지에 걸친 상호작용이 필요한 경우가 아니면 웹 서버의 부하 상태가 판단 근거가 될 것입니다. 부하 상태를 판단하기 위해 주기적으로 CPU나 메모리 사용률 등을 수집하거나, 시험 패킷을 주기적으로 보내서 응답 시간으로 판단할 수도 있습니다.
만약 복수 페이지에 걸친 상호작용이 필요하다면 웹 서버의 부하와 무관하게 이전 리퀘스트와 같은 웹 서버에 요청을 전달해야 합니다. 그런데 HTTP는 기본적으로 요청에 대한 응답이 일어나면 연결을 끊도록 고안되었기 때문에 이전 리퀘스트와의 관계를 파악하기가 힘듭니다. 요청의 송신처 IP 주소가 같으면 일련의 요청이라고 판단할 수도 없습니다. 앞서 말했듯이 부하 분산 장치는 프록시 서버이고 프록시는 요청을 전달할 때 송신처 IP 주소를 자신의 IP로 바꿔버리기 때문입니다. 또한 주소 변환을 하는 경우에도 송신처 IP의 주소는 공인 IP 주소가 되기 때문에 정확한 클라이언트를 판별할 수 없습니다.
이런 상황에서 나온 방법은 form에 입력한 데이터를 보낼 때 전후의 관련성을 나타내는 정보를 추가해서 보내거나 쿠키를 이용하는 것입니다. 부하 분산 장치는 이런 정보가 존재하면 이전과 같은 웹 서버에, 그렇지 않으면 부하가 적은 웹 서버에 요청을 전달합니다.&lt;/p&gt;

&lt;h3 id=&quot;캐시-서버를-이용한-부하-분산&quot;&gt;캐시 서버를 이용한 부하 분산&lt;/h3&gt;

&lt;p&gt;캐시서버를 이용하여 부하 분산을 할 수도 있습니다. 캐시서버는 클라이언트와 서버 사이에 프록시 형태로 자리하여 웹 서버 액세스 동작을 중개합니다. 캐시서버는 웹 서버로부터 받은 응답 데이터를 디스크에 저장해두고 클라이언트가 같은 데이터를 요청하면 웹 서버 대신 저장해둔 데이터를 반환하는 역할을 수행합니다. 이렇게 하면 웹 서버는 매 요청마다 동적 페이지를 생성하지 않아도 되기 때문에 부하가 많이 줄어듭니다. 요청마다 매번 달라지는 데이터 같은 경우에는 캐시서버에 저장할 수 없지만 그래도 저장이 가능한 것은 최대한 캐시 서버에 저장하는 것이 좋습니다.&lt;/p&gt;

&lt;h4 id=&quot;캐시-서버는-갱신일로-데이터를-관리한다&quot;&gt;캐시 서버는 갱신일로 데이터를 관리한다&lt;/h4&gt;

&lt;p&gt;캐시 서버의 동작을 좀 더 자세히 살펴보겠습니다. 캐시 서버는 부하분산 장치와 마찬가지로 캐시 버서를 웹 서버 대신 DNS 서버에 등록하게 됩니다. 그래서 클라이언트에서 요청을 보내면 캐시 서버가 1차적으로 받게 됩니다. 캐시 서버는 요청 데이터가 자신의 캐시에 저장되어 있는지 조사합니다.
먼저 데이터가 저장되지 않은 경우부터 살펴보겠습니다. 캐시 서버는 웹서버로 데이터 요청을 보냅니다. 이때 요청이 캐시 서버를 경유해서 왔다는 것을 알리기 위해 헤더에 ‘Via’라는 필드에 캐시 서버의 도메인 주소를 채워서 웹 서버로 보내게 됩니다. 이때 웹 서버가 한 대라면 웹 서버의 도메인이나 IP 주소를 캐시 서버에 설정해두고 무조건 거기로 전송하면 되지만, 웹 서버가 여러대인 경우에는 다른 방법이 필요합니다. 대표적인 방법은 요청 헤더의 URI별로 웹 서버를 할당하는 것입니다. 예를 들어 요청 URI가 ‘/dir1/’로 시작하면 ‘www1.lab.cyber.co.kr’로, 요청 URI가 ‘/dir2/’로 시작하면 ‘www2.lay.cyber.co.kr’로 요청을 전달하는 방식입니다. 요청을 받은 웹 서버는 캐시 서버로 응답을 해주게 됩니다. 그러면 캐시 서버는 데이터를 저장한 후 클라이언트에게 응답을 해주게 됩니다. 이 응답 헤더에도 ‘Via’ 필드에 캐시 서버의 도메인을 추가하게 됩니다. 참고로 ‘Via’ 헤더는 필수가 아닙니다. 캐시 서버의 설정에 따라 이 헤더를 추가하지 않기도 합니다.
이번에는 캐시 서버에 요청 데이터가 저장되어 있는 경우를 살펴보겠습니다. 데이터가 존재하더라도 웹 서버측에 데이터가 변경되었는지 확인을 해야 합니다. 이 확인용 요청을 보낼 때 ‘If-Modified-Since’ 헤더를 추가하여 웹 서버에 전송하게 됩니다. 웹 서버는 저 헤더 필드의 값과 데이터의 최종 갱신 일시를 비교하여 변경이 없으면 ‘304 Not Modified’ 응답을 돌려주게 됩니다. 캐시 서버에 데이터가 있어도 웹 서버가 이렇게 데이터 변경 확인 요청을 받긴 하지만 실제 데이터 요청보다는 훨씬 부담이 적습니다. 이제 캐시 서버는 자신이 저장한 데이터가 최신 데이터라는 것을 확인했으니 그 데이터를 클라이언트에게 응답해주게 됩니다. 이때 응답은 데이터가 없었을 때의 응답 메시지와 동일합니다. 만약 웹 서버측의 데이터가 변경되었다면 그때부터는 캐시서버에 데이터가 저장되지 않았을 때의 플로우와 완전히 동일합니다. 웹 서버가 데이터를 반환하게 되기 때문에 캐시서버는 응답 헤더에 ‘Via’ 필드를 추가해서 클라이언트에게 응답합니다.&lt;/p&gt;

&lt;h4 id=&quot;프록시의-유형&quot;&gt;프록시의 유형&lt;/h4&gt;

&lt;p&gt;캐시 서버가 프록시 방식으로 동작하는 것을 확인했습니다. 사실 이 프록시는 프록시 서버가 어디에 위치하는지에 따라 포워드 프록시, 리버스 프록시, 트랜스패어런트 프록시로 분류할 수 있습니다. 하나씩 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;포워드 프록시는 클라이언트측에 캐시 서버를 두는 방식입니다. 포워드 프록시는 초기의 캐시 서버 형태였습니다. 서버측에 설치하는 캐시서버와 같지만 이 당시의 포워드 프록시는 방화벽을 수행하는 목적으로도 사용되었습니다. 앞서 클라이언트쪽에 프록시 형태로 방화벽을 둠으로써 인터넷에서 사내 망으로의 부정 침입은 막으면서도 사내 망에서 인터넷으로의 액세스는 가능했던 것을 살펴봤습니다. 포워드 프록시는 요청의 데이터를 조사하기 때문에 위험한 사이트에 대한 액세스는 금지할 수 있습니다. 여기에 캐시 기능까지 추가하여 속도까지 잡았습니다.
포워드 프록시는 클라이언트에 존재하기 때문에 보통 브라우저에서 프록시 서버 항목을 설정합니다. 프록시 서버 url을 설정하게 되면 브라우저의 url 입력 상자에 어떤 url을 입력하든 무조건 요청은 포워드 프록시 서버로 하게 됩니다. 그리고 url의 입력 상자에 입력했던 url은 요청 헤더의 ‘URI’로 기록하여 포워드 프록시에게 요청 대상 웹서버를 통지합니다. 이처럼 클라이언트 프록시는 요청 대상 웹서버의 url을 URI로 설정하기 때문에 웹 서버가 여러 대인 경우 서버 쪽에 캐시 서버를 두는 경우와 다르게 대상 웹서버를 찾을 필요가 없습니다. 대상 서버를 찾는 일은 부하 분산 장치가 해야 할 일이기 때문이죠.&lt;/p&gt;

&lt;p&gt;리버스 프록시는 앞서 살펴본 서버측에 캐시 서버를 두는 형태입니다. 리버스 프록시는 포워드 프록시와 달리 브라우저에 프록시 서버 설정을 하지 않아도 되기 때문에 잘못된 브라우저 설정으로 인한 장애를 걱정할 필요가 없습니다. 이미 살펴봤지만 포워드 프록시와 다르게 리퀘스트 메시지의 URI 부분에 쓰여있는 리소스와 웹 서버를 대응시켜서 요청을 받은 캐시 서버가 어떤 웹 서버로 요청을 전달해야 할지 결정하게 됩니다.&lt;/p&gt;

&lt;p&gt;트랜스페어런트 프록시는 IP 헤더에 있는 수신처 IP로 액세스 대상 웹 서버를 판단하는 방식입니다. 이런 방식이면 일반적인 리퀘스트 메시지를 전송할 수 있기 때문에 포워드 프록시처럼 브라우저에 프록시 서버 설정을 하지 않아도 되고 리버스 프록시처럼 URI와 웹 서버를 대응시킬 필요도 없습니다. 이를 가능하게 하기 위해서 클라이언트에서 웹 서버로 요청 메시지가 흘러가는 길에 트랜스페어런트 프록시를 설치합니다. 메시지가 프록시를 통과할 때 메시지를 가로채어서 대상 웹서버로 보내는 것입니다. 만약 요청 메시지가 흐르는 길이 많으면 길이 한 개로 수렴하는 형태로 네트워크를 구성하고 수렴되는 곳에 트랜스페어런트 프록시를 설치하는 것이 일반적입니다. 보통 인터넷에 연결하는 액세스 회선 부분이 이런 형태로 구성되어 있어서 액세스 회선 부분에 설치하기도 합니다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><category term="CS" /><summary type="html">Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘5장 서버측의 LAN에는 무엇이 있는가’를 정리했습니다.</summary></entry><entry><title type="html">성공과 실패를 결정하는 1%의 네트워크 원리 3장</title><link href="https://anstn1993.github.io/2022/02/02/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-3%EC%9E%A5.html" rel="alternate" type="text/html" title="성공과 실패를 결정하는 1%의 네트워크 원리 3장" /><published>2022-02-02T00:00:00+09:00</published><updated>2022-02-02T00:00:00+09:00</updated><id>https://anstn1993.github.io/2022/02/02/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1%25%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-3%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2022/02/02/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-3%EC%9E%A5.html">&lt;p&gt;Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘3장 케이블의 앞은 LAN기기였다’를 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;3장-케이블의-앞은-lan기기였다&quot;&gt;3장. 케이블의 앞은 LAN기기였다.&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;3장에서는 케이블로 송출된 패킷이 리피터 허브, 스위치 허브, 라우터등의 네트워크 장비를 지나서 인터넷을 향해 진행하는 과정을 살펴봅니다.&lt;/p&gt;

&lt;h3 id=&quot;리피터-허브의-패킷-중계-동작&quot;&gt;리피터 허브의 패킷 중계 동작&lt;/h3&gt;

&lt;p&gt;LAN 어댑터에서 생성한 패킷의 신호는 RJ-45 커넥터를 통해 트위스트 페어 케이블(꼰 선쌍)을 타고 리피터 허브의 RJ-45 커넥터에 도달하게 됩니다. 그럼 리피터 허브는 LAN 전체에 신호를 전달하게 됩니다. 이는 같은 대역 내의 모든 기기에 패킷의 신호를 뿌리고 수신처 MAC 주소에 해당하는 기기만 패킷을 수신한다는 이더넷의 기본 원리를 그대로 실현한 것입니다.&lt;/p&gt;

&lt;p&gt;리피터 허브의 내부 구성은 LAN 어댑터와 크게 다르지 않습니다. 각 케이블에 연결된 커넥터별로 PHY들이 존재하고 이 PHY들은 리피터 회로에 전부 연결되어 있습니다. 즉 한쪽으로 신호가 들어오면 PHY로 신호가 전달되고 이 신호를 리피터 회로로 보내서 나머지 PHY들로 전달되고 커넥터에서 나가게 되어 리피터 허브에 접속한 모든 기기에 도달합니다. 이때 리피터 회로는 신호가 잡음의 영향을 받아 변형된 것 같은 신호라도 그대로 흘려보냅니다. 신호의 변형 여부는 수신한 기기에서 디지털 신호로 변환된 패킷의 FCS를 검사하면서 파악하기 때문입니다.&lt;/p&gt;

&lt;p&gt;신호를 받은 기기는 패킷의 MAC 헤더의 수신처 MAC 주소를 보고 자신에게 온 것이 아니면 파기하고 자신에게 온 것이면 수신합니다.&lt;/p&gt;

&lt;h3 id=&quot;스위칭-허브의-패킷-중계-동작&quot;&gt;스위칭 허브의 패킷 중계 동작&lt;/h3&gt;

&lt;p&gt;스위칭 허브는 리피터 허브처럼 연결된 모든 기기에 신호를 전달하기 않고 수신처 MAC 주소에 해당하는 기기에만 중계하도록 만들어져 있습니다. 그것이 가능하게 하기 위해서 스위칭 허브는 내부에 &lt;strong&gt;주소 테이블&lt;/strong&gt;을 관리합니다.&lt;/p&gt;

&lt;p&gt;스위칭 허브의 내부 또한 LAN 어댑터와 동일합니다. RJ-45커넥터로 신호를 받아서 PHY에서 공통의 신호 형식으로 변환해서 MAC 회로로 전달합니다. 여기서 디지털 데이터로 변환해서 패킷의 맨 끝에 있는 FCS를 대조해서 오류의 유무를 검사하고 이상이 없으면 메모리에 저장합니다. 이때 RJ-45 커넥터 안쪽의 회로 부분(PHY-MAC-메모리로 이어지는 회로)을 &lt;strong&gt;포트&lt;/strong&gt;라고 부릅니다. 그래서 &lt;strong&gt;스위칭 허브의 포트는 PC의 LAN 어댑터와 거의 같습니다.&lt;/strong&gt; 그런데 둘 사이에 한가지 차이가 있습니다. 스위칭 허브의 포트에는 MAC 주소가 할당되어 있지 않습니다. 스위칭 허브의 포트는 수신처 MAC 주소를 검사하지 않고 모든 패킷을 버퍼 메모리에 저장하기 때문입니다. 스위칭 허브는 이 검사 동작을 MAC 주소 테이블로 수행합니다. 버퍼 메모리에 저장된 패킷의 MAC 헤더에서 수신처 MAC 주소를 파악하고 MAC 주소 테이블에 등록이 되어있는지 확인합니다. 이 테이블에는 &lt;strong&gt;기기의 MAC 주소&lt;/strong&gt;와 그 &lt;strong&gt;기기가 어느 포트에 연결되어있는지&lt;/strong&gt;에 대한 정보가 등록되어 있습니다. 이를 통해 수신한 패킷을 어느 포트로 송신할지 판단합니다. 수신처 MAC 주소에 해당하는 포트를 찾았으면 스위치 회로를 경유하여 패킷을 송신측 포트로 보내게 됩니다. 포트가 패킷을 신호로 만들어서 케이블로 전달하는 과정은 LAN 어댑터의 송신 동작과 완전히 동일합니다.&lt;/p&gt;

&lt;p&gt;이때 스위칭 허브에 리피터 허브가 접속되어 반이중 모드로 동작할 때를 가정해서 먼저 살펴보겠습니다. 이더넷의 규칙에 따라 송/수신 회로 중 수신 회로에 신호가 들어오지 않는지 확인합니다. 만약 누군가가 송신 중이라면 기다리고 송신 동작이 끝나거나 송신 동작이 일어나고 있지 않으면 송신을 합니다. 만약 송신 중에 다른 기기가 보낸 신호가 수신 회로로 들어오면 패킷 충돌이 발생하기 때문에 재밍 신호를 보내고 송신 동작을 일정 시간이 지난 후에 다시 시작합니다. 하지만 최근에는 PC나 라우터 같은 기기를 리피터 허브 없이 스위칭 허브에 직접 접속하는 것이 일반적이기 때문에 전이중 모드로 동작합니다. 이에 대해서는 뒤에서 살펴봅니다.&lt;/p&gt;

&lt;h4 id=&quot;mac-주소-테이블의-갱신-동작&quot;&gt;MAC 주소 테이블의 갱신 동작&lt;/h4&gt;

&lt;p&gt;스위칭 허브는 패킷 중계시 MAC 주소 테이블의 내용을 통해 중계 대상을 정한다는 것을 살펴봤습니다. 그런데 사실 내용을 갱신하는 동작도 함께 수행합니다. 패킷을 수신했을 때 송신처 MAC 주소를 조사해서 이것을 수신한 입력 포트의 번호와 세트로 테이블에 등록합니다. 왜냐하면 언젠간 송신처 MAC 주소가 수신처 MAC 주소가 될 것이기 때문입니다.&lt;/p&gt;

&lt;p&gt;또한 반대로 테이블의 내용을 지우는 동작도 있습니다. 이는 스위칭 허브에 연결된 기기를 이동한 경우의 불편함을 방지하기 위함입니다. 예를 들면, 책상에 사용하고 있던 노트북 PC를 회의실로 가져가서 사용할 수 있는데, 그럼 스위칭 허브의 입장에서는 자신에게 접속 중이던 노트북이 사라진 것이기 때문에, 이 상태로 그 노트북으로 가야 할 패킷을 수신했을 때 연결이 끊긴 포트로 패킷을 보내게 됩니다. 즉 통신이 제대로 일어날 수 없는 상황을 막기 위해서 오래된 정보는 일정 시간이 경과하면 삭제합니다. 새롭게 이동한 회의실의 스위칭 허브의 입장에서도 아무 문제가 없습니다. 노트북이 신호를 전달하면 해당 노트북의 MAC 주소와 포트를 테이블에 등록할 것이기 때문입니다.&lt;/p&gt;

&lt;h4 id=&quot;예외적인-동작&quot;&gt;예외적인 동작&lt;/h4&gt;

&lt;p&gt;만약 스위칭 허브가 신호를 수신했을 때 MAC 주소 테이블에서 일치하는 행을 찾았는데 그 행의 송신 대상 포트가 신호를 수신한 포트와 같으면 어떻게 될까요? 이런 상황은 스위칭 허브에 리피터 허브가 접속된 경우 발생할 수 있는 예외적인 케이스 입니다. PC A와 PC B가 리피터 허브에 접속한 상태고 리피터 허브가 스위칭 허브에 접속한 상태라고 가정해보겠습니다. 이때 PC A가 패킷을 보내면 리피터 허브가 받게 되고 리피터 허브는 자신에게 연결된 모든 기기로 신호를 전달하기 때문에 PC B와 스위칭 허브에 신호가 전달됩니다. 그럼 스위칭 허브는 테이블에서 PC B의 MAC주소가 있는 행을 찾을 것이고 그 행은 자신이 수신한 포트인 것을 확인하고 패킷을 다시 리피터 허브로 반송하게 됩니다. 그럼 리피터 허브는 다시 신호를 PC B, PC A에 뿌리게 됩니다. 그럼 PC B는 동일한 패킷을 두번 받게 됩니다. 스위칭 허브는 이런 문제를 방지하기 위해서 &lt;strong&gt;패킷을 수신한 포트와 송신해야 하는 포트가 동일한 경우 패킷을 폐기&lt;/strong&gt;합니다.&lt;/p&gt;

&lt;p&gt;또 다른 예외적인 상황이 있습니다. MAC 주소표에 수신처 MAC 주소와 일치하는 주소가 등록되어 있지 않은 경우 입니다. 주소의 기기에서 패킷이 한 번도 도착한 적이 없거나 시간이 경과해서 MAC 주소표에서 삭제된 경우에 발생할 수 있습니다. 이 경우에는 리피터 허브처럼 모든 포트에 패킷을 송신해서 문제를 해결합니다. 그럼 대상 기기에서 응답이 돌아올 때 스위칭 허브의 MAC 주소 테이블에 등록이 될 것이고 그 다음부터는 대상 기기를 찾을 수 있게 됩니다. 만약 수신처의 MAC 주소를 브로드캐스트 주소로 설정해서 스위칭 허브로 전달해도 마찬가지로 해당 신호를 수신한 포트를 제외한 모든 포트로 패킷을 송신하게 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;전이중-모드&quot;&gt;전이중 모드&lt;/h4&gt;

&lt;p&gt;앞서 살펴본 스위칭 허브의 송신 동작은 반이중 모드를 가정했습니다. 하지만 오늘날은 대부분이 전이중 모드로 동작하기 때문에 전이중 모드의 동작방식도 살펴보겠습니다. 스위칭 허브는 케이블의 신호선이 송신용, 수신용으로 분리되어 있습니다. 그래서 총/수신 과정에서 충돌이 발생하지 않습니다. 즉, 스위칭 허브의 포트 부분이나 LAN 어댑터에 있는 PHY회로와 MAC 회로의 내부도 송신 회로, 수신 회로가 나누어져 있고 신호가 따로 흘러서 충돌하지 않습니다.&lt;/p&gt;

&lt;p&gt;충돌이 발생하지 않으니 반이중 모드의 충돌 방지 대책을 적용할 필요가 없고 그냥 송/수신 동작을 동시에 실행해도 상관없습니다. 그런데 기본적으로 이더넷에 신호가 흐르고 있을 때는 기다렸다가 송신 동작을 수행하기 때문에 &lt;strong&gt;이더넷의 규칙을 개정해서 신호가 흐르고 있어도 송신해도 좋다는 동작 모드를 새롭게 추가&lt;/strong&gt;했습니다. 이 동작 모드로 동작할 때는 신호의 충돌을 검출하는 회로를 무효화하기로 했는데 바로 이것이 &lt;strong&gt;전이중 동작 모드&lt;/strong&gt;입니다. 전이중 모드는 양방향 동시 송신이 가능해지기 때문에 당연히 반이중 모드보다 빠릅니다.&lt;/p&gt;

&lt;h4 id=&quot;자동-조정&quot;&gt;자동 조정&lt;/h4&gt;

&lt;p&gt;전이중 모드가 등장하면서 전이중 모드와 반이중 모드를 전환할 필요가 생겼습니다. 전이중 모드가 등장한지 얼마 안 된 시점에는 수동으로 동작 모드를 전환했지만 시간이 지나면서 자동으로 모드를 전환하는 기능이 나왔습니다. 접속한 상대가 전이중 모드를 지원하는지 검출하고 동작 모드를 자동으로 전환합니다. 그뿐만 아니라 상대의 전송 속도를 검출해서 전송 속도도 자동으로 전환하는데 이 기능을 &lt;strong&gt;자동 조정&lt;/strong&gt;이라고 합니다.&lt;/p&gt;

&lt;p&gt;접속한 상대가 어떤 모드를 지원하는지, 전송 속도는 어느 정도인지 검출하기 위해서 이더넷은 데이터 신호를 송신하지 않을 때는 &lt;strong&gt;링크 펄스&lt;/strong&gt;라는 신호를 흘립니다. 이 신호를 통해 PHY 회로나 케이블에 이상이 없는지 파악할 수 있습니다. 이더넷의 기기의 커넥터 주변에 초록 LED 표시등이 붙어있는데 이를 통해 펄스형 신호가 흐르는지를 나타냅니다. 즉 이 초록 표시등이 잘 켜져있으면 문제가 없음을 의미합니다.&lt;/p&gt;

&lt;p&gt;시간이 흐르면서 이 펄스 신호를 단순히 이상 유무 판단을 넘어, &lt;strong&gt;특정 패턴으로 송신&lt;/strong&gt;하여 자신의 상황을 상대에게 전달하는 방법이 고안됩니다. 자동 조정 기능은 바로 이 패턴화된 송신 방식을 이용합니다. 패턴을 통해 지원 가능한 모드와 전송 속도를 서로에게 통지할 수 있고, 그 중 최적의 조합을 선택해서 모드와 전송 속도를 정하게 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;라우터의-패킷-중계-동작&quot;&gt;라우터의 패킷 중계 동작&lt;/h3&gt;

&lt;p&gt;리피터 허브나 스위칭 허브를 경유한 패킷은 라우터에 도착하고 라우터에서 다음 라우터로 중계될 것입니다. 라우터의 중계 원리는 중계 대상을 등록한 라우팅 테이블로 판단한다는 점에서 스위칭 허브와 비슷합니다. 그러나 구체적인 동작에서 차이가 있는데 이는 라우터는 IP를, 스위칭 허브는 이더넷을 기반으로 동작하기 때문입니다.&lt;/p&gt;

&lt;p&gt;라우터는 크게 &lt;strong&gt;중계 부분&lt;/strong&gt;과 &lt;strong&gt;포트 부분&lt;/strong&gt;으로 구성됩니다. 중계 부분은 라우팅 테이블을 통해서 패킷의 중계 대상을 판단하는 동작을 담당하고, 포트 부분은 패킷의 송/수신 동작을 담당합니다. 포트에는 다양한 통신 기술을 지원하는 하드웨어를 장착해서 통신 기술을 지원할 수 있습니다. 예를 들면 컴퓨터는 LAN 어댑터를 교환해서 이더넷뿐만 아니라 무선 LAN도 지원할 수 있듯이, 라우터의 포트 부분에 무선 LAN 용 하드웨어를 장착한 기종이라면 무선 LAN도 지원 가능합니다. 그 외에도 ADSL, FTTH 등의 광대역 회선이라 불리는 전용선 등의 통신 회선을 지원하는 하드웨어를 장착해서 해당 통신 기술을 지원할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;이제 좀 더 구체적인 동작을 살펴보겠습니다. 포트는 다양한 통신 기술의 규칙에 따라 송/수신하는데, 가장 일반적인 이더넷 통신 기술을 적용한 포트를 예로 들어서 보면 라우터의 &lt;strong&gt;포트에는 MAC 주소가 할당되어 이더넷의 송신처나 수신처&lt;/strong&gt;가 됩니다. 포트에는 IP 주소도 할당되기 때문에 이런 측면에서도 LAN 어댑터와 같습니다. 패킷 중계시 포트는 수신처가 되어서 패킷을 수신하게 됩니다. 그리고 중계 부분이 중계 대상을 조사하면 이번에는 포트 부분이 송신처가 되어 이더넷의 패킷 송신 동작을 실행합니다. 이는 스위칭 허브와는 다른 동작 방식입니다. &lt;strong&gt;스위칭 허브는 들어온 패킷을 전달하기만 하지, 자기 자신이 송신처나 수신처가 되지는 않기 때문&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h4 id=&quot;라우팅-테이블&quot;&gt;라우팅 테이블&lt;/h4&gt;

&lt;p&gt;이미 2장에서 라우팅 테이블에 대해서 살펴봤었습니다. 여기서는 좀 더 구체적으로 라우팅 테이블의 정보로 어떻게 중계 대상을 정하는지 살펴보겠습니다. 라우팅 테이블에는 수신처 주소, 넷마스크, 게이트웨이, 인터페이스, 메트릭이라는 주요 정보가 존재합니다. 수신처 주소로는 호스트 번호는 무시하고 네트워크 번호만 일치하는지 확인합니다. 주소의 네트워크 번호와 호스트 번호를 구분하는 역할을 넷마스크가 합니다. 이때 10.10.1.0/24, 10.10.2.0/24, 10.10.3.0/24라는 3개의 서브넷이 있다고 가정해보겠습니다. 그럼 이 3개를 모두 라우팅 테이블에 등록하는 것이 원칙이지만, 3개의 서브넷을 일괄적으로 통합한 10.10.0.0/16이라는 서브넷에 있다고 간주해서 하나의 서브넷만 등록을 해도 중계 동작은 정확하게 수행할 수 있습니다. 이렇게 라우팅 테이블에 등록하는 건수를 줄일 수 있는데 이것이 &lt;strong&gt;주소 집약&lt;/strong&gt;입니다. 그런데 그 반대로 한 개의 서브넷을 세분화해서 등록하고 복수의 서브넷이 있는 것처럼 보이는 경우도 있습니다. 결국 넷마스크로 어떤 비트까지 비교의 대상으로 삼을지를 정하기만 하면 됩니다.
게이트웨이와 인터페이스는 패킷의 실제 중계 대상을 나타냅니다. 수신처와 넷마스크로 행을 찾았으면 그 행의 인터페이스(포트)에서 게이트웨이 항목에 등록된 IP 주소를 가진 라우터로 패킷을 중계합니다.
메트릭은 수신처 IP 주소에 기록된 목적지가 가까운지, 먼지를 나타냅니다. 값이 작을수록 가까이 있기에 가능하면 메트릭이 작은 행을 선택하는 것이 좋습니다.
참고로 라우터 테이블은 스위칭 허브와 달리 패킷 중계 동작에서 테이블을 갱신하는 동작을 수행하지 않습니다. 라우터는 사람이 수동으로 정보를 갱신하거나 라우팅 프로토콜(RIP, OSPF, BGP…)을 사용해서 라우터들끼리 경로 정보를 교환해서 자체적으로 갱신을 합니다.&lt;/p&gt;

&lt;h4 id=&quot;라우터의-패킷-중계-동작-1&quot;&gt;라우터의 패킷 중계 동작&lt;/h4&gt;

&lt;p&gt;라우터의 패킷 수신은 포트에서 시작되는데 포트는 이더넷 포트로 가정을 합니다. 이더넷 포트는 LAN 어댑터와 거의 같아서 패킷 수신부터 버퍼 메모리에 저장하는 부분까지 동일합니다.
수신이 끝났으면 MAC 헤더를 폐기하고 IP 헤더의 내용을 통해 패킷 중계 동작에 들어갑니다. 라우팅 테이블에서 중계 대상을 정하게 되는데 구체적인 예를 들어서 살펴보겠습니다. 10.10.1.101인 PC가 있고 이 PC가 192.168.1.10이라는 서버에 보낸 패킷이 현재 라우터에 들어왔다고 가정하겠습니다. 현재 라우터는 아래와 같은 테이블을 가지고 있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;수신처&lt;/th&gt;
      &lt;th&gt;넷마스크&lt;/th&gt;
      &lt;th&gt;게이트웨이&lt;/th&gt;
      &lt;th&gt;인터페이스&lt;/th&gt;
      &lt;th&gt;메트릭&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;10.10.1.0&lt;/td&gt;
      &lt;td&gt;255.255.255.0&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;e2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10.10.1.101&lt;/td&gt;
      &lt;td&gt;255.255.255.255&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;e2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;192.168.1.0&lt;/td&gt;
      &lt;td&gt;255.255.255.0&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;e3&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;192.168.1.10&lt;/td&gt;
      &lt;td&gt;255.255.255.255&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;e3&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0.0.0.0&lt;/td&gt;
      &lt;td&gt;0.0.0.0&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;e1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;라우팅 테이블에서 수신처 ip와 일치하는 네트워크 번호는 3행, 4행이 됩니다. 3행의 경우 넷마스크를 통해 왼쪽부터 24비트까지가 네트워크 번호이고 그럼 192.168.1이 네트워크 번호가 되기 때문입니다. 4행은 넷마스크를 통해 번호 전체가 네트워크 번호임을 알 수 있고, 수신처 IP와 완전히 동일한 것을 알 수 있습니다. 이렇게 후보가 여러개일 경우에는 &lt;strong&gt;최장 일치&lt;/strong&gt;의 원칙에 따라 결정을 하게 됩니다. 일치하는 비트가 가장 긴 행을 찾는 것입니다. 3행은 24비트까지가 네트워크 번호이고, 8비트는 호스트 번호로 할당할 수 있는 반면, 4행은 32비트 전체가 네트워크 번호이기 때문에 그 자체가 서버가 됩니다. 즉 4행이 더 일치하는 비트가 길어지기 때문에 최종적으로 4행을 선택합니다.
네트워크 번호의 길이가 같으면서 일치하는 행이 복수로 존재할 수도 있습니다. 이는 라우터의 고장이나 케이블의 단선 등을 고려해 우회로를 둔 경우인데 이 경우에는 메트릭이 가장 작은 쪽으로 선택됩니다.
그럼 테이블에서 일치하는 행이 하나도 없으면 어떻게 될까요? 패킷을 폐기하고 ICMP 프로토콜로 송신처에 이 사실을 통지합니다. 이것이 스위칭 허브와 다른 점인데, 스위칭 허브는 테이블에 일치하는 행이 없으면 브로드캐스팅을 한다고 했습니다. 이런 차이가 있는 이유는 스위칭 허브와 라우터가 가정하는 네트워크의 규모가 차원이 다르기 때문입니다. 스위칭 허브는 한 대역 안에서 정말 많아봐야 수천대에 그치는 대상을 가정하지만, 라우터는 인터넷 전체를 대상으로 삼기 때문에 여기에 패킷을 브로드캐스팅하는 것은 네트워크에 엄청난 부하를 주게 됩니다.
그런데 사실 해당 경로가 없어도 별 문제가 되지 않습니다. 위에서 살펴본 테이블의 마지막 행이 테이블에 등록된 주소 이외의 나머지 전체를 의미하기 때문입니다. 마지막 행의 넷마스크는 0.0.0.0이라서 수신처 항목을 비교할 비트 수가 0입니다. 이 말은 결국 모든 주소에 대해서 일치함을 의미합니다. 그래서 중계 대상을 찾지 못하면 이 행에 등록된 게이트웨이 주소에 해당하는 라우터로 패킷을 중계합니다. 이 행은 &lt;strong&gt;기본 경로&lt;/strong&gt;라고 하고 여기에 등록한 라우터를 &lt;strong&gt;기본 게이트웨이&lt;/strong&gt;라고 합니다.&lt;/p&gt;

&lt;h4 id=&quot;패킷의-유효기간&quot;&gt;패킷의 유효기간&lt;/h4&gt;

&lt;p&gt;라우팅 테이블에서 중계 대상을 찾고 피킷을 출력 포트로 옮겨서 송신하는데, 그 전에 라우터가 하는 일은 패킷의 수명을 1씩 줄이는 일을 합니다. IP 헤더를 보면 TTL(Time To Live)라는 필드가 존재합니다. 라우터를 경유할 때마다 이 TTL이 1씩 줄어들다가 0이 되면 이 패킷의 수명이 다했다고 간주하고 더 이상 중계하지 않고 폐기합니다. 이 TTL의 최초 값은 OS별로 다르게 설정되지만 통상적으로 64나 128로 설정됩니다.
이렇게 패킷에 수명을 두는 이유는 라우팅 테이블 정보에 오류가 있거나 기기의 고장 등으로 인해 우회로로 전환될 때 일시적으로 패킷이 같은 라우터들을 순환해서 도는 사태를 막기 위함입니다.&lt;/p&gt;

&lt;h4 id=&quot;큰-패킷은-조각화하여-중계한다&quot;&gt;큰 패킷은 조각화하여 중계한다&lt;/h4&gt;

&lt;p&gt;라우터의 포트는 앞서 살펴봤듯이 이더넷뿐만 아니라 다양한 통신 기술을 지원합니다. 그 종류에 따라 패킷의 최대 길이가 달라져서 라우터 간의 포트 입력측과 출력측의 패킷 최대 길이가 다른 경우가 있습니다. 중계하는 &lt;strong&gt;패킷의 크기가 출력측의 패킷 최대 길이를 초과하게 되면 패킷을 조각화(fragmentation)해서 보내야&lt;/strong&gt; 합니다.
패킷의 조각화는 IP 헤더의 필드들로 수행합니다. 우선 출력측 포트의 MTU를 조사해서 중계하는 패킷을 그대로 출력해서 송신할 수 있는지 조사합니다. 만약 MTU가 패킷의 크기보다 작으면 IP 헤더의 플래그 필드를 조사하여 조각화가 가능한지 살펴봅니다. 만약 송신처에서 조각화 불가 플래그를 설정해서 보냈으면 조각화가 불가능하기 때문에 패킷을 폐기하고 ICMP 프로토콜로 송신처에 통지를 합니다. 그렇지 않으면 이제 조각화를 시작합니다. 이때 TCP 헤더 이후의 부분을 분할 대상 데이터로 간주합니다. TCP 헤더도 IP 헤더 입장에서는 데이터이기 때문입니다. 그렇게 분할된 데이터에 IP 헤더를 모두 붙여줍니다. 이때 IP 헤더의 Identification 필드로 조각화된 패킷이 하나의 그룹임을 식별하고, offset 필드의 값으로 조각난 패킷의 순서를 식별할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;라우터의-송신-동작&quot;&gt;라우터의 송신 동작&lt;/h4&gt;

&lt;p&gt;TTL 체크와 패킷 조각화가 끝나면 라우터는 송신 동작을 수행합니다. 송신 동작은 포트의 통신 기술에 따라 달라지지만, 여기서는 이더넷 포트임을 가정해서 살펴보겠습니다. 이더넷의 패킷 송신 동작은 이더넷 규칙에 따라 동작하기 때문에 라우터라도 송신 동작은 앞서 살펴본 것과 동일합니다. MAC 헤더에 수신처 MAC 주소를 채우기 위해서 테이블의 게이트웨이 항목에서 중계 상대를 판단합니다. 만약 게이트웨이 항목에 IP 주소가 비어있으면 IP 헤더의 수신처 IP가 중계 대상이 됩니다. 이렇게 IP 주소를 정했으면 그 주소를 ARP 프로토콜에 세팅하여 수신처 MAC 주소를 구합니다. 그리고 송신처 MAC 주소는 출력 포트의 ROM에서 구하게 됩니다.
이렇게 MAC 헤더까지 붙여서 송신 패킷을 만들었으면 전기 신호로 변환해서 포트에서 송신합니다. 만약 반이중 모드라면 케이블에 신호가 흐르지 않는지 확인하고 송출하고, 전이중 모드면 그런 확인 없이 바로 송신합니다.
송신한 패킷은 스위칭 허브를 경유하여 다음 라우터에 도달합니다. 스위칭 허브는 패킷의 MAC 헤더에 설정된 수신처 MAC 주소를 보고 자신의 MAC 테이블과 대조해서 중계합니다.&lt;/p&gt;

&lt;h3 id=&quot;라우터의-부가-기능&quot;&gt;라우터의 부가 기능&lt;/h3&gt;

&lt;p&gt;라우터는 앞서 살펴본 기능 외에도 &lt;strong&gt;주소 변환&lt;/strong&gt;과 &lt;strong&gt;패킷 필터링&lt;/strong&gt;이라는 중요한 기능을 가지고 있습니다. 하나씩 살펴보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;주소-변환&quot;&gt;주소 변환&lt;/h4&gt;

&lt;p&gt;주소 변환 기능은 인터넷에 접속하는 기기의 수가 기하급수적으로 늘어나면서 그 기기들에 할당해줄 고유한 주소의 부족 문제를 해결하기 위해서 등장했습니다. 그래서 공인 IP, 사설 IP라는 개념이 등장했습니다. 예를 들어보겠습니다. A사와 B사가 있고 이 둘은 완전히 독립된 사내 네트워크를 각자 구축했습니다. 그럼 A사와 B사가 패킷을 주고받을 일이 없으니 A사의 서버에 할당한 주소와 같은 주소를 B사의 클라이언트에 할당해도 됩니다. 즉 네트워크 대역만 다르다면 그 대역 내의 서버에 할당하는 주소는 다른 대역의 서버에 할당하는 주소와 겹쳐도 상관이 없는 것입니다. 이게 사설 IP 입니다. 대신 두 네트워크 대역의 구분은 필요합니다. 이처럼 네트워크 대역 구분을 위한 주소가 공인 IP 입니다. 이렇게 주소를 관리하면 주소를 대폭 절약할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;사설 IP로 사용할 수 있는 주소의 범위는 아래와 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;10.0.0.0 ~ 10.255.255.255&lt;/li&gt;
  &lt;li&gt;172.16.0.0 ~ 172.31.255.255&lt;/li&gt;
  &lt;li&gt;192.168.0,0 ~ 192.168.255.255&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 범위에 해당하는 주소는 각 네트워크 대역 안에서 자유롭게 할당해서 쓸 수 있습니다.&lt;/p&gt;

&lt;p&gt;그런데 이런 네트워크 대역 안의 기기가 그 대역 안의 기기와만 통신을 하는 것은 아닙니다. 인터넷을 통해 다른 대역에 있는 기기와도 통신을 해야 하는데 그렇게 되면 주소의 충돌이 발생합니다. 바로 이 문제를 해결하기 위해서 라우터가 사설 IP를 공인 IP로, 또 공인 IP를 다시 사설 IP로 변환하는 주소 변환이라는 것을 수행하는 것입니다. TCP의 3-way-handshake를 통한 접속 동작시에 최초로 흐르는 패킷을 중계할 때 사설 IP로 기재된 송신처 IP 주소를 공인 IP로 바꿉니다. 이때 공인 IP는 라우터의 인터넷측에 연결된 포트에 할당된 주소입니다. 그리고 TCP 헤더의 포트 번호도 바꾸어 씁니다. 바꿀 포트 번호는 라우터가 미사용 번호 중에 적당한 것으로 바꿔줍니다. 이렇게 바꿀 때 기존 사설 IP주소와 포트 번호, 공인 IP주소와 바뀐 포트번호를 한 세트로 해서 대응표에 그록해둡니다. 이 대응표를 &lt;strong&gt;NAT 테이블&lt;/strong&gt;이라고 합니다. 즉 패킷의 수신처는 사실 송신처의 공인 IP로만 식별을 할뿐 송신처의 사설 IP는 알지 못하는 셈입니다. 그럼 당연히 송신처가 패킷을 회신했을 때의 수신처 IP는 공인 IP로 되어있을 것이고 이것을 NAT 테이블에서 찾아서 다시 사설 IP와 원래 포트 번호로 바꿔서 실제 기기로 전달을 해주게 됩니다.&lt;/p&gt;

&lt;p&gt;그럼 한 가지 의문이 생깁니다. 요청을 먼저 보내는 클라이언트는 패킷을 내보낼 때 NAT 테이블에 기록을 해둬서 응답을 받았을 때도 적절한 기기로 패킷을 전달해줄 수 있지만, 한번도 요청 패킷을 내보낸 적이 없는(즉 NAT 테이블에 기록을 해둔적이 없는) 서버로 어떻게 패킷이 정상적으로 운반될 수 있을까요? 원칙적으로 바깥으로 패킷을 내보낸 적이 없는 기기에 패킷을 전달할 수는 없습니다. NAT 테이블에 기록이 되어있지 않기 때문이죠. 하지만 수동으로 NAT 테이블에 기록을 해뒀으면 가능합니다. 그럼 사설 IP가 할당된 서버에도 요청을 전달할 수 있게 됩니다. 공인 IP 주소에 물린 포트번호에 대응되는 사설 IP 주소와 포트번호를 NAT 테이블에 등록해두면 그 공인 IP주소와 포트번호로 요청이 오면 사설 IP로 패킷을 전달해줄 수 있습니다. 이런 것을 &lt;strong&gt;포트 포워딩&lt;/strong&gt;이라고 합니다.&lt;/p&gt;

&lt;h4 id=&quot;라우터의-패킷-필터링&quot;&gt;라우터의 패킷 필터링&lt;/h4&gt;

&lt;p&gt;패킷 필터링은 패킷을 중계할 때 MAC 헤더, IP 헤더, TCP 헤더에 기록되어 있는 내용을 조사해서 그것이 사전에 설정한 조건에 합치되는 경우에만 패킷을 중계하는 것을 말합니다. 대부분의 방화벽 기기나 소프트웨어는 이 원리로 부정 침입을 방지합니다. 패킷 필터링은 원리는 간단하지만 필터링 조건을 설정하는 것이 간단하지 않습니다. 이와 관련해서는 서버의 동작에서 자세히 살펴보겠습니다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><category term="CS" /><summary type="html">Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘3장 케이블의 앞은 LAN기기였다’를 정리했습니다.</summary></entry><entry><title type="html">성공과 실패를 결정하는 1%의 네트워크 원리 2장</title><link href="https://anstn1993.github.io/2022/01/25/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-2%EC%9E%A5.html" rel="alternate" type="text/html" title="성공과 실패를 결정하는 1%의 네트워크 원리 2장" /><published>2022-01-25T00:00:00+09:00</published><updated>2022-01-25T00:00:00+09:00</updated><id>https://anstn1993.github.io/2022/01/25/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1%25%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-2%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2022/01/25/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-2%EC%9E%A5.html">&lt;p&gt;Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘2장 TCP/IP의 데이터를 전기 신호로 만들어 보낸다’를 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;2장-tcpip의-데이터를-전기-신호로-만들어-보낸다&quot;&gt;2장. TCP/IP의 데이터를 전기 신호로 만들어 보낸다.&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;2장에서는 프로토콜 스택이 패킷을 생성하고 LAN 어댑터에 넘긴 후, LAN 어댑터가 패킷을 디지털 데이터에서 전기 신호로 변환해서 케이블에 송출하는 순간까지 탐험합니다.&lt;/p&gt;

&lt;h3 id=&quot;프로토콜-스택의-내부-구성&quot;&gt;프로토콜 스택의 내부 구성&lt;/h3&gt;

&lt;p&gt;프로토콜 스택이 무슨 일을 하는지 보기에 앞서 프로토콜 스택이 어떻게 구성되어있는지 보겠습니다. 프로토콜 스택은 &lt;strong&gt;TCP, UDP, IP&lt;/strong&gt;로 구성됩니다. 계층적으로 TCP, UDP가 IP보다 상위 계층으로, TCP, UDP가 애플리케이션에서 보낸 의뢰를 받아서 &lt;strong&gt;데이터의 송수신&lt;/strong&gt;을 담당하고, 그 아래의 IP 프로토콜을 사용해서 &lt;strong&gt;패킷의 송수신&lt;/strong&gt; 동작을 제어하게 됩니다. IP 안에는 ARP, ICMP 같은 프로토콜을 다루는 부분도 포함되어있는데, 자세한 건 뒤에서 살펴보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;소켓은-통신-제어용-제어-정보다&quot;&gt;소켓은 통신 제어용 제어 정보다&lt;/h3&gt;

&lt;p&gt;소켓은 프로토콜 스택이 통신 동작을 수행하기 위해서 필요한 제어 정보(수신처 IP 주소, 포트 번호, 통신 동작의 진행 상태 등..)를 의미합니다. 혹은 이런 제어 정보를 저장하는 프로토콜 스택 내부의 메모리 영역이 소켓이라고 생각해도 무방합니다. 프로토콜 스택은 이 소켓의 정보를 참조하면서 동작합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;netstat&lt;/code&gt; 커맨드를 사용하면 소켓의 내용을 살펴볼 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;netstat &lt;span class=&quot;nt&quot;&gt;-an&lt;/span&gt;
Active Internet connections &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;including servers&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Proto  Local Address          Foreign Address        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;state&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
tcp4  192.168.0.10.49809     142.251.42.206.443     ESTABLISHED
tcp4  192.168.0.10.49804     172.217.25.99.443      ESTABLISHED
tcp46  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.80                   &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;                    LISTEN
tcp46  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.443                  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;                    LISTEN
tcp4   &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.3306                 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;                    LISTEN
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Local Address는 로컬 ip주소와 포트 번호를 표시하고 Foreign Address는 통신 상대의 ip주소와 포트 번호를 나타냅니다. 192.168.0.10라는 ip를 할당한 LAN 어댑터를 사용해서 원격측과 통신을 하고 있습니다. state가 ‘ESTABLISHED’인 것을 통해 원격측과 접속이 끝나고 통신을 하고 있음을 의미하고, 그 중에서도 로컬측의 포트번호가 49809번인 프로세스가 142.251.42.206 ip주소를 가진 상대측의 443번 포트를 사용하는 프로세스와 통신을 하고 있고 포트번호가 49804번인 프로세스가 172.217.25.99 ip 주소를 가진 상대측의 443번 포트를 사용하는 프로세스와 통신을 하고 있습니다.
state가 ‘LISTEN’인 경우는 아직 상대의 접속을 기다리고 있음을 의미합니다. 로컬측, 원격측의 ip주소가 명확히 지정되지 않은 이유는 아직 통신이 시작되지 않았기 때문입니다. 만약에 로컬 주소에 ip 주소를 지정해주면, 그건 해당 ip 주소의 LAN 어댑터로만 요청을 처리하겠다는 것을 의미합니다. 보통 복수의 LAN 어댑터를 장착하고 있는 서버에서 접속 동작을 특정 LAN 어댑터로만 제한하려고 할 때 사용합니다.&lt;/p&gt;

&lt;h3 id=&quot;프로토콜-스택이-하는-일&quot;&gt;프로토콜 스택이 하는 일&lt;/h3&gt;

&lt;p&gt;이제 애플리케이션이 소켓 라이브러리의 루틴을 호출했을 때 프로토콜 스택이 실제로 하는 일을 살펴봅니다.&lt;/p&gt;

&lt;h4 id=&quot;socket을-호출했을-때-프로토콜-스택이-하는-일&quot;&gt;socket()을 호출했을 때 프로토콜 스택이 하는 일&lt;/h4&gt;

&lt;p&gt;소켓의 제어 정보를 저장하기 위한 메모리 공간을 할당받습니다. 이 시점은 아직 송/수신 동작이 시작되지 않은 초기상태이기 때문에 제어 정보를 소켓의 메모리 영역에 기록해둡니다. 이렇게 소켓이 만들어지면 소켓 식별자인 디스크립터를 반환해줍니다.
애플리케이션은 이 디스크립터를 이후의 동작 의뢰시에 함께 전달해서 프로토콜 스택이 어떤 소켓에 대해서 작업을 해야할지 결정할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;connect를-호출했을-때-프로토콜-스택이-하는-일&quot;&gt;connect()를 호출했을 때 프로토콜 스택이 하는 일&lt;/h4&gt;

&lt;p&gt;만들어둔 소켓을 통신 대상 서버측 소켓에 접속합니다. 제어 정보를 의미하는 물리적 실체가 없는 소켓에 접속이라는 단어가 사용되어서 다소 모호하게 느껴진다면 접속 대신 ‘준비’라고 생각해도 좋습니다. 그럼 무엇을 준비해야 할까요? 크게 두가지가 있습니다.
하나는 클라이언트와 서버가 서로의 &lt;strong&gt;제어정보&lt;/strong&gt;를 교환하는 것입니다. 제어정보는 &lt;strong&gt;패킷의 헤더&lt;/strong&gt;를 의미합니다. 헤더는 실제 요청 데이터의 앞쪽에 붙는 정보로, TCP, IP, 이더넷의 제어정보가 순차적으로 붙게 됩니다. 이 헤더는 항상 고정되어있기 때문에 접속단계뿐만 아니라 데이터를 송/수신할 때, 연결을 끊을 때와 같이 클라이언트와 서버가 통신을 할 때는 항상 헤더에 명시된 정보를 토대로 이루어집니다. 접속단계에서는 아직 데이터의 송/수신이 이루어지지 않기 때문에 이때 주고받는 패킷은 헤더(제어정보)로만 이루어져있습니다. 프로토콜 스택이 처음에 소켓을 생성한 직후에는 통신 상대에 대한 정보가 존재하지 않습니다. 그래서 접속 단계에서 애플리케이션이 통신 대상에 대한 정보를 connect()의 인자로 함께 전달합니다. 그럼 프로토콜 스택은 제어정보(ip주소, 포트번호 등..)를 담은 헤더로만 구성된 패킷을 서버로 보내게 됩니다. 클라이언트의 제어정보를 받은 서버도 클라이언트의 정보를 알 수 있게 되고 비로소 통신을 할 준비가 끝나게 됩니다.
다른 하나는 송/수신하는 데이터를 일시적으로 저장할 버퍼 메모리를 확보하는 것입니다.
위 두가지 준비가 끝나면 접속이 됐다고 이해하면 됩니다.&lt;/p&gt;

&lt;p&gt;그럼 데이터의 송/수신을 위해 무엇을 준비해야하는지 알았으니 그 중에서도 클라이언트와 서버가 제어정보(헤더만으로 구성된 패킷)를 어떻게 교환하는지 구체적으로 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56672937/151005977-df270e91-1e6b-4bc6-8fa6-174c98a1c008.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로토콜 스택의 TCP가 데이터 송/수신 동작의 개시를 나타내는 제어 정보를 기록한 TCP 헤더를 생성합니다. 이 헤더에 세팅하는 주요 값들은 &lt;strong&gt;송신처(클라이언트)의 포트 번호&lt;/strong&gt;, &lt;strong&gt;수신처(서버)의 프토 번호&lt;/strong&gt;, 그리고 컨트롤 비트 중 &lt;strong&gt;SYN 비트를 1로&lt;/strong&gt; 설정합니다. SYN는 Sync의 약어로 상대방과 연결을 시작할 때 설정하는 비트입니다. 즉 연결을 통해 상대방과 동기화를 하겠다는 의미로 이해하면 됩니다. 사실 이때 헤더에 &lt;strong&gt;시퀀스 번호와 윈도우&lt;/strong&gt;라는 값도 함께 설정해서 보내게 되는데 이건 뒤에서 살펴보겠습니다. 이렇게 TCP가 만든 패킷을 IP에게 건네주면 송신 동작을 실행해서 서버로 패킷을 전달합니다. IP가 패킷을 송신하는 동작은 뒤에서 구체적으로 살펴보겠습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서버가 패킷을 받으면 서버의 프로토콜 스택의 IP가 패킷을 TCP로 전달해줍니다. 그럼 패킷의 헤더를 조사해서 수신처 포트번호를 보고 그 번호에 해당하는 소켓을 찾고 그 소켓에 클라이언트의 제어 정보를 기록하고 접속 동작이 진행중이라는 상태로 바뀝니다. 그리고 서버의 TCP가 클라이언트에 응답을 해주게 됩니다. 이때 TCP 헤더에 &lt;strong&gt;SYN 컨트롤 비트와 ACK 컨트롤 비트를 1로&lt;/strong&gt; 만듭니다. 서버도 클라이언트와 연결을 하겠다는 의미에서 &lt;strong&gt;SYN 비트를 시퀀스 번호, 윈도우와 함께 설정&lt;/strong&gt;합니다. ACK는 Acknowledgement의 약어로 클라이언트의 SYN 요청 패킷을 잘 전달받았고 그것을 승인하겠다 의미를 지닙니다. 이때 ACK 번호도 헤더에 함께 세팅해서 보내게 되는데 이는 뒤에서 살펴보겠습니다. 이렇게 세팅된 TCP 헤더를 IP에 전달하여 클라이언트에 응답하게 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;응답을 받은 클라이언트는 마찬가지로 IP에서 TCP로 패킷이 흘러가게 되고 서버측이 ACK 컨트롤 비트를 1로 설정했는지 확인해서 접속 동작이 성공했는지 확인합니다. 성공했으면 서버의 제어정보를 소켓에 저장하게 됩니다. 여기서 끝나지 않고, 클라이언트에서 서버쪽에 TCP 헤더의 &lt;strong&gt;ACK 컨트롤 비트를 1로&lt;/strong&gt; 세팅해서 ACK 번호와 함께 한 번 더 패킷을 응답합니다. 서버쪽에도 클라이언트가 패킷을 잘 받았음을 알리기 위함입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기까지가 접속 동작의 구체적인 플로우입니다. 접속 동작에서 클라이언트와 서버 사이에서 3번의 패킷이 오가는데 이런 연결 동작을 &lt;strong&gt;3-way-handshake&lt;/strong&gt;라고 합니다. 이제 서버와 클라이언트의 소켓은 데이터를 송/수신할 수 있는 상태입니다. 이런 걸 비유적인 표현으로 &lt;strong&gt;두 소켓이 파이프로 연결됐다&lt;/strong&gt;고 하기도 합니다. 저 파이프를 &lt;strong&gt;커넥션, 세션&lt;/strong&gt;이라고 하기도 합니다. 이는 네트워크에서 자주 등장하는 용어들이기 때문에 이런 용어들을 마주하면 양쪽의 소켓이 서로의 제어정보를 가지고 통신을 할 수 있는 상태라고 이해하면 될 것 같습니다.&lt;/p&gt;

&lt;h4 id=&quot;write를-호출했을-때-프로토콜-스택이-하는-일&quot;&gt;write()를 호출했을 때 프로토콜 스택이 하는 일&lt;/h4&gt;

&lt;p&gt;클라이언트가 서버에 접속했다면 이제 데이터를 송/수신해야 합니다. 먼저 송신을 위해 write()를 호출하면 프로토콜 스택은 전달받은 &lt;strong&gt;데이터를 송신용 버퍼 메모리에 저장하고 애플리케이션이 다음 데이터를 전달해주기를 기다립니다.&lt;/strong&gt; 바로 전달을 하지 않는 이유는 한번 패킷을 보낼 때 최대한 많은 양의 데이터를 담아서 보내기 위함입니다. 애플리케이션별로 프로토콜 스택에 전달하는 데이터의 길이는 저마라 다르기 때문에 어떤 애플리케이션은 전체 데이터를 한번에 전달할 수도 있고 어떤 애플리케이션은 1바이트씩 쪼개서 전달할 수도 있습니다. 이는 프로토콜 스택에서 제어할 수 없는 것입니다. 만약 전체 데이터를 너무 작은 단위로 쪼개서 송신 의뢰를 할 때 버퍼에 쌓아두지 않고 매번 실제로 패킷을 보내버리면 네트워크의 효율이 저하되기 때문에 기다리는 것입니다. 이때 프로토콜 스택은 한 패킷에 저장할 수 있는 데이터의 최대 크기인 MTU(Maximum Transmission Unit)라는 매개변수를 기준으로 실제 전송 동작을 수행할 타이밍을 잡습니다. 보통 이더넷에서는 1500바이트가 됩니다. 여기서 헤더를 제외해야 실제로 전송할 수 있는 데이터의 최대 크기가 나오는데 이것을 MSS(Maximum Segment Size)라고 합니다. 보통 TCP, IP 헤더를 합치면 40바이트가 되기 때문에 MSS는 일반적으로 1460바이트가 됩니다. 애플리케이션에게 받은 데이터의 크기가 MSS를 초과하거나 MSS에 가까운 크기가 됐을 때 송신 동작을 수행하면 효율이 높은 송신을 수행할 수 있는 것입니다.
하지만 데이터의 크기에만 의존해서 송신 동작을 수행할 타이밍을 잡으면 안 됩니다. 애플리케이션의 송신 속도가 느려서 MSS에 가깝게 데이터를 송신 버퍼에 쌓는 시간이 오래 걸릴 수도 있기 때문입니다. 그래서 프로토콜 스택은 내부적으로 &lt;strong&gt;타이머를 두고 일정 시간이 경과하면 데이터가 MSS에 미치지 못하더라도 패킷을 송신&lt;/strong&gt;합니다.
프로토콜 스택에는 이렇게 상충되는 송신 동작의 판단 요소를 적절하게 절충해서 송신 동작을 언제 수행할지 판단하게 됩니다. 이때 두 판단 요소를 어떻게 절충할지에 대한 명확한 규정이 없기 때문에 이는 전적으로 프로토콜 스택을 개발하는 개발자에게 달려있습니다.
이때 송신 타이밍을 애플리케이션이 제어하게 할 수도 있습니다. write()를 호출할 때 송신 버퍼에 쌓아두지 말고 바로 전송하라는 옵션을 전달하면 프로토콜 스택은 바로 송신 동작을 수행합니다. 보통 브라우저 같이 대화형 애플리케이션이 서버에 메시지를 보낼 때 버퍼에 머무는 시간만큼 응답 지연이 발생하기 때문에 이런 옵션을 많이 사용할 것입니다.&lt;/p&gt;

&lt;p&gt;그럼 반대로 데이터가 MSS를 초과하는 크기를 가진 경우는 어떻게 될까요? 이때는 MSS를 초과하기 때문에 바로 송신 동작에 들어가는데 데이터를 MSS 크기에 맞게 분할해서 송신 버퍼에 저장합니다. 그럼 분할된 각각의 데이터 조각들에 TCP 헤더를 붙이고 조각별로 IP에게 건네서 송신 동작을 수행합니다. 이때 조각화된 패킷들이 서버에 도착하면 그 패킷들의 데이터를 다시 완결된 형태로 합칠 수 있어야 합니다. 이렇게 조각화된 데이터를 합칠 수 있는 단서들은 IP 헤더에 기록되어있고 이는 뒤에서 자세히 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;TCP 통신은 데이터의 송신만 하고 끝나지 않습니다. 항상 상대방에게 송신한 패킷이 잘 도착했는지 &lt;strong&gt;확인하는 동작&lt;/strong&gt;을 수행해서 도착하지 않았으면 다시 송신해서 &lt;strong&gt;신뢰성을 보장&lt;/strong&gt;합니다. 이 확인 동작은 TCP 헤더의 &lt;strong&gt;시퀀스 번호&lt;/strong&gt;와 &lt;strong&gt;ACK 번호&lt;/strong&gt;를 통해서 하게 됩니다.
시퀀스 번호는 송신 데이터의 일련번호로 데이터 조각을 송신할 때 각 패킷의 맨 앞 위치의 데이터가 전체 데이터의 몇번째 바이트인지를 송신측에서 수신측으로 전달하기 위한 값입니다. ACK 번호는 수신 데이터의 일련번호로 수신측이 전체 데이터 중 몇바이트까지 수신했는지를 송신측에 전달하기 위한 값입니다. 구체적인 예로 살펴보겠습니다. 클라이언트에서 데이터를 1460바이트(MSS)로 조각화해서 여러 패킷을 전달한다고 가정하겠습니다. 그리고 초기 시퀀스 번호 1이라고 가정하겠습니다. 이 초기 시퀀스 값은 연결시점에 3-way-handshake에서 클라이언트가 SYN 컨트롤 비트를 1로 설정해서 패킷을 전송할 때 설정하게 됩니다. 참고로 이 시퀀스 번호는 항상 랜덤하게 생성됩니다. 시퀀스 번호가 고정되면 시퀀스 번호를 예측할 수 있게 되기 때문에 악의적인 공격이 발생할 수 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56672937/151006334-6a0b33d8-aae6-485e-87b4-84c5f029c322.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 클라이언트에서 시퀀스 번호를 1로 설정해서 서버로 첫번째 조각 패킷을 보내겠습니다. 그럼 서버는 데이터의 크기를 계산해서 1460바이트인 것을 확인하고 시퀀스 번호에 데이터 크기만큼 더한 1461로 ACK 번호를 세팅해서 클라이언트로 응답하게 됩니다.(ACK 컨트롤 비트도 1로 세팅) 이때 서버는 다음 패킷의 시퀀스 번호가 1461번일 것으로 기대하게 됩니다. 그럼 클라이언트는 다음 시퀀스 번호를 서버에게 받은 ACK 번호인 1461로 설정하고 다시 전송합니다. 그럼 서버는 ACK 번호를 시퀀스 번호에 데이터 크기만큼 더한 2921로 설정해서 응답합니다. 이렇게 응답측에서 ACK 번호를 돌려주는 것을 &lt;strong&gt;수신 확인 응답&lt;/strong&gt;이라고 합니다. 즉, 송신측의 시퀀스 번호와 응답측의 ACK 번호는 계속 동기화되는 것입니다. 이를 통해 패킷의 누락을 검출할 수 있습니다. 가령 서버가 응답한 ACK 번호가 1461인데 그 다음 전달된 패킷의 시퀀스 번호가 2921이면 패킷이 누락되었음을 알 수 있기 때문입니다.
지금까지 살펴본 과정은 클라이언트에서 서버로만 패킷을 전달하는 흐름만 고려한 것인데 사실 서버에서 클라이언트로 패킷을 전달하는 흐름에서도 이런 과정은 동일하게 일어납니다. 서버에서 클라이언트에게 응답 데이터를 생성해서 보내면 클라이언트도 마찬가지로 ACK 번호를 산출해서 서버에 전달하게 됩니다.&lt;/p&gt;

&lt;p&gt;그럼 시퀀스 번호와 ACK 번호를 중점으로 클라이언트와 서버의 연결부터 데이터 송/수신을 다시 한번 살펴보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;연결 동작&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;클라이언트는 SYN비트를 1로 설정하고 시퀀스 번호 초기값을 서버에 전송&lt;/li&gt;
      &lt;li&gt;서버는 SYN, ACK 비트를 1로 설정하고 ACK 번호와 시퀀스 번호 초기값을 클라이언트로 전송&lt;/li&gt;
      &lt;li&gt;클라이언트는 ACK 비트 1로 설정하고 ACK 번호를 서버로 전송&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;송/수신 동작&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;클라이언트는 서버로 데이터와 함께 시퀀스 번호를 전송&lt;/li&gt;
      &lt;li&gt;서버는 ACK 번호를 클라이언트로 전송&lt;/li&gt;
      &lt;li&gt;서버는 응답 데이터와 함께 시퀀스 번호를 전송&lt;/li&gt;
      &lt;li&gt;클라이언트는 ACK 번호를 서버로 전송&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이처럼 클라이언트건, 서버건 서로가 보낸 패킷의 시퀀스 번호를 확인하고 ACK 번호를 반환합니다. 이때 클라이언트, 서버 모두 &lt;strong&gt;ACK 번호를 확인하기 전까지는 송신용 버퍼 메모리에 송신한 패킷을 보관&lt;/strong&gt;합니다. 송신한 데이터에 대응하는 ACK 번호가 돌아오지 않으면 동일한 패킷을 다시 보내기 위함입니다. TCP는 이런 방식으로 신뢰성을 보장합니다. 그리고 TCP의 이런 동작 덕분에 LAN 어댑터, 버퍼, 라우터, 애플리케이션 모두 오류가 발생해도 회복 조치를 취하지 않습니다.&lt;/p&gt;

&lt;p&gt;TCP가 오류를 검출하고 회복하는 과정을 좀 더 구체적으로 살펴보겠습니다. 가장 중요한 것은 ACK 번호가 돌아오는 것을 기다리는 대기시간(타임아웃)을 적절하게 설정하는 것입니다. 네트워크가 혼잡한 상황이면 ACK 번호 응답이 지연되기 때문에 대기시간을 넉넉하게 잡아야 합니다. 그렇지 않으면 ACK 번호가 돌아오기 전에 패킷을 다시 보내게 됩니다. 이는 불필요한 패킷 전송으로 인해 네트워크를 더 혼잡하게 만듭니다. 하지만 반대로 대기시간이 너무 길어도 정말 패킷을 다시 보내야 하는 상황에서 패킷을 다시 보내는 동작에 지연이 발생합니다. 하지만 서버와 클라이언트의 거리, 네트워크의 혼잡도 등의 다양한 변수 때문에 적절한 대기시간을 정하는 것은 매우 어려운 일입니다. 그래서 TCP는 대기시간을 동적으로 변경하는 전략을 취하고 있습니다. TCP는 데이터 송신 동작을 할 때 항상 ACK 번호가 돌아오는 시간을 항상 기록해두고, ACK 번호가 돌아오는 시간이 기록해둔 시간보다 지연되면 대기 시간도 늘리게 됩니다. 반대로 더 빨리 도착하면 대기시간을 짧게 설정합니다.&lt;/p&gt;

&lt;p&gt;TCP는 윈도우 제어를 통해 ACK 번호가 돌아올 때까지 기다리는 시간 낭비를 줄입니다. 윈도우 제어 방식은 응답측에서 ACK 번호를 받기 전까지 기다리지 않고 보내야 하는 패킷을 계속 보내게 됩니다. 아주 효율적인 방식이지만 &lt;strong&gt;송신측의 패킷 전송 속도가 수신측의 수신 버퍼 처리 속도보다 빨라져서 수신 버퍼의 용량이 초과&lt;/strong&gt;하는 문제가 발생할 수 있습니다. 이 문제를 해결하기 위해서 &lt;strong&gt;TCP 헤더의 윈도우 필드&lt;/strong&gt;를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56672937/151006561-f90a964e-c265-4717-a045-04cafbb2449c.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;윈도우 필드는 수신측의 수신 버퍼의 여유 공간을 담습니다. 수신측이 송신측에 수신 가능한 데이터의 양을 윈도우 필드에 세팅해서 통지하면 송신측은 수신측 버퍼에 공간이 얼마나 남았는지 알고, 자신이 패킷을 보낼때마다 데이터의 크기도 알기 때문에 스스로 계산을 해서 수신측 버퍼의 여유공간이 0이 되는 순간에 송신을 중단하게 됩니다. 수신측은 수신처리가 끝나서 수신 버퍼에 여유 공간이 생기면 다시 윈도우 필드를 세팅해서 송신측에 알리게 되고 송신측은 다시 패킷을 전송하기 시작합니다. 이렇게 해서 수신 버퍼의 용량 초과 없이 데이터를 전송할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;그런데 수신측의 입장에서 한가지 고려해야 할 것이 있습니다. 위의 그림에서는 수신측이 송신측에 윈도우 통지를 하는 플로우만 표현했지만 사실 송신측으로부터 받은 패킷에 응답하는 ACK 번호 통지도 함께 일어나게 됩니다. 그럼 효율성을 높이려면 왼도우와 ACK번호를 통지하는 타이밍을 잘 잡아야 합니다. 윈도우가 송신측으로 통지되는 타이밍은 수신측에서 애플리케이션에 데이터를 건네주고 수신 버퍼의 빈 영역이 늘어났을 때입니다. ACK 번호가 송신측으로 통지되는 타이밍은 데이터를 받았을 때 내용을 조사해서 정상 수신을 확인할 수 있는 경우 입니다. 다시 말해 데이터를 수신한 후 즉시 보내게 됩니다. 개념적으로만 보면 ACK 번호를 먼저 통지하고, 애플리케이션에 데이터를 전달해준 후 윈도우를 통지하는 게 맞지만, 이 둘을 따로따로 통지하는 건 비효율적입니다. 그래서 ACK 번호나 윈도우를 통지할 때 바로 보내지 않고 잠시 기다렸다가 다음 통지가 발생할 때 두 통지를 하나의 패킷으로 묶어서 보냅니다. 예를 들면 ACK번호 송신 대조를 하는 시점에 윈도우 통지도 발생하면 ACK번호와 윈도우를 하나의 패킷으로 묶어서 보내주는 것입니다. 또한 ACK 번호 통지가 연속해서 일어난 경우에도 마지막 통지만 해주면 됩니다. 윈도우 통지도 마찬가지입니다. 애플리케이션에 데이터를 전달하는 동작이 여러번 일어난다 하더라도 가장 마지막 통지 시점에 수신 버퍼 크기만 알려주면 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;read를-호출했을-때-프로토콜-스택이-하는-일&quot;&gt;read()를 호출했을 때 프로토콜 스택이 하는 일&lt;/h4&gt;

&lt;p&gt;애플리케이션이 write()로 송신 동작을 의뢰했으면 read()를 호출하여 응답 메세지 수신을 프로토콜 스택에 의뢰합니다. 수신 데이터는 앞서 살펴본 수신 버퍼에 쌓이게 됩니다. 송신을 하자마자 수신이 되지는 않기 때문에 프로토콜 스택은 수신버퍼에 데이터가 쌓일 때까지 대기를 합니다. 대기를 하는동안 프로토콜 스택은 다른 작업을 수행하다가 패킷이 도착하면 작업을 다시 시작합니다. 수신한 데이터 조각과 TCP 헤더의 내용(시퀀스 번호와 ACK 번호)을 조사해서 데이터 누락이 되지 않았는지 검사합니다. 문제가 없으면 ACK 번호를 반송합니다. 그리고 데이터 조각은 수신 버퍼에 TCP가 설정한 시간만큼 보관하고 쌓인 조각들을 복원하여 애플리케이션에 건내줍니다. 이후 통지 타이밍을 가늠해서 윈도우를 송신측에 통지합니다.&lt;/p&gt;

&lt;h4 id=&quot;close를-호출했을-때-프로토콜-스택이-하는-일&quot;&gt;close()를 호출했을 때 프로토콜 스택이 하는 일&lt;/h4&gt;

&lt;p&gt;송/수신 동작까지 끝나면 애플리케이션은 close()를 호출하여 프로토콜 스택에게 연결 끊기 동작에 들어가게 됩니다. 연결 끊기 동작은 송신을 완료한 쪽에서 하게 됩니다. 어디에서 송신을 완료하는지는 애플리케이션마다 다르지만 웹의 경우에는 서버가 요청에 응답하면서 데이터의 송신이 완료되기 때문에 서버에서 연결 끊기에 들어갑니다. 그런데 이건 HTTP 1.0에 해당하는 내용이고 HTTP 1.1에서는 클라이언트가 하나의 소켓으로 계속해서 요청 메시지를 보낼 수 있기 때문에 더 이상 보낼 요청이 없다고 판단하는 순간 클라이언트에서 먼저 끊기 단계에 돌입할 수도 있습니다. 이 장에서는 서버가 연결 끊기를 시작하는 것으로 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56672937/151006774-b254bf09-f6fd-4a71-93b6-5d45e76908cb.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서버측의 프로토콜 스택이 TCP 헤더의 FIN 컨트롤 비트를 1로 세팅하고 IP에게 클라이언트로 송신을 의뢰합니다. 동시에 소켓에 연결 끊기 동작에 들어갔다는 정보를 기록하게 됩니다. 패킷을 받은 클라이언트의 프로토콜 스택은 서버측의 TCP 헤더를 확인하고 자신의 소켓에 서버측이 연결 끊기 동작에 들어갔음을 기록합니다. 서버의 연결 끊기를 잘 수신했음을 통지하기 위해 ACK 번호를 서버에 통지하고 애플리케이션이 read()를 호출하여 데이터를 가지러 올 때까지 기다립니다. read()가 호출되면 데이터 수신을 완료했다는 사실을 애플리케이션에게 알립니다. 그럼 애플리케이션도 close()를 호출하고 프로토콜 스택은 서버와 같이 TCP 헤더에 FIN 비트를 1로 세팅하고 IP에 의뢰해서 서버로 송신합니다. 서버에서 ACK 번호가 돌아오면 끝입니다.&lt;/p&gt;

&lt;p&gt;상대와의 연결이 끊기면 소켓을 말소하게 됩니다. 이때 &lt;strong&gt;오작동을 막기 위해 바로 말소하지 않고 좀 기다린 후 말소&lt;/strong&gt;하게 됩니다. 오작동이 일어나는 한 가지 케이스를 살펴보겠습니다. 연결 끊기를 클라이언트에서 먼저 시작하면 마지막에 서버의 연결 끊기 통지에 대한 ACK 번호를 보낼 건데 이 마지막 ACK 번호가 잘 가지 않았다고 가정해보겠습니다. 그럼 서버에서는 다시 FIN 비트를 세팅해서 송신을 할 건데 이때 클라이언트 소켓이 말소되어있고, 직전에 다른 애플리케이션에 대해서 동일한 포트 번호로 소켓이 만들어진 상태면 그 애플리케이션의 소켓에 FIN이 도착하게 되어서 그 애플리케이션의 소켓이 바로 종료 동작을 수행하는 오작동을 일으키게 됩니다. 이런 이유로 소켓을 바로 말소시키지 않고 기다리는 것입니다. 이때 기다리는 시간은 패킷을 다시 보내는 동작이 지속되는 시간을 기준으로 판단합니다. 패킷을 다시 보내는 동작은 몇분 정도 계속되고 그 시간이 모두 경과하면 회복 불가로 판단하여 보내기 동작을 멈춥니다. 하지만 기존에 다시 보낸 패킷들이 네트워크에 존재할 가능성이 있기 때문에 다시 보내기 동작이 완전히 끝나는 시간만큼은 기다리는 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;프로토콜-스택의-ip는-패킷을-만들어서-상대에게-송신한다&quot;&gt;프로토콜 스택의 IP는 패킷을 만들어서 상대에게 송신한다&lt;/h3&gt;

&lt;p&gt;앞서 TCP가 실제로 패킷을 송신하기 위해서는 IP에 의뢰해야 한다는 것을 알게 됐습니다. 그럼 실제로 어떻게 패킷을 상대에게 송신하는지 살펴보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;패킷이란&quot;&gt;패킷이란&lt;/h4&gt;

&lt;p&gt;그 전에 패킷에 대해서 알아보겠습니다. 패킷은 실제로 네트워크를 통해서 주고받는 데이터 그 자체입니다. 패킷은 크게 &lt;strong&gt;헤더와 데이터(페이로드)로 구성&lt;/strong&gt;됩니다. 앞서 많이 살펴봤지만 헤더는 통신에 필요한 여러 제어 정보를 담고 있습니다. 이 헤더의 앞에는 하위 계층의 헤더가 계속 붙게 되는데 예를 들면 데이터에 TCP 헤더가 붙고나면 그 앞에는 IP 헤더, 그리고 그 앞에는 MAC 헤더가 붙게 됩니다. 이처럼 상위 계층 프로토콜에서 하위 계층 프로토콜 계층으로 내려오면서 헤더를 하나씩 붙이는 과정을 &lt;strong&gt;캡슐화&lt;/strong&gt;라고 합니다. 실제로 패킷은 상위 계층에서 하위 계층으로 내려오면서 캡슐화를 통해 완성됩니다.&lt;/p&gt;

&lt;p&gt;완성된 패킷은 중계장치(허브, 라우터..)에 송신됩니다. 각 중계장치들은 패킷의 목적지(수신처)가 어느 방향에 있는지에 대한 정보를 기록한 테이블을 가지고 있습니다. 그리고 중계장치는 자신의 계층에 해당하는 헤더까지 &lt;strong&gt;디캡슐화&lt;/strong&gt;를 하여 헤더에 기록된 수신처와 테이블의 데이터를 통해 어떤 케이블로 패킷을 전송할지 결정하게 됩니다. 예를 들면 L2장비인 허브는 2계층인 이더넷 프로토콜 헤더까지 디캡슐화를 하고 L3 장비인 라우터는 3계층인 IP 프로토콜 헤더까지 디캡슐화하여 제어정보를 취득하게 됩니다. 즉 허브는 MAC 헤더의 맥 주소를 보고 패킷을 서브넷 내에서 이동시키고, 라우터는 IP 헤더의 ip 주소를 보고 패킷을 다음 라우터로 전달합니다.&lt;/p&gt;

&lt;p&gt;이 동작을 좀 더 구체적으로 서술해보자면, 수신처 ip 주소를 확인해서 어느 방향에 있는지 조사하고 그 방향에 있는 다음 라우터를 조사하여 그 라우터의 맥 주소를 MAC 헤더의 수신처 맥 주소로 기록합니다. 그리고 그 라우터에 패킷을 보내도록 이더넷에 의뢰합니다. 패킷을 받은 이더넷은 허브로 패킷을 전송합니다. 패킷을 받은 허브는 앞서 말한 것처럼 MAC 헤더까지 디캡슐화를 해서 수신처 맥 주소(다음 라우터의 맥 주소)를 보고 자신이 관리하는 테이블에 기록된 정보와 결합하여 패킷의 다음 목적지를 중계합니다. 만약 서브넷 내의 허브가 여러 개라면 순차적으로 경유하여 라우터에 도착합니다. 라우터는 ip 헤더까지 디캡슐화를 하고 자신의 테이블 정보와 결합하여 중계해줄 다음 라우터를 결정합니다. 그럼 그 라우터의 맥 주소를 조사해서 그것을 다시 MAC 헤더의 수신처 맥 주소로 갱신해줍니다. 그럼 다시 허브를 타면서 다음 라우터에 도착하는 과정이 반복되고, 수신처까지 도착을 하게 됩니다.&lt;/p&gt;

&lt;p&gt;잘 살펴보면 &lt;strong&gt;이더넷 프로토콜(2계층)은 같은 네트워크 대역 내의 장비로 패킷을 전달하기 위한 역할&lt;/strong&gt;을 수행하고, &lt;strong&gt;ip 프로토콜(3계층)은 서로 다른 네트워크 대역으로 패킷을 전달하기 위한 역할&lt;/strong&gt;을 수행합니다.&lt;/p&gt;

&lt;h4 id=&quot;ip의-패킷-송수신-동작&quot;&gt;IP의 패킷 송수신 동작&lt;/h4&gt;

&lt;p&gt;이제 프로토콜 스택의 IP가 하는 일을 구체적으로 살펴보겠습니다. 먼저 TCP가 IP에게 패킷 송신을 의뢰하는 지점부터 시작해야겠군요. TCP는 TCP 헤더를 추가한 패킷을 IP에 전달합니다. 그리고 IP는 IP 헤더와 MAC 헤더를 순차적으로 붙이게 됩니다. IP의 역할은 이렇게 완성한 패킷을 LAN 어댑터로 전달하는 것이 끝입니다. 반대로 상대로부터 패킷을 받은 경우에는 LAN 어댑터가 IP에게 패킷을 건네주고 TCP 헤더와 데이터를 TCP에게 건내주게 됩니다.&lt;/p&gt;

&lt;p&gt;먼저 IP 헤더를 만드는 과정을 살펴보겠습니다. IP 헤더에는 수신처와 송신처의 IP 주소가 들어갑니다. 수신처 IP 주소는 애플리케이션이 접속동작을 TCP에 의뢰하면서 전달한 상대측 IP 주소를 TCP가 IP에 그대로 전달하는 것입니다. 그래서 그것이 잘못된 주소이더라도 IP주소는 그냥 그 주소로 세팅을 해서 보내게 됩니다. 이에 대한 잘못된 동작은 애플리케이션의 책임으로 간주합니다.
송신처 IP 주소는 LAN 어댑터에 할당된 IP 주소로 세팅하게 됩니다. 만약 LAN 어댑터가 여러 개 장착된 경우라면 어떤 어댑터의 IP로 설정할지를 판단해야 하는데, 그것은 어떤 라우터로 보내야할지를 통해 결정할 수 있습니다. 그 방법은 라우터에서 라우팅 테이블로 다음 라우터를 결정하는 것과 동일합니다. IP용 표를 라우팅 테이블이라고 하는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;route print&lt;/code&gt; 커멘드로 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;route print
Network Destination  Netmask           Gateway           Interface         Metric
0.0.0.0              0.0.0.0           125.129.69.254    125.129.69.101    20
125.129.69.0         255.255.255.0     125.129.69.101    125.129.69.101    20
125.129.69.101       255.255.255.255   127.0.0.1         127.0.0.1         20
125.255.255.255      255.255.255.255   125.129.69.101    125.129.69.101    20
127.0.0.0            255.0.0.0         127.0.0.1         127.0.0.1         1
224.0.0.0            240.0.0.0         125.129.69.101    125.129.69.101    20
255.255.255.255      255.255.255.255   125.129.69.101    125.129.69.101    1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Network Destination은 패킷의 최종 목적지로 수신처 IP를 이 행과 비교해서 대상 행을 찾습니다. Interface는 LAN 어댑터 등의 네트워크 인터페이스를 나타냅니다. ‘125.129.69.101’이 LAN 어댑터에 할당된 ip입니다. Gateway는 다음 중계 라우터 주소가 됩니다. 다음 라우터에서 패킷을 받으면 그 라우터는 마찬가지로 라우팅 테이블을 조회하여 다음으로 중계해줄 라우터를 찾게 됩니다. 만약 Interface와 Gateway가 같으면 이때는 라우터로 중계하지 않고 상대에게 직접 패킷을 전할 수 있음을 의미합니다. 예를 들어 Gateway, Interface가 ‘125.129.69.101’로 동일한 행의 목적지 주소인 ‘125.129.69.0’으로는 패킷을 바로 전달할 수 있음을 의미합니다. 최상단에는 목적지와 넷마스크가 ‘0.0.0.0’으로 등록되어있는데 이는 &lt;strong&gt;기본 게이트웨이&lt;/strong&gt;라고 합니다. 다른 행에 일치하는 항복이 없으면 이 행에 해당하는 것으로 간주합니다. 바로 이 테이블을 보고 &lt;strong&gt;어떤 LAN 어댑터에서 패킷을 내보낼지 결정하고 그 LAN 어댑터에 할당된 주소로 송신처 IP 주소를 결정&lt;/strong&gt;하게 됩니다.
IP 헤더에는 프로토콜 번호라는 필드에도 값을 설정합니다. 이 필드에는 상위 계층의 헤더가 어떤 프로토콜인지 지정합니다. 다르게 말하면 어디로부터 의뢰가 되었는지를 명시하는 것이기도 합니다. 예를 들어 TCP로부터 의뢰를 받았다면 06, UDP로부터 의뢰를 받았으면 17이 됩니다.&lt;/p&gt;

&lt;p&gt;이제 MAC 헤더를 만드는 과정을 살펴보겠습니다. MAC 헤더에는 송신측 LAN 어댑터의 MAC 주소와 수신측 MAC 주소를 담습니다. 그리고 IP 헤더와 마찬가지로 상위 계층의 프로토콜 타입을 이더 타입이라는 필드에 세팅합니다. 보통 이 이더 타입에는 IP(0800)나 ARP(0806) 프로토콜이 들어갑니다. 송신측 MAC 주소는 LAN 어댑터 내부의 ROM이라는 공간에 기록되어 있어서 여기서 읽어들이게 됩니다. 이미 IP 헤더를 작성하는 과정에서 어떤 LAN 어댑터로 패킷을 내보낼지 결정된 상태이기 때문에 그 어댑터에서 읽어들이면 됩니다. 그럼 수신측 MAC 주소는 어떻게 지정할 수 있을까요? 바로 ARP(Address Resolution Protocol)를 통해서 지정하게 됩니다. 이더넷에는 연결된 모든 노드에게 패킷을 전달하는 브로드캐스트라는 구조가 존재합니다. ARP 헤더는 송신측과 수신측의 IP, MAC 주소를 모두 담습니다. 이때 수신측의 IP주소는 다음 중계 라우터의 IP 주소(Gateway)를 입력하고 MAC주소는 알지 못하기 때문에 0으로만 채워둡니다. 그리고 MAC 헤더의 수신측 MAC 주소를 브로드캐스트(FF.FF.FF.FF.FF.FF)로 설정해서 패킷을 내보내면 패킷을 받은 모든 노드들은 MAC 헤더의 브로드캐스트 주소를 보고 모든 노드들에게 보낸 패킷이라는 것을 알고 패킷을 확인하게 됩니다. 그리고 ARP 헤더의 수신처 IP 주소를 확인해서 자신에게 온 패킷임을 확인했으면 ARP 헤더에 자신의 MAC 주소를 채워서 응답하게 됩니다. 그럼 비로소 수신측의 MAC 주소까지 알게 되어 MAC 헤더도 완성됩니다. 그런데 패킷을 보낼 때마다 ARP 동작을 수행하면 비효율적이기 때문에 한번 조회한 MAC 주소는 ARP 캐시라는 메모리에 보관합니다. 그래서 먼저 ARP 캐시에서 목적지 IP에 대한 MAC 주소가 있는지 확인하고 없는 경우에만 ARP 패킷을 전송합니다. 이때 ARP 캐시에 특정 노드의 MAC 주소를 저장했는데 이후 그 노드의 MAC 주소가 변경되어 캐시에 있는 MAC 주소가 유효하지 않은 문제가 발생할 수 있기 때문에 ARP 캐시에 저장된 값은 일정 시간이 경과하면 삭제하게 되어있습니다.
이렇게 완성된 패킷은 LAN 어댑터로 전달하게 됩니다. 여기까지가 프로토콜 스택의 IP의 역할입니다.&lt;/p&gt;

&lt;h3 id=&quot;lan-어댑터의-역할&quot;&gt;LAN 어댑터의 역할&lt;/h3&gt;

&lt;p&gt;LAN 어댑터는 IP로부터 받은 &lt;strong&gt;디지털 데이터인 패킷을 전기나 빛의 신호로 변환하여 네트워크 케이블로 송출&lt;/strong&gt;하는 역할을 수행합니다. LAN 어댑터는 LAN 어댑터 제조사에서 제공하는 LAN 드라이버 소프트웨어가 제어하게 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;lan-어댑터의-구성요소&quot;&gt;LAN 어댑터의 구성요소&lt;/h4&gt;

&lt;p&gt;LAN 어댑터의 동작을 살펴보기 전에 어떻게 구성되어있는지 먼저 살펴보겠습니다. LAN 어댑터에는 버퍼 메모리, MAC 회로, PHY(MAU) 회로, RJ-45 커넥터, ROM 등으로 구성되어 있습니다. LAN 어댑터는 전원이 공급되면 다른 하드웨어들처럼 초기화 작업이 필요합니다. 그 동작을 LAN 드라이버가 수행합니다. LAN 어댑터의 MAC 주소는 ROM에 저장됩니다. 여기서 MAC 주소를 읽어서 MAC 회로에 설정하게 됩니다. MAC 회로는 이더넷의 송/수신 동작을 제어합니다. 다른 구성요소들은 실제로 LAN 어댑터의 동작을 살펴보면서 더 보도록 하겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;ip로부터-전달받은-패킷에-3개의-제어용-데이터를-추가한다&quot;&gt;IP로부터 전달받은 패킷에 3개의 제어용 데이터를 추가한다&lt;/h4&gt;

&lt;p&gt;프로토콜 스택의 IP로부터 패킷을 받으면 우선 LAN 어댑터의 버퍼 메모리로 복사해둡니다. 그리고 MAC 회로에 패킷 송신 명령을 보내면 MAC 회로 버퍼 메모리에서 패킷을 읽어서 3개의 데어터를 붙이게 됩니다. 하나는 패킷의 맨 앞에 붙는 &lt;strong&gt;프리앰블&lt;/strong&gt;입니다. 프리앰블은 수신측이 계속해서 흐르는 전기 신호 속에서 송신측으로부터 받은 패킷을 읽기 시작할 타이밍을 잡게 할 수 있게 도움을 주기 위한 데이터 입니다. 프리앰블은 ‘10101010..’같이 1, 0이 번갈아 나타나는 56비트 데이터 입니다. 이 비트 패턴을 신호로 바꾸면 파형이 일정한 모습이 되고 수신측에서 이 일정한 파형을 통해 패킷을 읽을 준비를 해야함을 알게 됩니다. 다음은 프리앰블 바로 뒤에 오는 &lt;strong&gt;스타트 프레임 딜리미터&lt;/strong&gt;입니다. 이 데이터는 ‘101010….11’와 같이 1과 0이 반복되다가 마지막에 ‘11’로 끝이납니다. 수신측은 저 ‘11’로 끝나는 지점을 통해서 패킷의 시작점을 파악할 수 있게 됩니다. 즉 스타트 프레임 딜리미터는 패킷의 시작지점을 캐치할 수 있게 하기 위한 데이터가 됩니다. 나머지 하나는 패킷의 맨 뒤에 붙는 &lt;strong&gt;FCS&lt;/strong&gt;라는 데이터 입니다. 이 데이터는 패킷이 네트워크를 타고 전달되는 과정에서 잡음 등의 영향으로 파형이 흐트러져 데이터가 손상된 경우 검출을 하기 위해 사용합니다. 이 값은 패킷의 맨 앞부터 맨 끝까지의 내용을 어떤 계산식을 이용해서 도출한 32비트의 비트열입니다. 그래서 패킷 데이터의 값이 1비트라도 변하면 계산한 결과도 달라진 값이 됩니다. 수신측은 전달받은 패킷을 계산식을 토대로 계산한 결과와 FCS의 값과 비교를 해서 데이터 손상 여부를 파악합니다.&lt;/p&gt;

&lt;h4 id=&quot;허브를-향해서-패킷을-송신한다&quot;&gt;허브를 향해서 패킷을 송신한다&lt;/h4&gt;

&lt;p&gt;앞서 언급한 3개의 데이터를 패킷에 부가했으면 이제 패킷을 허브로 송신하게 됩니다. 이때 리피터 허브일 때는 반이중 모드, 스위칭 허브일 때는 전이중 모드로 동작하는데 먼저 반이중 모드부터 살펴보겠습니다.
반이중 모드는 동시에 송신과 수신을 할 수 없습니다. LAN 어댑터의 PHY(MAU)는 케이블에 다른 기기가 송신한 신호가 흐르고 있는지 확인하고 신호가 흐르고 있으면 끝날 때까지 기다립니다. 만약 송신하고 있는 신호가 있는데 송신동작을 시작하면 충돌이 발생합니다. 그리고 신호가 흐르고 있지 않으면 송신 동작을 시작합니다. 송신 동작은 먼저 &lt;strong&gt;MAC 회로가 프리앰블의 맨 앞부터 1비트씩 차례로 디지털 데이터를 신호로 변환하고 PHY 혹은 MAU라는 송/수신 신호 부분에 보냅니다.&lt;/strong&gt; 이때 디지털 데이터를 신호로 변환하는 속도가 전송 속도가 됩니다. 1초에 10메가비트 분량의 디지털 데이터를 신호로 변환하여 보내면 10메가비트/초 전송률이 됩니다. 그럼 &lt;strong&gt;PHY는 다시 이 신호를 실제 케이블에 송출하는 형식으로 변환해서 송신&lt;/strong&gt;을 합니다. MAC에서 한번, PHY에서 한번 신호를 변환하는 절차를 2번으로 나눈 이유는 PHY는 여러 신호 형식의 종류에 구애받지 않고 공통 형식의 신호로만 변환해서 송신을 할 수 있게 하기 위함입니다. 이렇게 PHY가 송신을 완료할 때까지 수신 신호선에 신호가 들어오지 않으면 송신 동작은 끝납니다. 그런데 신호를 송신하는데 적은 확률로 복수의 기기가 송신 동작에 들어가서 수신 신호가 흘러들어오는 경우가 있습니다. 이렇게 신호가 충돌하게 되면 송신을 계속 해도 의미가 없기 때문에 송신 중단을 하고 충돌 사실을 다른 기기에 통지하기 위해 &lt;strong&gt;재밍 신호&lt;/strong&gt;라는 특수한 신호를 잠시 흘리고 일정 시간 대기했다가 다시 송신 동작을 수행합니다. 이때 모든 기기의 대기 시간이 동일하면 다시 출돌이 일어나기 때문에 대기 시간은 기기들의 MAC 주소를 바탕으로 난수를 생성해서 계산하도록 고안되어 있습니다. 그런데도 이더넷의 혼잡으로 다시 충돌이 발생하면 대기 시간을 2배로 늘리고 다시 보내게 됩니다. 그렇게 열번까지 재시도가 일어나게 되었는데도 해결이 안 되면 오류로 판단합니다.
전이중 모드는 송신과 수신의 충돌이 일어나지 않기 때문에 반이중모드처럼 충돌에 대한 고민을 할 필요가 없습니다. 리피터, 스위칭 허브에 대한 내용은 3장에서 더 자세하게 살펴봅니다.&lt;/p&gt;

&lt;h4 id=&quot;lan-어댑터의-패킷-수신&quot;&gt;LAN 어댑터의 패킷 수신&lt;/h4&gt;

&lt;p&gt;패킷의 수신은 앞서 살펴본 송신과 반대로 일어난다고 이해하면 됩니다. 리피터 허브의 반이중 동작을 기준으로 살펴보겠습니다. 앞서 살펴봤듯이 이더넷에서는 1대가 송신을 하면 같은 허브에 접속된 모든 케이블로 신호가 흘러갑니다. 이렇게 신호를 받은 기기들은 패킷의 맨 앞에 붙은 프리앰블을 통해 파형을 계산하고 스타트 프레임 딜리미터가 나오면 그 다음 비트부터 PHY 회로에서 신호를 공통 형식 신호로 변환해서 MAC 회로로 보내고, MAC 회로에서 신호를 차례로 디지털 데이터로 변환합니다. 그리고 신호의 마지막에 다다르면 FCS를 검사합니다. 여기까지 통과하면 MAC 헤더의 수신처 MAC 주소를 조사해서 MAC 회로에 설정된 주소와 비교해서 자신에게 온 것인지 확인합니다. 이때 자신에게 온 것이 아니면 패킷을 폐기하고, 자신에게 온 것이면 버퍼 메모리에 저장합니다. MAC 회로가 일을 끝마치면 패킷 수신 사실을 컴퓨터 본체에 통지합니다.
통지는 인터럽트를 통해서 하게 됩니다. LAN 어댑터는 확장 버스 슬롯에 있는 인터럽트용 신호선에 신호를 보냅니다. 이 신호선은 컴퓨터 본체의 인터럽트 컨트롤러를 통해 CPU에 연결되어 있고, 신호를 받으면 CPU는 하던 작업을 보류하고 OS 내부의 인터럽트 처리용 프로그램으로 전환합니다. 여기서 LAN 드라이버가 호출되어서 LAN 어댑터를 제어하면서 송/수신 동작을 실행합니다.
LAN 어댑터의 버퍼 메모리에서 수신 패킷을 추출하면 LAN 드라이버는 MAC 헤더의 타입 필드 값을 통해서 상위 계층 프로토콜을 판별합니다. 그리고 프로토콜 스택의 해당 프로토콜 담당 부분에 패킷을 전달해줍니다.(보통 IP, TCP)&lt;/p&gt;

&lt;h3 id=&quot;프로토콜-스택-tcpip의-수신-동작&quot;&gt;프로토콜 스택 TCP/IP의 수신 동작&lt;/h3&gt;

&lt;p&gt;LAN 어댑터에게 건네받은 패킷을 프로토콜 스택의 IP, TCP가 어떻게 처리하는지 정리해보겠습니다. IP담당은 IP 헤더의 포맷에 문제가 없는지 확인하고, 수신처 IP 주소를 확인합니다. 만약 현재 기기가 라우터 같은 중계 장비가 아닌 클라이언트(엔드 노드)인 경우라면 수신처 IP가 자신의 IP와 다르다면 오류로 간주합니다. 클라이언트가 패킷 중계를 할 일은 없기 때문입니다. 그래서 이럴 때는 &lt;strong&gt;ICMP&lt;/strong&gt;를 통해 상대에게 오류 통지를 하게 됩니다. 다양한 오류 케이스를 통지할 수 있는데 이 경우에는 Destination unreachable 메시지를 통지합니다. IP 주소까지 올바르면 IP 담당은 &lt;strong&gt;조각화된 패킷을 원래의 모습으로 합치는 리어셈블링 작업&lt;/strong&gt;을 수행합니다. 리어셈블링에 필요한 정보는 ip 프로토콜 헤더에 기록되어있습니다. 플래그, ID 정보, 프래그먼트 오프셋이 바로 그 정보들인데, 플래그는 이 패킷이 조각화된 패킷인지 아닌지를 판별할 수 있는 정보입니다. 만약 이 패킷이 조각화된 패킷이면 IP 담당 내부의 메모리에 일시적으로 보관하게 됩니다. 그리고 ID 정보를 통해 조각화된 패킷들이 한몸임을 식별할 수 있습니다. 한몸이 되어야 하는 패킷들은 동일한 ID 정보를 가집니다. 그리고 이 패킷들이 어떤 순서로 합쳐져야 하는지에 대한 정보는 프래그먼트 오프셋이라는 항목으로 알 수 있습니다. 여기까지 수행하면 이제 패킷을 TCP 담당에 전달합니다.
TCP 담당은 IP 헤더의 수신처, 송신처 IP 주소와 TCP 담헤더의 수신처, 송신처 포트 번호를 조사해서 해당하는 소켓을 찾습니다. 소켓에는 현재 통신의 진행 상태가 기록되어 있기 때문에 적절한 동작을 수행하면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;udp-프로토콜의-송수신-동작&quot;&gt;UDP 프로토콜의 송/수신 동작&lt;/h3&gt;

&lt;p&gt;UDP 프로토콜은 TCP 프로토콜처럼 신뢰성을 보장하지 않아도 될 경우 사용하면 효율적입니다. TCP와 달리 패킷이 잘 도착했는지 확인하고 도착하지 않았으면 패킷을 다시 보내는 동작을 하지 않기 때문입니다. UDP는 TCP처럼 수신 확인, 윈도우 같은 것이 없기 때문에 송, 수신 전에 제어 정보를 주고 받을 필요가 없고, 접속, 연결 끊기 단계도 없습니다. 애플리케이션으로부터 데이터를 받으면 그냥 UDP 헤더를 붙이고 IP에 의뢰하고 바로 송신합니다. 수신도 IP 헤더의 수신처, 송신처의 IP 주소와, TCP 헤더의 수신처, 송신처의 포트 번호로 소켓을 찾아서 애플리케이션에게 데이터를 건네주고 끝입니다. 오류가 발생해도 UDP는 신경쓰지 않습니다. UDP는 DNS 서버에 IP 주소를 조회할 때나, 음성 및 동영상 데이터의 송수신에 사용됩니다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><category term="CS" /><summary type="html">Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘2장 TCP/IP의 데이터를 전기 신호로 만들어 보낸다’를 정리했습니다.</summary></entry><entry><title type="html">성공과 실패를 결정하는 1%의 네트워크 원리 1장</title><link href="https://anstn1993.github.io/2022/01/18/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-1%EC%9E%A5.html" rel="alternate" type="text/html" title="성공과 실패를 결정하는 1%의 네트워크 원리 1장" /><published>2022-01-18T00:00:00+09:00</published><updated>2022-01-18T00:00:00+09:00</updated><id>https://anstn1993.github.io/2022/01/18/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1%25%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-1%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2022/01/18/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-1%EC%9E%A5.html">&lt;p&gt;Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘1장 웹 브라우저가 메시지를 만든다’를 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;1장-웹-브라우저가-메시지를-만든다&quot;&gt;1장. 웹 브라우저가 메시지를 만든다.&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;1장에서는 웹 브라우저가 url을 입력해서 요청할 때 메시지가 만들어져서 바깥으로 나가는 순간까지를 추적합니다.&lt;/p&gt;

&lt;h3 id=&quot;dns가-ip주소를-찾는다&quot;&gt;DNS가 ip주소를 찾는다&lt;/h3&gt;

&lt;h4 id=&quot;ip-주소란&quot;&gt;ip 주소란?&lt;/h4&gt;

&lt;p&gt;ip 주소는 네트워크의 대역을 식별하는 &lt;strong&gt;네트워크 번호&lt;/strong&gt;와 그 대역 안에서 하나의 컴퓨터(노드)를 식별하는 &lt;strong&gt;호스트 번호&lt;/strong&gt;의 조합으로 이루어진 32비트 데이터 입니다. 이때 ip주소 값에서 어디까지가 네트워크 번호이고 어디까지가 호스트 번호인지 그 경계를 구분해주는 역할을 하는 것이 &lt;strong&gt;서브넷 마스크&lt;/strong&gt; 입니다. 서브넷은 작은 네틔워크 대역 하나를 의미하고, 이 대역 안에서의 장비들은 &lt;strong&gt;허브&lt;/strong&gt;로 연결됩니다. 그리고 이 서브넷들은 &lt;strong&gt;라우터&lt;/strong&gt;를 통해 서 연결되는데, 결국 전체 네트워크는 수많은 서브넷들이 연결된 형태라고 생각하면 됩니다. ip 주소는 결국 두 노드가 통신할 때 각 노드가 많은 서브넷들 중에서 어떤 서브넷의 어떤 장비인지를 식별하기 위한 값이라고 볼 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;dns란-무엇인가&quot;&gt;DNS란 무엇인가&lt;/h4&gt;

&lt;p&gt;브라우저에서 실제로 통신을 할 대상을 지정할 때 ip주소를 입력해도 되지만 대부분의 경우에는 도메인 주소를 입력하게 됩니다. ip주소가 아님에도 불구하고 원하는 대상과 통신을 할 수 있는 이유는 DNS(Domain Name System)에게 적절한 ip를 받을 수 있기 때문입니다. DNS 서버는 도메인 주소와 그에 대응되는 ip주소를 저장하고 있는 서버 입니다. 브라우저에서 도메인을 입력해서 요청을 하는 순간 DNS 서버에 도메인 주소를 전달하면서 그에 대응되는 ip주소를 돌려달라고 요청을 먼저 하게 되고 그렇게 전달 받은 ip 주소를 이용해서 실제 네트워크 통신이 시작됩니다.&lt;/p&gt;

&lt;h4 id=&quot;dns-서버에-요청을-보내는-건-소켓-라이브러리의-dns-리졸버다&quot;&gt;DNS 서버에 요청을 보내는 건 소켓 라이브러리의 DNS 리졸버다&lt;/h4&gt;

&lt;p&gt;DNS 서버에 ip 주소를 찾기 위한 요청은 &lt;strong&gt;DNS 리졸버&lt;/strong&gt;가 보내게 됩니다. DNS 서버를 통해서 ip 주소를 조사하는 것을 name resolution(이름 확인)이라고 하는데, 이를 실행하는 것이 DNS 리졸버 입니다.
리졸버는 소켓 라이브러리에 포함된 루틴(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gethostbyname(&amp;lt;domain name&amp;gt;)&lt;/code&gt;) 입니다. 소켓 라이브러리는 애플리케이션 레벨에서 네트워크 통신에 필요한 동작을 OS에 의뢰하기 위한 많은 루틴들을 포함하고 있습니다. 리졸버도 애플리케이션에서 OS에 작업 의뢰를 하기 위한 많은 인터페이스들 중 하나라고 이해하면 되겠습니다.&lt;/p&gt;

&lt;p&gt;애플리케이션에서 name resolution을 하기 위해서 소켓 라이브러리의 리졸버를 호출하면 다음과 같은 동작이 발생합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;DNS 서버에 보낼 요청 메시지를 만든다.&lt;/li&gt;
  &lt;li&gt;프로토콜 스택에 의뢰하여 DNS 서버에 전송한다.&lt;/li&gt;
  &lt;li&gt;프로토콜 스택이 DNS에서 돌아온 응답 메시지를 수신하면 리졸버에게 반환한다.&lt;/li&gt;
  &lt;li&gt;리졸버는 응답 메시지에서 ip 주소를 추출해서 애플리케이션에게 반환하고 애플리케이션은 그 ip 주소를 자신이 관리하는 변수에 저장한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;프로토콜 스택&lt;/strong&gt;은 DNS 서버와의 통신뿐만 아니라 모든 네트워크 통신에 필요한 동작을 담당하는 OS에 포함되어있는 프로그램입니다. 프로토콜 스택이 실제로 어떻게 동작하는지는 뒤에서 살펴보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;ip주소는-여러-dns가-연대해서-찾는다&quot;&gt;ip주소는 여러 DNS가 연대해서 찾는다&lt;/h3&gt;

&lt;h4 id=&quot;dns-서버가-ip를-찾는-과정&quot;&gt;DNS 서버가 ip를 찾는 과정&lt;/h4&gt;

&lt;p&gt;앞에서 클라이언트가 도메인 주소를 통해서 ip 주소를 찾기 위해서 DNS 서버에 요청을 보내는 과정을 살펴봤으면 이제 요청을 받은 DNS 서버가 실제로 ip를 어떻게 찾는지 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;클라이언트로부터 받은 조회 메시지에는 다음의 3가지 정보가 포함되어있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이름: 서버나 메일 배송 목적지(메일 주소에서 @ 뒷부분)와 같은 이름&lt;/li&gt;
  &lt;li&gt;클래스: DNS의 구조를 고안했을 때 인터넷 이외의 네트워크에서의 동작까지 고려해서 만든 네트워크 식별을 위한 값으로, 지금은 인터넷 이외의 네트워크는 소멸했기에 클래스는 항상 인터넷을 의미하는 ‘IN’이 사용됨&lt;/li&gt;
  &lt;li&gt;타입: 이름에 어떤 타입의 정보가 지원되는지를 표시한 것으로 ‘A’면 이름에 ip 주소가 지원됨을, ‘MX(Mail eXcahnge)’이면 이름에 메일 목적지가 지원됨을 나타냄&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DNS 서버는 위의 3가지 정보에 대응하는 ip주소나 메일의 배송 목적지를 설정 파일에 기록해두었습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;이름&lt;/th&gt;
      &lt;th&gt;클래스&lt;/th&gt;
      &lt;th&gt;타입&lt;/th&gt;
      &lt;th&gt;클라이언트에 회답하는 항목&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;www.lab.cyber.co.kr&lt;/td&gt;
      &lt;td&gt;IN&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;192.0.2.226&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cyber.co.kr&lt;/td&gt;
      &lt;td&gt;IN&lt;/td&gt;
      &lt;td&gt;MX&lt;/td&gt;
      &lt;td&gt;10 mail.cyber.co.kr&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mail.cyber.co.kr&lt;/td&gt;
      &lt;td&gt;IN&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;192.0,2.227&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위의 표가 DNS 서버가 관리하는 설정 파일에 들어있는 데이터 예시입니다. DNS 서버는 요청 메시지에 기재된 3가지 정보를 통해서 표에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;클라이언트에 회답하는 항목&lt;/code&gt;을 찾아서 응답하게 됩니다. 예를 들어 ‘www.lab.cyber.co.kr’의 ip주소를 조사하고 싶다면 클라이언트는 DNS 서버에 다음과 같은 정보를 포함해서 메시지를 보내는 겁니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이름: www.lab.cyber.co.kr&lt;/li&gt;
  &lt;li&gt;클래스: IN&lt;/li&gt;
  &lt;li&gt;타입: A&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그럼 DNS 서버는 192.0.2.226을 클라이언트에 응답해주게 됩니다. 그럼 메일 배송 목적지를 조회할 때 사용하는 MX에 대해서도 살펴보겠습니다. 예를 들면 ‘tone@cyber.co.kr’이라는 메일 주소가 있을 때 목적지 메일 서버의 이름은 @ 뒤에 있는 이름이 됩니다. 그럼 조회 메시지는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이름: cyber.co.kr&lt;/li&gt;
  &lt;li&gt;클래스: IN&lt;/li&gt;
  &lt;li&gt;타입: MX&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 표를 기준으로 DNS 서버는 ‘10’과 ‘mail.cyber.co.kr’이라는 두 값을 담아서 응답합니다. 여기서 숫자는 메일 서버의 우선순위를 의미합니다. 메일의 전송 목적지로 복수의 메일 서버가 등록되어있으면 어느 메일 서버를 우선 선택할지 판단하기 위한 값으로, 값이 작을수록 우선순위가 높습니다.
그런데 잘 보면 여기서 끝이 아닙니다. 어떠한 경우가 되었든 네트워크 통신은 ip를 통해서 이루어지기 때문에 저 전송 목적지의 ip주소를 찾아서 함께 담아서 응답하게 됩니다. 위의 표에서는 ‘192.0.2.227’이 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;dns-서버들은-도메인-주소를-기반으로-계층화되어있다&quot;&gt;DNS 서버’들’은 도메인 주소를 기반으로 계층화되어있다&lt;/h4&gt;

&lt;p&gt;사실 앞에서는 DNS 서버가 한대인 것을 가정해서 설명했습니다. 하지만 현실에는 엄청난 수의 서버가 있기에 1대의 DNS 서버만으로 운용하는 것은 불가능합니다. 그래서 실제로는 여러 대의 DNS 서버가 요청을 주고받으면서 최종적인 ip 주소를 찾게 됩니다. 하지만 각각의 DNS 서버가 응답할 값을 찾는 과정은 위에서 설명한 것과 동일하기 때문에 결국 DNS 서버들이 어떤 &lt;strong&gt;구조&lt;/strong&gt; 속에서 통신하는지만 이해하면 됩니다.&lt;/p&gt;

&lt;p&gt;DNS 서버들의 구조를 이해하려면 먼저 &lt;strong&gt;도메인의 계층&lt;/strong&gt;에 대해서 이해해야 합니다. 도메인 주소는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.&lt;/code&gt;으로 구분되는데, 이 점이 계층을 구분합니다. 오른쪽 끝이 최상위, 왼쪽 끝이 최 하위 계층이 됩니다. ‘www.lab.cyber.com’을 예로 들면, ‘com’이 최상위 계층이 되고, ‘www’는 최하위 계층이 됩니다. 회사의 조직으로 비유해보면, ‘com 사업부 cyber 부 lab과의 www씨’ 정도가 됩니다. 그리고 저 각각의 계층화된 주체가 바로 &lt;strong&gt;도메인&lt;/strong&gt;입니다. 결국 도메인 주소는 com, cyber, lab, www와 같은 도메인들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.&lt;/code&gt;으로 계층화한 값이라고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;다시 DNS 서버로 돌아와보면 DNS 서버들은 계층화된 도메인들을 하나씩 맡아서 저장하게 됩니다. 이때 &lt;strong&gt;하위의 도메인을 담당하는 DNS 서버의 주소를 그 상위의 DNS 서버에 등록합니다.&lt;/strong&gt; 예를 들면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lab.glasscom.com&lt;/code&gt;이라는 도메인을 담당하는 DNS 서버를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;glasscom.com&lt;/code&gt;의 DNS 서버에 등록하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;glasscom.com&lt;/code&gt;의 DNS 서버를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;com&lt;/code&gt; 도메인의 DNS 서버에 등록하는 식입니다. 그럼 상위의 DNS 서버에서 하위 DNS 서버의 ip 주소를 알 수 있고, 그 서버에 조회 메시지를 보내서 다시 그 하위 DNS 서버의 ip주소를 받음으로써 실제 타겟 서버의 ip주소를 조회할 때까지 계층적으로 타고 내려갈 수 있게 됩니다. 결국 &lt;strong&gt;DNS 서버는 도메인 주소와 같은 계층화된 구조를 가지는 것&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h4 id=&quot;세상의-모든-dns-서버는-root-도메인의-dns-서버-주소를-알아야-한다&quot;&gt;세상의 모든 DNS 서버는 root 도메인의 DNS 서버 주소를 알아야 한다&lt;/h4&gt;

&lt;p&gt;그럼 DNS 서버가 실제로 ip 주소를 찾는 과정을 좀 더 구체적으로 살펴보기에 앞서 DNS 서버들이 갖추어야 할 준비사항을 살펴보겠습니다. 우리가 살펴봤던 ‘lab.glasscom.com’에서 ‘com’이 최상위 계층이지만 사실 그 위에는 &lt;strong&gt;root 도메인&lt;/strong&gt;이 존재합니다. 이 도메인이 진짜 최상위 도메인이고 이 루트 도메인의 DNS 서버에 ‘com’, ‘kr’같은 도메인의 DNS 서버를 등록하게 됩니다. ip 조회 작업은 항상 root 도메인의 DNS 서버에서부터 시작하고 그 하위 DNS 서버로 타고 내려가면서 진행됩니다. 항상 root 도메인에서부터 조회가 시작되어야하기 때문에 &lt;strong&gt;세상에 존재하는 모든 DNS 서버는 root 도메인의 DNS 서버를 등록한 상태&lt;/strong&gt;입니다. 그래야 어떤 지역의 DNS서버로 요청을 보내도 그 요청을 다시 root 도메인의 DNS 서버로 보낼 수 있기 때문입니다.&lt;/p&gt;

&lt;h4 id=&quot;dns-서버가-ip를-찾는-실제-과정&quot;&gt;DNS 서버가 ip를 찾는 실제 과정&lt;/h4&gt;

&lt;p&gt;이제 모든 준비가 끝났습니다. 클라이언트가 ‘www.lab.glasscom.com’이라는 웹 서버에 관한 정보를 조회하기 위해서 클라이언트 pc에 설정된 DNS 서버로 조회 요청을 보내면 다음과 같은 일들이 벌어집니다. 편의상 클라이언트에게 최초 요청을 받은, 즉 클라이언트에게 ip를 찾아서 응답해줄 의무를 가지는 DNS 서버를 ‘A 서버’라고 칭하도록 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;최초 요청을 받은 A 서버에는 ‘www.lab.glasscom.com’이라는 이름이 등록되어 있지 않기에 root 도메인의 DNS 서버에 클라이언트로부터 받은 메시지를 전송&lt;/li&gt;
  &lt;li&gt;root 도메인의 DNS 서버는 마지막 도메인이 ‘com’인 것을 확인하고 ‘com’ 도메인의 DNS 서버의 ip 주소를 A 서버에 응답&lt;/li&gt;
  &lt;li&gt;A 서버는 응답받은 ip를 이용하여 ‘com’ 도메인이 있는 DNS 서버에 조회 요청&lt;/li&gt;
  &lt;li&gt;‘com’ 도메인의 DNS 서버에도 ‘www.lab.glasscom.com’는 등록되어있지 않기 때문에 ‘com’의 아래에 있는 ‘glasscom.com’ 도메인의 DNS 서버의 ip 주소를 A 서버에 응답&lt;/li&gt;
  &lt;li&gt;A 서버는 응답받은 ip를 이용하여 ‘glasscom.com’ 도메인의 DNS 서버에 조회 요청&lt;/li&gt;
  &lt;li&gt;‘glasscom.com’ 도메인의 DNS 서버에도 ‘www.lab.glasscom.com’는 등록되어있지 않기 때문에 ‘glasscom.com’의 아래에 있는 ‘lab.glasscom.com’ 도메인의 DNS 서버의 ip 주소를 A 서버에 응답&lt;/li&gt;
  &lt;li&gt;A 서버는 응답받은 ip를 이용하여 ‘lab.glasscom.com’ 도메인이 있는 DNS 서버에 조회 요청&lt;/li&gt;
  &lt;li&gt;‘lab.glasscom.com’ 도메인의 DNS 서버에는 ‘www.lab.glasscom.com’의 ip 주소가 있기 때문에 여기서 ip 주소를 응답받으면 A 서버는 클라이언트에 해당 ip 주소를 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이처럼 하나의 도메인 이름에 대응되는 ip를 찾으려면 여러 개의 DNS 서버에 요청을 보내야 합니다. 그런데 지금까지 살펴본 DNS 서버의 탐험은 DNS 서버 하나에 도메인 하나를 저장한 경우를 가정했지만, 현실에서는 한 대의 DNS 서버에 복수의 도메인 정보를 가질 수도 있습니다. 즉 상위와 하위 도메인을 같은 DNS 서버에 등록할 수도 있는데, 이 경우에 상위 DNS 서버에 조회를 하면 하위 DNS 서버를 하나 건너뛰고 그 아래의 DNS 서버에 관한 정보가 돌아옵니다.&lt;/p&gt;

&lt;h4 id=&quot;dns-서버는-캐싱을-통해-응답-속도를-높일-수-있다&quot;&gt;DNS 서버는 캐싱을 통해 응답 속도를 높일 수 있다&lt;/h4&gt;

&lt;p&gt;앞선 DNS 서버의 ip 조회 과정에서 꽤나 많은 요청과 응답이 필요하다는 것을 알게 됐습니다. 다소 비효율적인 것처럼 보이는데, 여기에 한 번 조사한 이름을 캐시에 기록하여 root 도메인의 DNS 서버부터 최하위 도메인의 DNS서버까지 요청을 보내지 않고 바로 응답을 내려줄 수 있습니다. 이렇게 하면 캐시 미스가 나는 경우에 한해서만 앞서 살펴본 과정을 거쳐서 ip를 획득하면 됩니다.&lt;/p&gt;

&lt;p&gt;하지만 캐싱을 적용할 때는 DNS 서버의 정보와 캐시에 저장된 정보의 동기화에 주의해야 합니다. 캐시에 정보를 저장한 후에 DNS 서버의 등록 정보가 변경되면, 캐시에 저장된 정보는 더 이상 유효하다고 할 수 없기 때문입니다. 그래서 DNS 서버에 등록하는 정보에는 유효기간을 설정하고, 캐시에 저장한 데이터의 유효기간이 지나면 캐시에서 삭제하게 됩니다. 그리고 조회에 응답할 때 정보가 캐싱된 정보인지, 등록처 DNS 서버에서 직접 응답을 받은 것인지 알려주게 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;os의-프로토콜-스택에-메시지-송신을-의뢰한다&quot;&gt;OS의 프로토콜 스택에 메시지 송신을 의뢰한다&lt;/h3&gt;

&lt;p&gt;ip 주소까지 구했으면 이제 통신 대상 서버에 메시지를 송신하도록 OS의 &lt;strong&gt;프로토콜 스택&lt;/strong&gt;에 의뢰하게 됩니다. 이 과정에서도 소켓 라이브러리의 루틴들을 호출하게 됩니다. 메시지를 송신하는 일련의 절차들을 알아보면서 각 절차들에서 호출되어야 하는 루틴들을 함께 살펴보겠습니다. 앞서 DNS 리졸버에서도 살펴봤지만 소켓 라이브러리는 애플리케이션이 OS의 프로토콜 스택에 필요한 동작을 의뢰하는 인터페이스 역할을 담당합니다. 소켓 라이브러리 자체가 통신에 필요한 직접적인 동작을 하지 않는다는 것을 명심하세요.&lt;/p&gt;

&lt;h4 id=&quot;소켓의-작성-단계&quot;&gt;소켓의 작성 단계&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gethostbyname&lt;/code&gt;을 호출하고나면 다음으로는 소켓 생성을 위해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket(&amp;lt;IPv4 사용&amp;gt;, &amp;lt;스트림형&amp;gt;, ...)&lt;/code&gt;을 호출하게 됩니다. 여기서 ‘소켓’은 ‘소켓 라이브러리’에서의 소켓과는 조금 다른 의미로 쓰였는데요. 여기서는 간단하게 ‘통신의 출입구’ 정도로 이해하면 됩니다. 자세한 의미는 2장에서 살펴봅니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket()&lt;/code&gt;을 호출해서 소켓을 생성하면 &lt;strong&gt;디스크립터&lt;/strong&gt;가 반환됩니다. 디스크립터는 소켓을 식별하기 위한 식별값입니다. 컴퓨터는 동시다발적으로 여러 서버와 통신하는 일이 비일비재하기 때문에 복수의 소켓이 동일한 시점에 존재할 가능성이 높습니다. 이런 상황에서 프로토콜 스택이 각각의 소켓을 식별할 필요가 있기 때문에 디스크립터를 쓰는 것입니다. 이 디스크립터는 애플리케이션의 메모리에 저장한 후 이후 루틴의 인자로 전달됩니다.&lt;/p&gt;

&lt;h4 id=&quot;두-노드-간의-파이프를-연결하는-접속-단계&quot;&gt;두 노드 간의 파이프를 연결하는 접속 단계&lt;/h4&gt;

&lt;p&gt;소켓을 만들었으면 그 소켓을 서버측의 소켓에 접속하도록 프로토콜 스택에 의뢰합니다. 이때 사용하는 루틴은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect(&amp;lt;디스크립터&amp;gt;, &amp;lt;서버의 ip 주소와 포트 번호&amp;gt;)&lt;/code&gt;입니다. 앞서 소켓 생성의 결과로 반환받은 디스크립터를 인자로 전달하여 어떤 소켓으로 서버 소켓에 연결해야하는지 찾습니다. ip 주소와 포트 번호도 인자로 전달하는데, ip 주소로는 통신 대상 노드를 찾고, 포트 번호로 그 노드의 연결할 소켓을 찾게 됩니다. 이때 소켓을 찾는다는 말은 결국 애플리케이션을 찾는다는 말과 같기 때문에 포트 번호를 통해서 통신 노드 내에서 어떤 애플리케이션과 연결을 할지를 결정한다고 봐도 좋습니다.&lt;/p&gt;

&lt;p&gt;그럼 서버도 클라이언트의 어떤 소켓과 통신해야할지 알아야 하기 때문에 클라이언트의 포터번호가 필요할 것입니다. 클라이언트 소켓의 포트 번호는 소켓을 생성할 당시에 프로토콜 스택이 적당한 값을 골라서 할당하게 됩니다. 그리고 접속 동작 시에 서버측에 통지해줍니다. 자세한 과정은 2장에서 설명합니다.&lt;/p&gt;

&lt;p&gt;이렇게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect()&lt;/code&gt;를 호출해서 프로토콜 스택이 접속 동작을 실행하고 상대와 연결되면 프로토콜 스택은 연결된 상대의 ip 주소나 포트 번호 등의 정보를 소켓에 기록합니다. 이제 데이터의 송/수신이 가능한 상태가 됐습니다.&lt;/p&gt;

&lt;h4 id=&quot;메시지를-주고-받는-송수신-단계&quot;&gt;메시지를 주고 받는 송/수신 단계&lt;/h4&gt;

&lt;p&gt;양쪽 소켓이 연결되었으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write(&amp;lt;디스크립터&amp;gt;, &amp;lt;송신 데이터&amp;gt;, &amp;lt;송신 데이터 길이&amp;gt;)&lt;/code&gt; 루틴을 호출해서 프로토콜 스택이 송신 데이터를 서버에게 송신하게 합니다. 이미 소켓에는 통신 상대 소켓에 대한 정보가 기록되어 있기 때문에 바로 전송을 할 수 있습니다. 서버는 수신 동작을 통해 받은 데이터에 대한 적절한 처리를 하고 응답 메시지를 반송합니다. 그럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read(&amp;lt;디스크립터&amp;gt;, &amp;lt;수신 버퍼&amp;gt;, ...)&lt;/code&gt;라는 루틴을 통해서 프로토콜 스택에 수신 동작을 의뢰할 수 있습니다. 수신한 응답 메시지는 &lt;strong&gt;수신 버퍼&lt;/strong&gt;라는 메모리 영역에 저장합니다. 이 버퍼는 애플리케이션에 할당된 메모리 공간이기 때문에 애플리케이션이 접근해서 읽게 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;송수신을-종료하는-연결-끊기-단계&quot;&gt;송/수신을 종료하는 연결 끊기 단계&lt;/h4&gt;

&lt;p&gt;통신이 모두 끝나면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close(&amp;lt;디스크립터&amp;gt;)&lt;/code&gt; 루틴을 호출해서 프로토콜 스택이 연결 끊기 동작을 수행하게 합니다. 일반적으로 HTTP1.0에서는 서버쪽에서 먼저 연결 끊기 동작을 실행합니다.(HTTP 1.1 버전에서는 요청할 데이터가 없어진 상태가 되면 브라우저에서 연결 끊기를 먼저 들어갈 수도 있습니다.) 이때 끊기 동작이 수행되었다는 것을 클라이언트에 전달하게 되는데, 그럼 클라이언트 애플리케이션도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; 루틴으로 그 사실을 전달받고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt;를 호출해서 연결 끊기 단계에 들어갑니다. 디스크립터를 인자로 전달하는 것은 여러 소켓 중에 말소시킬 소켓을 찾아야하기 때문입니다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><category term="CS" /><summary type="html">Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘1장 웹 브라우저가 메시지를 만든다’를 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 8장</title><link href="https://anstn1993.github.io/2021/12/22/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-8%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 8장" /><published>2021-12-22T00:00:00+09:00</published><updated>2021-12-22T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/12/22/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-8%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/12/22/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-8%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘8장 실용주의 프로젝트’를 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;8장-실용주의-프로젝트&quot;&gt;8장. 실용주의 프로젝트&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;41장-실용주의-팀&quot;&gt;41장. 실용주의 팀&lt;/h3&gt;

&lt;p&gt;앞서 살펴본 더 나은 프로그래머가 되기 위한 실용주의 기법들은 팀에도 그대로 적용됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;깨진 창문을 없애라: 팀 차원에서 깨진 창문을 없애려는 노력이 필요한 건 당연한 얘기입니다. 팀은 상품 품질에 책임이 있기에 만약 깨진 창문을 없애라는 철학을 이해하지 못한 팀원이 있다면 적극적으로 이해하도록 격려합시다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;삶은 개구리: 개인일 때보다 팀일 때 변화를 감지하지 못해 삶은 개구리가 되기 더 쉽습니다. 왜냐하면, 팀 내의 개개인들이 다른 구성원들이 이미 확인했을 것이라는 근거 없는 판단을 하기 쉽기 때문입니다. ‘다른 사람이 하겠지’라는 생각은 버리고 모든 사람이 적극적으로 환경 변화를 감시해야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;소통하라: 한 팀에 속한 개발자들이 대화하는 것은 당연합니다. 이를 넘어 팀 밖의 세상과도 소통을 한다는 사실도 잊지 맙시다. 바깥에서 봤을 때 무뚝뚝하고 과묵해보이는 팀은 최악입니다. 외부와 잘 소통하는 팀과의 회의는 언제나 기대되며, 그들이 작성한 문서는 깔끔하고 정확하며 일관적일 것입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;반복하지 마라: 팀 내에서 팀원 간의 중복된 일을 하도록 하지 않아야 합니다. 그렇게 하기 위해서 작업의 기능적 측면의 핵심 사안별로 담당자를 임명하면 효과적입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;직교성: 팀 간의 직교성을 높이려면 팀을 기능적으로 분리하는 것이 좋습니다. 각 팀이 최종 시스템의 특정한 기능에 전적으로 책임지게 하면 어떤 변화가 생겨도 그 변화에 책임이 있는 팀으로 영향 범위가 축소됩니다. 그리고 그 기능에 책임이 있다는 사실 때문에 팀원들이 주인의식을 더 많이 느낄 가능성이 높아집니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자동화: 일관성과 정확성을 보장하는 좋은 방법은 팀이 하는 모든 일을 자동화하는 것입니다. 자동화할 수 있는 것은 모조리 자동화해야 합니다. 자동화를 위해 팀 내에서 한 명의 팀원이 자동화 도구를 만들고 설치하도록 합시다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;덧칠을 언제 멈출지 알아라: 팀은 개인들로 이루어진다는 사실을 명심하고 각 팀원이 자신의 방식으로 자유롭게 개발할 수 있을 정도까지만 구조화하는 것이 중요합니다. 명세를 지나치게 구체적으로 작성할 때 발생하는 문제를 기억합시다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;42장-유비쿼터스-자동화&quot;&gt;42장. 유비쿼터스 자동화&lt;/h3&gt;

&lt;p&gt;수작업은 일관성과 반복 가능성을 보장하지 않습니다. 그렇기 때문에 항상 운에 의존하게 됩니다. 하지만 자동화를 하게 되면 실행할 때마다 일관된 과정을 통한 결과가 보장되기 때문에 자동화는 개발부터 제품 전반의 안정화를 위해서 가능한 곳에는 모두 적용되어야 합니다.
자동화를 지원해주는 아주 다양한 도구들이 존재합니다. cron을 통해 어떤 작업이 정해진 시간에 주기적으로 수행되도록 할 수 있고, makefile로 프로젝트 컴파일을 할 수도 있습니다. 이런 도구들을 이용해서 빌드나 테스트 같은 것들도 자동화할 수 있도록 구성합시다!&lt;/p&gt;

&lt;h3 id=&quot;43장-가차없는-테스트&quot;&gt;43장. 가차없는 테스트&lt;/h3&gt;

&lt;p&gt;테스트 코드는 일찍 테스트하고, 자주 테스트해야 합니다. 가급적, 코드를 작성하자마자 테스트 코드를 해야 합니다. 버그는 빨리 발견하면 발견할수록 고치는 비용이 적어짐을 명심하고, 테스트 코드를 작성하고 모든 테스트가 통과했을 때 비로소 코딩이 끝났다고 생각하면서 코드를 작성합시다. 그리고 가능하다면 자동화해서 주기적으로 테스트 코드가 실행되도록 합시다.
그럼 무엇을 테스트해야 할까요? 테스트를 할 때는 크게 단위 테스트, 통합 테스트, 유효성 평가와 검증, 녹록치 않은 현실 속 한정된 자원에서의 동작 테스트, 성능 테스트(스트레스 테스트), 사용 편의성 테스트 등을 해야 합니다.
무엇을 테스트할지 알았다면, 어떻게 테스트할지도 알아야 합니다. 코드의 수정이 일어난 후에도 전체 기능이 수정 이전과 같이 동작하는지를 테스트해야 합니다. 이를 회귀 테스트라고 합니다. 그리고 실세계의 데이터, 통계적 조건 하에 인공적으로 생성된 합성 데이터와 같은 테스트 데이터를 많이 확보하고 이 데이터를 기반으로 테스트해야 합니다. 두 종료의 데이터가 갖는 다른 특징들이 다른 종류의 버그를 찾아줄 것이기 때문에 둘 다 사용해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;44장-결국은-모두-글쓰기&quot;&gt;44장. 결국은 모두 글쓰기&lt;/h3&gt;

&lt;p&gt;개발자들은 일반적으로 문서화보다는 코드를 작성하는 것을 더 좋아하는 것 같습니다. 하지만 실용주의 프로그래머들은 문서화도 개발 프로세스의 일부로 포용합니다. 문서를 코드에 녹여낼 수 있다면 문서 작성은 한결 더 쉬운 작업이 됩니다. 코드와 문서를 결합시키는 유틸리티는 많습니다. 자바의 경우 JavaDoc이 대표적입니다.
문서의 종류로는 소스 코드, 주석, 설계와 테스트 문서와 같은 내부 문서와 사용자 메뉴얼 같이 외부로 출간되는 모든 것이 포함된 외부 문서가 있습니다. 어떤 문서이든 문서는 코드의 거울이라고 생각하고 작성을 게을리하지 맙시다. 특히 주석을 작성할 때는 그 코드의 동작에 대해 작성하는 경우가 많은데 그 내용은 이미 코드 자체에서 파악이 가능한 내용이기 때문에 DRY 원칙 위배입니다. 주석에는 왜 이런 코드가 작성되었는지, 왜 이런 구조로 잡았는지와 같은 목적에 대한 설명이 들어가야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;45장-위대한-유산&quot;&gt;45장. 위대한 유산&lt;/h3&gt;

&lt;p&gt;위대한 소프트웨어는 명세를 올바르게 구현하는 것을 넘어서 사용자들의 기대를 충족시켜야 합니다. 아무리 설계가 훌륭하고, 효율적이고, 요구사항을 잘 충족하더라도 그것이 사용자에게 매력적이지 않고 기대를 충족하지 않는다면 그 소프트웨어는 실패작으로 간주됩니다.
사용자들의 기대를 충족시키려면 사용자들과 기대에 대해서 상호 소통해야 합니다. 즉, 그들이 기대하는 것이 무엇인지에 집중하면서 사용자들에게 우리가 어떤 결과물을 전달하게 될 것인지를 끊임없이 설명해서, 그들이 무엇을 기대해야 할지에 대해서 제어를 하는 것이 중요합니다. 이런 과정은 앞에서 살펴본 예광탄이나 프로토타입 등을 이용해서 수월하게 진행할 수 있을 것입니다. 사용자들에게 미리 대략의 결과물을 보여줄 수 있기 때문입니다.
그리고 가능하다면 사용자들이 요구하지 않은 추가 기능을 구현해서 그들을 놀라게 합시다. 물론 어디까지나 기본에 충실할 때의 이야기 입니다.&lt;/p&gt;

&lt;h3 id=&quot;46장-오만과-편견&quot;&gt;46장. 오만과 편견&lt;/h3&gt;

&lt;p&gt;실용주의 프로그래머는 자신의 결과물에 자부심을 가집니다. 그렇기 때문에 책임을 회피하지 않습니다. 하지만 이런 자부심이 때로는 오만으로 이어질 수도 있습니다. 각자 자신의 코드에 대한 자부심이 지나쳐 서로 협력하지 못하고 깎아내리고 편견을 가지게 될 수 있습니다. 이는 바람직하지 않습니다. 항상 다른 사람들의 코드를 존중하고 상호 존중을 지킵시다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘8장 실용주의 프로젝트’를 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 7장</title><link href="https://anstn1993.github.io/2021/12/22/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-7%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 7장" /><published>2021-12-22T00:00:00+09:00</published><updated>2021-12-22T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/12/22/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-7%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/12/22/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-7%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘7장 프로젝트 전에’를 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;7장-프로젝트-전에&quot;&gt;7장. 프로젝트 전에&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;36장-요구사항의-구렁텅이&quot;&gt;36장. 요구사항의 구렁텅이&lt;/h3&gt;

&lt;p&gt;우리가 현실에서 받아보는 요구사항은 진정한 요구사항이 아닌 경우가 많습니다. 요구사항은 무엇이 이루어져야 된다는 진술이 되어야 하는데 거기에 어떤 정책이 녹아든 경우가 많으며 그것은 요구사항이라고 말하기 힘듭니다. 예를 들면 ‘직원 기록은 지명된 사람들만 볼 수 있습니다.’는 요구사항이라고 할 수 있지만, ‘해당 직원의 관리자와 인사부에서만 그의 기록을 열람할 수 있습니다’는 요구사항이 아닙니다. 여기에는 비즈니스 정책에 녹아있기 때문입니다. 당장 내일 그의 기록을 열람할 수 있는 대상군이 추가될 수도 있고, 반대로 사라질 수도 있는 것입니다. 위의 두 문장을 다르게 표현해보자면 전자는 후자에 비해 상대적으로 추상적이고, 후자는 전자에 비해 구체적입니다. 항상 구체적인 것보다는 추상적인 것이 더 오래갑니다. 그래서 이런 요구사항과 정책을 잘 분리해서 문서화하고 양자를 하이퍼링크하는 것이 중요합니다. 둘을 나누고 정책과 관련된 정보는 구현의 한 예시로 제시합니다. 그럼 정책은 결국 애플리케이션의 메타데이터로 빠져서 잘 분리될 것입니다.
요구사항을 잘 정리했다면 문서화를 잘 합시다. 유스케이스, 유스케이스 다이어그램 등을 잘 활용하면 문서화를 잘 할 수 있습니다.이때 지나치게 자세하게 서술하는 것에 주의해야 합니다. 요구사항은 최대한 간단하고 명료하게 작성해야 합니다. 요구사항에 설계, 사용자 인터페이스가 들어가서는 안 됩니다.
마지막으로 한 프로젝트를 만들기 위해 달려드는 모든 구성원들의 의사소통을 원활하게 하기 위해서 공통의 용어사전을 만들고 유지합시다. 이때 이 용어는 웹 기반의 문서로 작성해두면 접근성이 높아져 더 많은 사람들이 찾아볼 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;37장-불가능한-퍼즐-풀기&quot;&gt;37장. 불가능한 퍼즐 풀기&lt;/h3&gt;

&lt;p&gt;해결이 불가능에 가까워보이는 어려운 문제를 해결할 때는 항상 자신의 상상이 아닌 실제의 제약 조건을 알아내고 그 안에서 해법을 찾는 것입니다. 그리고 이 제약조건이 한번 밝혀지면 그것이 마음에 들든, 들지 않든 절대적인 것이라는 사실을 인정하는 것이 중요합니다. 이때 진정 제약조건이 아닌 것에 휘말리지 않도록 주의합시다. 많은 경우 이런 것에 휘말려서 문제 해결이 더 어렵게 느껴지는 경우가 많습니다.&lt;/p&gt;

&lt;h3 id=&quot;38장-준비가-되어야만&quot;&gt;38장. 준비가 되어야만&lt;/h3&gt;

&lt;p&gt;프로젝트를 진행하기에 앞서 아직 시작할 때가 아니라는 생각이 든다면 본인의 판단을 믿고 준비가 되었을 때 시작합시다. 경력이 쌓이면 쌓일수록 비슷한 일을 많이 경험하게 되기에 이유를 명확히 설명할 수는 없지만 뭔가 꺼림칙하다면 그 직감을 믿어도 괜찮습니다.
하지만 그 미룸이 늑장부림일 수도 있습니다. 과연 좋은 판단과 늑장부림을 어떻게 구분할 수 있을까요? 프로토타입을 만들기 시작하는 것입니다. 어려울 것 같은 부분을 고르고 그것의 개념 입증을 위한 코드를 작성해보면 시작한지 얼마 되지 않아 시간낭비라는 느낌이 드는 경우가 있을 것입니다. 이런 지루함이 느껴진다면 단순히 늑장부림이었을 가능성이 높아집니다. 이젠 진짜 개발을 시작할 때라는 좋은 징표입니다.
반면 프로토타입을 만드는 과정에서 몇몇 전제가 틀렸다는 것이 밝혀질 때도 있는데, 이런 경우 이제 어떻게 올바르게 해야할지도 명확해지기 때문에 진짜 개발을 시작해도 꺼림칙하지 않을 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;39장-명세의-함정&quot;&gt;39장. 명세의 함정&lt;/h3&gt;

&lt;p&gt;프로그램 명세화란 어떤 요구사항을 프로그래머가 자신의 기술로 작업할 수 있을 때까지 구체화하는 과정입니다. 즉, 추상적인 진술에서 올 수 있는 모호함을 제거하는 과정이라고도 볼 수 있죠. 명세는 지금 당장 구현을 할 개발자들과의 대화일 뿐만 아니라 미래에 유지보수하고 개선할 프로그래머들을 위한 기록입니다.
그런데 앞에서도 말했지만 이 명세를 지나치게 구체적으로 작성하는 것은 지양해야 합니다. 너무 세부적인 사항까지 명세에 작성하는 것은 여러 이유로 볼 때 실수입니다.
첫째, 명세서가 시스템이나 세스템에 대한 요구사항의 모든 세부사항과 미묘한 차이점을들 모두 잡아낼 수 없습니다. 그리고 명세에 작성하는 표기법의 의미를 결국에는 읽는 사람들에게 설명해줘야 하고, 사람들마다 해석 차이가 존재해서 일이 뒤죽박죽이 될 가능성이 있습니다.
둘째, 언어 자체의 표현 능력에도 문제가 있습니다. 우리가 수행할 작업을 기술할 때는 결국 자연 언어로 된 표현에 의존해야 하는데, 이는 명세에 그렇게 적합하지는 않습니다. 때론 이런 것들을 언어로 풀어내는 것보다 직접 해보는 것이 더 쉬울 수도 있습니다.
셋째, 실제 개발을 하는 사람의 기술적 자유를 빼앗아버릴 수도 있습니다. 너무 구체적이게 되면 개발을 하는 사람이 자신만의 판단이나 해석을 할 여지가 남지 않게 되기 때문에 어쩌면 더 좋은 선택, 더 좋은 구현을 하게 될 가능성을 차단하게 될 수도 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;40장-동그라미-화살표&quot;&gt;40장. 동그라미 화살표&lt;/h3&gt;

&lt;p&gt;여러 개발 방법론들과 같은 형식적 방법을 지나치게 맹신하면 안 됩니다. 형식적 방법에는 몇 가지 단점이 존재합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대부분의 형식적 방법은 다이어그램과 같은 어떤 형식을 이용해서 설명하는데, 이걸 보는 최종 사용자는 그 형식을 전혀 이해하지 못하기에 설계자가 해석을 해줘야만 합니다. 이는 결국 최종 사용자들이 그 시스템의 요구사항을 스스로 점검할 수 없음을 의미합니다.&lt;/li&gt;
  &lt;li&gt;형식적 방법들은 전문화를 권장하는 것처럼 보입니다. 어떤 집단은 데이터 모델 작업을 하고, 다른 집단은 아키텍처 수립하고, 또 다른 집단은 유스케이스를 모읍니다. 하지만 이런 방식은 의사소통 부족과 노력의 낭비로 이어지는 경우가 많습니다. 또한 구성원들이 시스템 전체에 대한 이해를 하지 못하게 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대부분의 방법론들은 저마다의 이점이 존재하지만 그 이점들이 발휘되기 위해서는 그것을 사용하는 사람들이 학습하는 상당한 시간이 필요한데, 이 상당한 노력은 가리고 이점만 과장하는 경우가 많으니 주의해야 합니다. 이런 사실을 받아들이고 주의 깊게 분석한 후에 그 방법론이 필요하다고 생각한다면 기꺼이 사용합시다. 하지만 그 방법론이라는 도구의 노예가 되면 안 됩니다. 동그라미와 화살표를 사용하는 우리가 주인이라는 사실을 기억합시다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘7장 프로젝트 전에’를 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 6장</title><link href="https://anstn1993.github.io/2021/12/16/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-6%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 6장" /><published>2021-12-16T00:00:00+09:00</published><updated>2021-12-16T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/12/16/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-6%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/12/16/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-6%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘6장 코딩하는 동안 해야 할 일들’을 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;6장-코딩하는-동안-해야-할-일들&quot;&gt;6장. 코딩하는 동안 해야 할 일들&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;31장-우연에-맡기는-프로그래밍&quot;&gt;31장. 우연에 맡기는 프로그래밍&lt;/h3&gt;

&lt;p&gt;우리는 항상 &lt;strong&gt;생각하면서&lt;/strong&gt; 코드를 작성해야 합니다. 즉 그냥 되는대로 작성하면 안 된다는 건데요. 항상 코드를 그렇게 작성하는 의도가 명확해야 합니다. 생각 없이 작성한 코드가 잘 돌아간다면 그것은 그저 그 코드를 돌리는 순간 운이 좋아서 잘 돌아가는 것이라고 생각합시다. 즉, 언제라도 제대로 돌아가지 않을 수 있다는 것을 의미합니다.
그럼 의도적으로 프로그래밍한다는 것은 무엇일까요? 책에서는 다음과 같이 설명합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자기가 무엇을 하고 있는지 알아야 한다.&lt;/li&gt;
  &lt;li&gt;맹목적인 코딩을 하지 말자. 왜 그렇게 동작하는지 아는 애플리케이션만 빌드하거고 이해하고 있는 기술을 사용하자.&lt;/li&gt;
  &lt;li&gt;코드를 작성하기 전에 계획을 세우고 진행하라.&lt;/li&gt;
  &lt;li&gt;신뢰할 수 있는 것에만 기대라.&lt;/li&gt;
  &lt;li&gt;자신의 가정을 문서로 남기고 그것을 통해 다른 사람들과 소통하라.&lt;/li&gt;
  &lt;li&gt;자신이 세운 가정을 반드시 테스트해서 증명해라.&lt;/li&gt;
  &lt;li&gt;우선순위를 정하고 중요한 것을 먼저 처리하라.&lt;/li&gt;
  &lt;li&gt;기존의 코드가 미래에 짤 코드의 발목을 잡지 못하게 해라. 더 이상 적절한 코드가 아니면 과감하게 리팩토링하라.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;32장-알고리즘의-속도&quot;&gt;32장. 알고리즘의 속도&lt;/h3&gt;

&lt;p&gt;프로그램을 만들 때 어떤 알고리즘이 사용하는 자원(시간, 프로세서, 메모리 등)을 추정하는 것이 중요할 때가 있습니다. 일반적으로 ‘big O’ 표기법을 통해 근사값을 추정할 수 있습니다. 이 표기법을 통해 우리가 작성한 코드의 차수를 추정해봅시다. 만약 코드만 봐서는 가늠이 되지 않는다면 입력 레코드의 수나, 그 외에 영향을 미칠 수 있는 요소를 바꾸어가면서 직접 실행해보면 됩니다. 몇 번만 실행해서 그래프를 그려본다면 대략적인 답이 나올 것입니다. 이 얘기의 연장으로, 코드만 보고 추정을 하는 것을 넘어서 실제 데이터를 입력받아서 돌아가는 코드의 수행시간이 진정으로 의미있는 수치입니다. O(n^2)이 O(nlogn)보다 수치상으로는 좋지 않지만 실제 코드가 수행되는 조건, 환경 하에서 수행시간이 전자가 더 짧다면 당연히 전자의 알고리즘을 채택하는 것이 맞습니다.&lt;/p&gt;

&lt;h3 id=&quot;33장-리팩터링&quot;&gt;33장. 리팩터링&lt;/h3&gt;

&lt;p&gt;코드는 생물과도 같습니다. 즉, 코드는 시간이 지나면 늘 문제에 직면하기 마련이고 그로 인해 항상 변하는 것이라는 사실을 명심하고 코드를 다시 작성하는 것에 대해 주저하지 맙시다. 중복, 성능, 유효기간이 끝난 지식, 직교적이지 않은 설계 등, 무슨 문제라도 생기면 바로 리팩터링을 해야 합니다. 사실 현실에서 일정의 압박 때문에 리팩터링을 하는 것이 쉽지는 않습니다. 결국 일정의 압박이 있다는 건 리팩터링을 할 시간까지는 고려하지 않았다는 것을 의미하는데, 이게 현재의 시점에서는 문제 없이 동작하는 것처럼 보이기 때문에 합리적인 판단이라고 생각할 수 있지만, 앞서 말했듯이 반드시 문제에 직면하게 된다는 것을 생각해보면 그렇게 합리적이라고 할 수 없습니다. 지금 당장 고치지 않아서 나중에 고치는 데 더 큰 비용이 들어갈 것이니까요. 그래서 책에서는 &lt;strong&gt;일찍, 그리고 자주 리팩터링하라&lt;/strong&gt;고 조언합니다.
리팩터링은 아주 천천히, 신중하게 해야합니다. 마틴 파울러는 올바른 리팩터링을 위해 다음과 같은 조언을 했습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;리팩터링을 할 때 새로운 기능 추가는 하지 말자.&lt;/li&gt;
  &lt;li&gt;리팩터링을 시작하기 전에 든든한 회귀 테스트 집합을 확보해야 한다. 그래야 리팩터링 과정에서, 그리고 리팩터링이 종료된 후에도 리팩터링 전과 같이 동작하는지 확인해볼 수 있다.&lt;/li&gt;
  &lt;li&gt;단계를 나누어서 신중하게 작업한다. 대부분의 커다란 작업은 사실 작은 규모의 것들이 합쳐진 것이다. 한 단계가 마무리될 때마다 테스트를 돌려서 디버깅의 지옥에서 벗어나자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;34장-테스트하기-쉬운-코드&quot;&gt;34장. 테스트하기 쉬운 코드&lt;/h3&gt;

&lt;p&gt;역할이 명확히 분리되게끔 모듈을 나누면 각 모듈들에 대한 단위 테스트를 하기 쉬워집니다. 단위 테스트는 모듈들의 루틴을 호출해보면서 그 루틴들이 계약을 잘 지키는지 테스트하는 것을 말합니다. 이때 테스트는 작은 것에서부터 점점 큰 것으로 진행되어야 합니다. 가장 작은 단위의 모듈들이 탄탄하게 테스트되면 그 모듈들에 의존하고 있는 다른 모듈들을 테스트할 때 문제가 생기더라도 이미 테스트가 완료된 모듈들은 후보에서 과감하게 제외할 수 있기 때문입니다. 물론 테스트를 하는 것은 성가시고, 귀찮고, 시간도 더 많이 필요하지만, 그렇게 하지 않았을 때 미래에 문제가 터져버려서 어디서부터 디버깅을 해야할지도 감이 안 오는 상황을 피하기 위해서 꼭 해야만 합니다.
테스트 코드는 다음의 아주 귀중한 자원도 제공합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모듈의 모든 기능을 어떻게 이용해야 하는지 보여주는 예제&lt;/li&gt;
  &lt;li&gt;코드 변경시 검증하기 위한 회귀 테스트 구축 수단&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;실제로 저도 작업을 하면서 코드 수정을 하고 작성해둔 모든 테스트 코드를 돌려봅니다. 돌려보고 모든 테스트가 통과하면 마음이 편해지고, 통과하지 못해도 좋습니다. 배포 전에 문제를 찾은 것이니까요.
책에서는 테스트를 위한 장치(도구)를 사용하라고 권장하는데요. 그 장치는 다음과 같은 기능이 있어야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시작할 때 할 일과 마칠 때 할 일을 지정할 수 있는 표준적인 방법&lt;/li&gt;
  &lt;li&gt;개별적인 테스트들을 선택하거나, 모든 테스트를 한꺼번에 선택하게 해주는 메서드&lt;/li&gt;
  &lt;li&gt;예상한(또는 예상치 못한) 결과에 비추어 결과를 분석할 수 있는 방법&lt;/li&gt;
  &lt;li&gt;실패를 보고하는 표준화된 형태&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자바에서는 이 모든 조건을 갖춘 도구로 JUnit을 많이 활용합니다. 저도 팀에서 테스트 코드를 Junit으로 작성하고 있습니다^^ 모든 코드에 대한 테스트 코드를 작성하지는 못하지만 그래도 작성하고나면 마음이 든든합니다. 어차피 프로그래머 자신, 혹은 팀에서 테스트를 하지 않으면 유저가 테스트를 하게 됩니다. 유저가 테스트하기 전에 먼저 테스트를 꼼꼼하게 진행해야겠습니다!&lt;/p&gt;

&lt;h3 id=&quot;35장-사악한-마법사&quot;&gt;35장. 사악한 마법사&lt;/h3&gt;

&lt;p&gt;오늘날 방대해진 애플리케이션을 빠르게 만들기 위해서 거의 대부분의 코드 골격을 대신 생성해주는 마법사 덕분에 우리는 정해진 시간 안에 서비스를 만들 수 있지만 마법사가 만든 코드를 이해하고 사용하는 것이 중요합니다. 그렇지 않으면 이는 우연에 맡기는 프로그래밍과 다를 게 없습니다. 마법사가 만들어준 코드가 지금 상황에 맞지 않으면 혼자 힘으로 코드를 바꿔야 하는데 기를 때 마법사의 코드를 이해하지 못하면 결국 마법사에게 끌려다니게 될 것입니다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘6장 코딩하는 동안 해야 할 일들’을 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 5장</title><link href="https://anstn1993.github.io/2021/12/08/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-5%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 5장" /><published>2021-12-08T00:00:00+09:00</published><updated>2021-12-08T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/12/08/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-5%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/12/08/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-5%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘5장 구부러지거나 부러지거나’을 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;5장-구부러지거나-부러지거나&quot;&gt;5장. 구부러지거나 부러지거나&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;26장-결합도-줄이기와-디미터-법칙&quot;&gt;26장. 결합도 줄이기와 디미터 법칙&lt;/h3&gt;

&lt;p&gt;결합도를 줄이는 것은 최대한 적은 객체와 상호작용하는 것에서 시작됩니다. 모든 객체를 모듈화하고 한 모듈이 너무 많은 모듈과 상호작용하는 것을 제한합시다. 그러면 한 모듈이 변경되더라도 다른 모듈들은 큰 변경 없이 수행될 수 있습니다. 책에서 재밌는 예시를 들었는데요. 우리가 집을 지을 때 이를 도맡아서 해줄 주계약자라는 주체와만 계약을 할 것입니다. 그럼 이 주계약자는 또 다시 집을 짓기 위해 필요한 역할들을 담당할 하도급자들과 계약을 합니다. 이때 우리는 하도급자들과 직접 부딪힐 일도 없고 이들에게 무슨 일이 생긴다고 하더라도 신경쓸 것이 없습니다. 모든 건 주계약자가 처리할 거니까요. 이처럼 어떤 객체에게 특정한 서비스를 요청하면 그 서비스가 어떻게 처리되는지 요청자는 알 필요가 없게 하는게 중요합니다.
프로그램에서 모듈 간의 결합도를 최소화하고 싶다면 디미터 함수 법칙을 따르는 것도 좋은 방법입니다. 디미터 함수 법칙에 따르면 객체의 한 메서드 내에서 다음에 해당하는 메서드만 호출해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체 자신이 가지는 다른 메서드&lt;/li&gt;
  &lt;li&gt;인자로 전달된 객체의 메서드&lt;/li&gt;
  &lt;li&gt;객체 자신이 포함하고 있는 멤버의 메서드&lt;/li&gt;
  &lt;li&gt;지역 변수 객체의 메서드&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;물론 이 법칙을 엄격하게 따르는 것에 대한 대가도 있습니다. 역할에 대한 위임을 위해서 위임하는 객체의 메서드를 호출하기 위한 위임용 메서드를 많이 만들어야 합니다. 하지만 그럼에도 불구하고 깨지기 쉽고, 유연하지 않은 프로그램을 만드는 것이 가져오는 후폭풍은 어마무시하기 때문에 가능하다면 디미터 함수 법칙을 잘 지키는 것이 좋을 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;27장-메타프로그래밍&quot;&gt;27장. 메타프로그래밍&lt;/h3&gt;

&lt;p&gt;메타데이터는 최대한 많이 코드에서 분리하여 별도로 관리하도록 하는 것이 좋습니다. 데이터에 관한 데이터인 메타데이터는 애플리케이션 구성에 필요한 모든 데이터를 의미합니다. 다음과 같은 것들입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터베이스 연동 정보&lt;/li&gt;
  &lt;li&gt;api url&lt;/li&gt;
  &lt;li&gt;컨텐츠 업로드/다운로드 경로&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같은 데이터가 코드레벨에 뿌리내려 박혀있다면 그 프로그램은 매우 경직된, 변화에 쉽게 대응할 수 없는 프로그램이 될 것입니다. 우리의 애플리케이션의 db가 바뀌더라도 그것이 코드 바깥에 있다면 코드의 수정은 최소화될 것입니다. 메타데이터를 코드 바깥에서 별도로 관리하면 코드의 추상화 레벨은 올라갈 것이고, 애플리케이션의 설정 변경을 위해 다시 컴파일할 필요가 없어집니다.
저에게 가장 익숙한 스프링도 메타데이터 관리를 위한 지원을 아주 잘 해줍니다. properties나 yaml파일에 애플리케이션의 모든 메타 데이터를 몰아두고 코드에서는 그 설정 파일의 값을 동적으로 읽어들일 수 있게 구성해서 유연성을 높일 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;28장-시간적-결합&quot;&gt;28장. 시간적 결합&lt;/h3&gt;

&lt;p&gt;시간적 결합은 어떤 메서드나 함수의 호출이 다른 것의 호출보다 이전, 혹은 이후에만 실행되어야 하는 순서에 의존하는 것을 의미합니다. 물론 이런 순서가 반드시 지켜져야하는 경우도 있지만 순서와 무관하게 호출되어도 되는(혹은 동시에 호출되어도 되는) 경우에도 순차적으로 호출되는 경우가 있습니다. 이런 경우에는 시간적 결합을 끊어낼 수 있는 방법을 고려해보는 것이 좋습니다. 주로 동시성을 허용하는 것인데요. 이 책에서는 아래와 같은 방법들을 제시합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;작업 흐름
요구사항을 분석할 때 작업의 흐름을 모델화해서 분석해보는 것입니다. UML 활동 다이어그램을 통해 작업 흐름을 시각화하는 것이 하나의 방법이 되겠습니다. 그렇게 분석하다보면 &lt;strong&gt;동시에 일어나도 되는 것들&lt;/strong&gt;이 보이는데요. 이를 통해 병렬성을 극대화할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아키텍처
여러 시스템들이 결합되어 동작하는 분산 애플리케이션에서 동시에 처리되어도 되는 시스템들끼리 집합으로 묶고 순차적으로 처리되는 시스템 집합 사이에는 큐를 통해 순차적으로 실행되어야하는 시스템 집합들 간의 동기화를 할 수 있습니다. 이렇게 하면 같은 시스템 집합 속의 시스템들 간의 시간적 결합을 끊어내서 효율을 극대화할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;동시성을 고려한 설계
책은 자바의 스레드를 예로 들면서 동시성 제어를 위해 고려해야할 것들을 강조합니다. 가장 대표적으로 static한 변수들을 동시 접근으로부터 보호하는 것이 있는데요. 더 중요한 건 정적 변수가 정말 필요한지를 자문하는 것입니다. 다음은 여러 스레드의 손을 타는 전역 변수의 상태가 손을 탈 가능성이 있는 모든 시간대에 언제나 유효한 상태에 있도록 하는 것이 중요합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;29장-단지-뷰일-뿐이야&quot;&gt;29장. 단지 뷰일 뿐이야&lt;/h3&gt;

&lt;p&gt;적절히 책임을 잘 분리해서 모듈들을 만드는 것은 매우 중요합니다. 그런데 이렇게 만들고나서 각 모듈들이 소통하게 하려면 어떻게 해야할까요. 이벤트를 사용하면 됩니다. 이벤트는 어떤 객체의 상태 변화가 생기면 그 변화에 관심이 있는 다른 객체들에게 알리는 것입니다. 이벤트를 구현할 수 있는 대표적인 방법이 출판/구독인데요. 출판자는 이벤트를 발신하는 역할을 구독자는 이벤트를 수신하는 역할을 합니다. 구독자가 관심을 가지는 이벤트에 구독을 하면 출판자는 구독자 목록을 저장하고 해당 이벤트가 발생하면 목록에 있는 구독자에게 이벤트가 발생했다고 알리게 됩니다. 이 둘 간의 관계는 여러 형태를 가지는데, 직접 통신을 하는 ‘p2p’방식부터 중간에서 중계를 하는 객체를 두는 ‘소프트웨어 버스 방식’ 등 다양합니다.
이런 출판/구독 메커니즘은 MVC 패턴에서 뷰와 컨트롤러에서 모델을 분리해내기 위해서 사용할 수 있습니다. 모델은 출판자, 뷰는 구독자가 됩니다. 모델에서 어떤 데이터의 변화라는 이벤트가 생기면 뷰는 그 사실을 전달받아 갱신하는 것입니다.
하지만 여전히 구독자와 출판자 사이에는 서로에 대한 의존성이 존재합니다. 가령 자바에서 출판자에게 인터페이스를 전달하더라도 콜백을 위해 어떤 루틴을 호출해야할지에 대한 지식을 가지고 있어야 합니다. 다음 장에서 결합도를 더 많이 낮추는 방법을 보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;30장-칠판&quot;&gt;30장. 칠판&lt;/h3&gt;

&lt;p&gt;형사들이 수사를 할 때 칠판을 어떻게 활용하는지 살펴보면 다른 모듈들 간의 결합도를 낮추는 실마리를 찾을 수 있습니다. 형사들은 칠판을 다음과 같이 활용합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;어떤 형사도 다른 형사들의 존재를 알 필요가 없다. 그저 칠판에 업데이트된 새로운 정보만 얻고 자신이 발견한 것을 추가한다.&lt;/li&gt;
  &lt;li&gt;형사들은 저마다 속한 환경이 다르고 받은 훈련의 종류가 다르고, 교육 수준도 다르며, 관할 구역이 다를 수도 있다. 단지 그들의 공통점은 사건 해결 하나다.&lt;/li&gt;
  &lt;li&gt;수사 과정에서 여러 형사들이 들어오고 나갈 수 있고, 임무의 교대 시간도 다 다를 수 있다.&lt;/li&gt;
  &lt;li&gt;칠판에 어떤 정보를 올려야 하는지에 대한 제한은 없다. 사진, 증언, 물리적 증거 등 모든 것이 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 내용을 프로그래밍으로 적용해본다면, 형사들은 모듈들이 되고 칠판은 각 모듈들이 비동기적으로 데이터를 주고받을 수 있는 공간을 의미합니다. 이제 칠판에 데이터를 주고 받는 단 하나의 인터페이스만 정한다면 이벤트를 보내는 쪽과 받는 쪽의 결합은 완전히 끊어낼 수 있습니다. 이 내용을 보면서 메세징 큐가 떠올랐는데요. 카프카나, rabbit MQ를 이용하면 이런 메세징 큐에 데이터를 밀어넣고, 소비하기 위한 인터페이스를 하나로 통일할 수 있게 되어서 서로 다른 모듈들 간에 데이터 교환을 위한 제각각 다른 인터페이스를 구현하면서 생기는 의존성을 끊어낼 수 있습니다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘5장 구부러지거나 부러지거나’을 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 4장</title><link href="https://anstn1993.github.io/2021/12/01/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-4%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 4장" /><published>2021-12-01T00:00:00+09:00</published><updated>2021-12-01T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/12/01/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-4%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/12/01/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-4%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘4장 실용주의 편집증’을 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;4장-실용주의-편집증&quot;&gt;4장. 실용주의 편집증&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;21장-계약에-의한-설계&quot;&gt;21장. 계약에 의한 설계&lt;/h3&gt;

&lt;p&gt;정직한 거래를 보장하는 최선의 해법은 계약입니다. 계약의 당사자들은 모두 자신의 권리와 책임을 지고, 서로에게 기대한 바를 수행하도록 강제합니다. 이런 컨셉을 소프트웨어 모듈에도 적용하면 프로그램의 정확성을 높일 수 있습니다. 정확한 프로그램은 자신의 일이라고 주장하는 것에 대해 더 많지도, 적지도 않게 수행하는 것입니다. 그 주장을 문서화하고 검증하는 것이 바로 계약에 의한 설계(Design By Contract, DBC)입니다.
이 계약은 보통 함수, 메서드와 그것의 호출자 사이에 적용됩니다. 계약에 의한 설계 개념을 개발한 버트란드 마이어는 계약을 이행하기 위한 조건으로 다음 3가지를 말합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;선행조건: 루틴이 호출되기 위해 지켜져야 할 조건으로 이 조건이 위반된 경우에는 루틴이 호출되지 않아야 합니다. 즉 조건이 충족된 데이터를 루틴에 전달하는 것은 호출하는 쪽의 책임입니다.&lt;/li&gt;
  &lt;li&gt;후행조건: 루틴이 완료되었을 때의 상태를 의미합니다. 어떤 루틴에 후행조건이 있으면 그 루틴은 반드시 종료됨을 보장합니다.&lt;/li&gt;
  &lt;li&gt;클래스 불변식: 호출자의 입장에서 루틴이 종료되고 호출자로 제어권이 반환될 때 불변식이 항상 참임을 보장하는 것입니다. 루틴이 진행 중일 때는 불변식이 일시적으로 참이 아닐 수도 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 조건을 정리하자면 만약 호출자가 루틴의 모든 선행조건을 이행한다면, 루틴은 종료시에 모든 호행조건과 불변식이 참이 될 것을 보장해야 하는 것입니다.&lt;/p&gt;

&lt;p&gt;상속과 다형성에서도 이런 계약은 빛을 발합니다. 서브타입은 항상 부모 타입의 한 종류라는 간단한 사실을 잊지 않고 서브클래스에서는 자신의 부모 이상으로 받아들이고, 최소한 자신의 부모만큼은 보증해야 하는데 이런 규칙을 잘 이행하게 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;22장-죽은-프로그램은-거짓말을-하지-않는다&quot;&gt;22장. 죽은 프로그램은 거짓말을 하지 않는다.&lt;/h3&gt;

&lt;p&gt;우리는 코드를 작성하는 그 순간부터 무슨 일이든 일어날 수 있다는 것을 인정해야 합니다. 많은 경우 ‘그런 일은 절대 일어날 리 없어’라는 생각과 함께 방어적으로 코딩을 하지 않는데, 가능하면 방어적으로 코딩하면서 에러를 최대한 빨리 잡아내고 &lt;strong&gt;가능한한 일찍 프로그램의 작동을 멈추게 하는 것&lt;/strong&gt;이 좋습니다. 대표적으로 자바는 예외를 던져서 그것을 잡지 않으면 스택 트레이스를 출력하면서 프로그램을 종료합니다.
그렇게 하지 않으면 프로그램은 점점 망가져가고 결국 문제의 발생 지점과는 점점 멀어져서 어디서부터 잘못됐는지 알 수 없는 지경에 다다를 수도 있습니다. 멈출 수 있을 때 바로 멈춰버립시다!&lt;/p&gt;

&lt;h3 id=&quot;23장-단정적-프로그래밍&quot;&gt;23장. 단정적 프로그래밍&lt;/h3&gt;

&lt;p&gt;단정문(assertion)을 사용해서 절대 일어나선 안 될 일들에 대비를 해야 합니다. 단정문을 통한 검사 없이 ‘이런 일은 절대 일어날 수 없어’라고 생각하고 있다면 그것은 아주 큰 오산입니다. 혹자들은 단정문에 대한 오해를 가지고 단정문을 사용하지 않는데 주로 다음과 같은 오해가 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;단정문은 과부하를 준다. 단정문은 코드의 테스트를 위해 존재하고, 테스트가 끝나면 단정을 꺼야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 주장은 테스트가 모든 버그를 발건한다는 가정이 깔려있는데, 복잡한 프로그램에서는 모든 버그를 테스트만으로 못 잡을 가능성이 높습니다. 그리고 우리의 프로그램은 험한 세상에서 돌아가고있기 때문에 런타임에도 단정문으로 최대한 빨리 일어나선 안 될 일이 일어나는 것에 대비해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;24장-언제-예외를-사용할까&quot;&gt;24장. 언제 예외를 사용할까&lt;/h3&gt;

&lt;p&gt;예외는 말 그대로 예외적인 상황에서 사용해야 합니다. 예를 들면, 파일을 열어서 읽어들일 때 파일이 존재하지 않는다면 예외가 발생해야 할까요? 정답은 파일이 반드시 존재해야 한다면 그렇고, 파일이 있을 수도 있고, 없을 수도 있다면 그렇지 않다는 것입니다. 파일이 반드시 존재해야 한다면 예외를 던지고 그렇지 않다면 에러만 반환합시다.
예외를 사용하지 말아야 할 때도 알아야 합니다. 예외는 절대 정상적인 로직을 처리하기 위해서 사용하면 안 됩니다. 모든 예외 처리를 다 제거했을 때 프로그램이 잘 동작하지 않는다면 예외를 잘못 사용하고 있는 건 아닌지 의심해봐야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;25장-리소스-사용의-균형&quot;&gt;25장. 리소스 사용의 균형&lt;/h3&gt;

&lt;p&gt;리소스 사용의 균형은 &lt;strong&gt;사용을 마쳤으면 반드시 반납하는 것&lt;/strong&gt;을 의미합니다. 메모리, 트랜잭션, 파일 등 어떤 종류의 리소스가 되었든 할당이 되었으면 반납이 되어야 합니다. 그리고 이 둘은 같은 객체가 책임져야 합니다. 이때 할당과 반납을 하는 함수는 별도로 만드는 것이 추후 유지보수 측면에서 좋습니다. 특정 역할을 하는 함수에서 반납까지 함께 처리하게 되면 시간이 지나면서 요구사항이 추가되고 그 함수가 조건에 따라 호출되지 않는 경우가 생겼을 때 자원이 반납되지 않게 되는 등의 문제가 생길 수 있습니다.
자원을 두개 이상 중첩할당할 수도 있습니다. 이때는 2가지를 주의해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;리소스를 할당한 순서의 반대로 해제하라. 그렇게 해야 한 리소스가 다른 리소스를 참조하는 경우에도 리소스를 고아로 만들지 않는다.&lt;/li&gt;
  &lt;li&gt;코드의 여러 곳에서 동일한 리소스 집합을 할당받으려고 하면 할당 순서는 모든 곳에서 동일하게 해라. 그렇게 애햐 교착 상태에 빠질 가능성을 줄일 수 있다. 할당의 순서가 달라서 한 곳에서는 resource A -&amp;gt; B, 다른 한 곳에서는 resouce B -&amp;gt; A 순서로 할당을 요청하는데 공교롭게도 각각 A와 B를 할당받은 상태에서 다음 자원 할동을 요청하게 되면 그 다음 필요한 자원은 서로가 이미 할당받은 상태이기 때문에 계속해서 기다려야 합니다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘4장 실용주의 편집증’을 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 3장</title><link href="https://anstn1993.github.io/2021/11/23/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-3%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 3장" /><published>2021-11-23T00:00:00+09:00</published><updated>2021-11-23T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/11/23/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-3%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/11/23/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-3%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘3장 기본적인 도구’를 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;3장-기본적인-도구&quot;&gt;3장. 기본적인 도구&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;14장-일반-텍스트의-힘&quot;&gt;14장. 일반 텍스트의 힘&lt;/h3&gt;

&lt;p&gt;프로그래밍은 인간이 하는 것이고 인간은 소위 일반 텍스트(plain text)를 통해서 소통하기 때문에 설계, 구현, 테스트, 문서화 등 대부분의 지식을 저장할 때는 일반 텍스트를 사용하는 것이 바람직합니다. 일반 텍스트가 아닌 이진수, 암호화된 무작위로 나열된 문자들은 그 데이터를 이해하는 데에 필요한 맥락이 없는한 의미를 파악할 수 없습니다. 물론 일반 텍스트를 사용하면 저장 공간에 대한 오버헤드가 생길 수 있고 다른 포맷에 비해 연산에 대한 오버헤드도 생길 수 있지만 그것을 일반 텍스트를 사용했을 때의 장점이 그것을 다 보상하고도 남습니다. 다음이 그 장점입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;구식이 되는 것에 대한 보험: 사람이 읽을 수 있는 형태의 데이터를 사용하면 그 데이터를 생성한 애플리케이션이 죽더라도 살아남을 수 있습니다. 완전히 소멸해버린 레거시 시스템이 생성한 주민등록번호 데이터가 있을 때 그것이 이진 데이터로 표현되어있으면 그 레거시 시스템 없이는 그 데이터의 의미를 파악하지 못합니다. 하지만 일반 텍스트로 되어있다면 그 데이터를 파싱해서 새로운 애플리케이션에 적용하는 건 매우 간단한 작업이 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;호환성: 소스코드 관리 시스템, 컴파일러, ide등과 같이 오늘날의 모든 도구들은 일반 텍스트를 다룰 수 있게 지원합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;더 쉬운 테스트: 시스템 테스트를 구동하게 할 합성 데이터를 만들기 위해 일반 텍스트를 사용하면 별도의 도구 없이 테스트 데이터를 추가, 업데이트, 수정할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;15장-조개-놀이&quot;&gt;15장. 조개 놀이&lt;/h3&gt;

&lt;p&gt;오늘날의 많은 GUI 프로그램은 프로그래머들에게 편리함을 제공하지만, 그럼에도 여전히 셸 명령어들은 프로그래머에게 없어서는 안 될 작업대라고 할 수 있습니다. GUI나 IDE의 장점은 우리가 보는 것이 우리가 얻는 것(WYSIWYG-What You See Is What You Get)이라는 점입니다. 즉 매우 직관적으로 우리에게 필요한 것을 얻을 수 있다는 것이죠. 하지만 동시에 우리가 보는 것이 우리가 얻는 전부(WYSIAYG - What You See Is All You Get)라는 단점이 있습니다. 즉 GUI, IDE가 제공하는 기능 이상의 것은 얻을 수 없습니다.
하지만 셸의 명령어들을 조합하면 우리가 원하는 거의 모든 기능을 얻을 수 있습니다. 그렇기 때문에 반드시 셸과 친근해져야 합니다. 또 이런 자주 사용되는 조합을 스크립트로 작성하여 자동화할 수도 있습니다. 현재 회사에서 배포 자동화에도 셸 스크립트가 사용되고 있는데 이를 제대로 이해하지는 못 한 것 같습니다. 셸의 중요성에 대해서 인지하고는 있지만 그 특유의 지루함 때문에 미루어왔는데 앞으로는 억지로라도 공부를 해야겠습니다..&lt;/p&gt;

&lt;h3 id=&quot;16장-파워-에디팅&quot;&gt;16장. 파워 에디팅&lt;/h3&gt;

&lt;p&gt;에디터는 프로그래밍의 기본적인 원재료인 텍스트를 매우 효율적으로 조작할 수 있게 해주는 도구이기 때문에 마치 자신의 손을 움직이는 것과 같이 익숙한 수준으로 에디터에 대한 숙련도를 높일 필요가 있습니다. 특히 &lt;strong&gt;하나의 에디터를 마스터&lt;/strong&gt;하는 것이 중요합니다. 그리고 모든 편집 작업에서 그 에디터를 사용합시다.
그럼 어떤 에디터를 선택하는지가 중요한데 다음의 요소를 만족해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 플랫폼에서 가능해야 한다.&lt;/li&gt;
  &lt;li&gt;환경 설정이 가능해야 한다.(폰트, 색깔, 윈도우 크기, 키 입력 설정 등)&lt;/li&gt;
  &lt;li&gt;확장이 가능해야 한다. 새 프로그래밍 언어가 나와도 에디터는 사용 가능해야 합니다. 즉 어떤 컴파일러 환경과도 결합 가능해야 합니다.&lt;/li&gt;
  &lt;li&gt;복잡하고 다단계의 작업 수행이 가능하도록 에티터를 프로그램할 수 있어야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;17장-소스코드-관리&quot;&gt;17장. 소스코드 관리&lt;/h3&gt;

&lt;p&gt;소스코드 관리, 즉 형상관리는 프로젝트에서 발생한 실수를 되돌릴 수 있게 해주는 거대한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;undo&lt;/code&gt; 키와 같습니다. 형상관리를 통해서 언제든지 소스코드를 원하는 시점으로 되돌릴 수 있다는 것은 프로젝트의 안정감을 극도로 높여주는 것을 의미합니다. 뿐만 아니라 특정 시점에 어떤 코드를 누가 수정했는지 알 수 있고, 무수히 많은 브랜치를 생성해서 저마다 독립적으로 코드를 작성하고 한 번에 합칠 수도 있기에 생산성도 높아집니다. 또한 결국 형상관리의 핵심은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;undo&lt;/code&gt;에 있기 때문에 소스코드가 아닌 모든 컨텐츠(각종 문서, 메모, makefile, 셸 스크립트, 환경설정 등)는 다 형상관리 하에 두는 것이 좋습니다.
책에는 나오지 않지만 최근에는 많은 프로젝트가 git flow의 규칙에 따라 관리되는데 이런 형상관리가 당연하다고 생각하다가도 막상 이게 없다고 생각하면 너무 암담할 것 같습니다^^&lt;/p&gt;

&lt;h3 id=&quot;18장-디버깅&quot;&gt;18장. 디버깅&lt;/h3&gt;

&lt;p&gt;현존하는 모든 프로그램은 완벽하지 않고 우리가 만든 프로그램도 마찬가지 입니다. 항상 버그가 존재하기 때문에 디버깅을 잘해야 합니다. 디버깅을 잘 하려면 우선 마음가짐을 다잡아야 합니다. 디버깅은 단지 &lt;strong&gt;문제해결&lt;/strong&gt; 그 이상, 이하도 아니라고 생각하고 접근해야 합니다. 버그를 만들어낸 장본인이 누구인지 색출하고, 비난하는 것은 아무 도움이 안 됩니다. 그렇게 한다고 버그가 고쳐지는 것도 아닙니다. 그 다음은, 디버깅을 할 때 당황하지 않아야 합니다. 일정이 촉박하거나 상사나 클라이언트의 압력에 시달리고 있는 상황에서 디버깅을 하는 것은 분명히 쉽지 않겠지만 그럼에도 불구하고 차분하게 원인을 생각해야 합니다. 그리고 디버깅을 할 때 표면에 보이는 문제를 해결하는 것이 아닌 몇 단계 더 깊이 있는 근본적인 문제를 해결하려고 노력해야 합니다.
이렇게 마음가짐을 다잡았다면 이젠 실제로 디버깅을 어떻게 할지 살펴보겠습니다. 당연한 얘기처럼 들릴 수도 있지만 수집할 수 있는 모든 정보를 수집해야 합니다. 필요하다면 최초로 버그를 발견한 사람을 인터뷰할 수도 있어야 합니다. 그리고 제한적인 테스트를 넘어 최종 사용자의 입장에서 모든 케이스를 철저하게 테스트해야 합니다.
이렇게 어떤 버그가 발생하고 있는지를 확실히 파악했으면 그게 프로그램의 입장에서 어떻게 발생하는지 찾아야 합니다. 그걸 알아내는 가장 쉬운 방법은 그 프로그램이 다루는 데이터를 살펴보는 것입니다. 이때 데이터들 간의 상호관계를 시각화해서 보여주는 디버거를 쓸 수 있다면 아주 쉽게 깊이 있는 파악이 가능합니다. 그리고 현재 상태를 넘어 시간별로 데이터의 상태가 어떻게 변하는지를 살펴봐야 할 수도 있습니다. 특히 실시간 시스템, 동시 프로세스, 이벤트 기반 애플리케이션 등에서 그런데, 이럴 때는 트래이싱을 이용합시다. 트레이스 메시지는 규칙적이고 일관된 형식으로 작성되어야 합니다. 왜냐하면 그 메시지에서 특정 영역만 자동으로 뽑아내서 해석하고 싶은 경우가 많기 때문입니다. 예를 들면 자원 누수가 있는지 확인하고 싶어서 open/close를 남겨서 open은 있는데 close는 없는 경우를 찾을 수 있습니다. 또 다른 방법으로는 버그가 발생한 코드에 대해서 다른 사람에게 설명을 해보는 것입니다. 그러면 혼자서 코드를 봤을 때 당연하게 생각하고 지나갈 것을 명시적으로 설명하게 되는데 여기서 의외의 통찰을 얻을 수도 있습니다. 그 외로 자신이 작성한 코드에 근거가 없는 신뢰와 믿음을 가지기보단 항상 증명하려고 하고 서드파티 모듈보단 자신의 코드에 문제가 있을 것이라고 가정하고 디버깅을 합시다.&lt;/p&gt;

&lt;h3 id=&quot;19장-텍스트-처리&quot;&gt;19장. 텍스트 처리&lt;/h3&gt;

&lt;p&gt;텍스트 처리를 위한 언어는 텍스트를 원하는 형태로 제어하기 위해서 꼭 숙달해야 합니다. 유닉스 계열에서는 awk, sed와 같은 명령어를 선호하기도 하고, 파이썬 같은 더 구조적이고 객체지향성을 갖춘 도구를 선호하기도 하는데 뭐가 됐든 이런 기반 언어들 중 하나를 익혀야 합니다. 이런 텍스트 처리 언어를 통해 다음과 같은 것을 할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터베이스 스키마가 들어있는 일반 텍스트 파일로 sql문 생성, 데이터베이스에 엑세스하는 c코드 생성 등..&lt;/li&gt;
  &lt;li&gt;자바 클래스에서 특정 플래그가 달린 멤버에 대한 getter/setter 자동 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;20장-코드-생성기&quot;&gt;20장. 코드 생성기&lt;/h3&gt;

&lt;p&gt;코드 작성하는 코드, 즉 코드 생성기를 만들면 똑같은 기능을 다른 맥락에서 사용할 때 반복할 필요가 없어집니다. 코드 생성기는 크게 두 가지 유형이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;수동적 코드 생성기: 결과를 내기 위해 한 번만 실행되는 생성기 입니다. 한번 생성되면 수동적 코드 생성기와는 독립적인 결과물이 됩니다. 즉 몇 개의 입력을 받으면 그에 맞게 출력을 생성해주는 템플릿이라고 생각하면 됩니다. 가령 새 소스 파일 생성, 언어 간 일회용 변환 수행 등이 수동적 코드 생성기 입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;능동적 코드 생성기: 코드 생성이 필요할 때마다 작동하는 생성기 입니다. 단지 평하기 위해 사용하는 수동적 코드 생성기와 달리 능동적 코드 생성기는 DRY 원칙을 따르려면 필수 입니다. 이 생성기는 하나의 지식 뼈대를 만들어두면 그것을 사용하는 구체화된 형식으로 변환해줍니다. 가령 데이터베이스 애플리케이션을 만들 때 우리가 다루어야 할 환경은 데이터베이스와 데이터베이스에 접근하기 위한 언어 입니다. 이때 데이터베이스 스키마와 언어에서 데이터베이스 테이블 형식을 표현하는 구조체는 형태만 다를뿐 그 지식은 동일합니다. 이는 지식이 중복되는 것입니다. 이런 것을 능동적 코드 생성기로 해결할 수 있습니다. 스키마를 입력하면 그에 맞는 구조체들을 만들어주는 것입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘3장 기본적인 도구’를 정리했습니다.</summary></entry></feed>