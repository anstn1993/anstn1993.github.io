<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://anstn1993.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://anstn1993.github.io/" rel="alternate" type="text/html" /><updated>2022-01-26T00:44:33+09:00</updated><id>https://anstn1993.github.io/feed.xml</id><title type="html">MunSooKim’s devlog</title><subtitle>일상, 회고, 개발 지식을 기록하기 위한 공간 입니다.</subtitle><entry><title type="html">성공과 실패를 결정하는 1%의 네트워크 원리 2장</title><link href="https://anstn1993.github.io/2022/01/25/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-2%EC%9E%A5.html" rel="alternate" type="text/html" title="성공과 실패를 결정하는 1%의 네트워크 원리 2장" /><published>2022-01-25T00:00:00+09:00</published><updated>2022-01-25T00:00:00+09:00</updated><id>https://anstn1993.github.io/2022/01/25/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1%25%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-2%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2022/01/25/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-2%EC%9E%A5.html">&lt;p&gt;Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘2장 TCP/IP의 데이터를 전기 신호로 만들어 보낸다’를 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;2장-tcpip의-데이터를-전기-신호로-만들어-보낸다&quot;&gt;2장. TCP/IP의 데이터를 전기 신호로 만들어 보낸다.&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;2장에서는 프로토콜 스택이 패킷을 생성하고 LAN 어댑터에 넘긴 후, LAN 어댑터가 패킷을 디지털 데이터에서 전기 신호로 변환해서 케이블에 송출하는 순간까지 탐험합니다.&lt;/p&gt;

&lt;h3 id=&quot;프로토콜-스택의-내부-구성&quot;&gt;프로토콜 스택의 내부 구성&lt;/h3&gt;

&lt;p&gt;프로토콜 스택이 무슨 일을 하는지 보기에 앞서 프로토콜 스택이 어떻게 구성되어있는지 보겠습니다. 프로토콜 스택은 &lt;strong&gt;TCP, UDP, IP&lt;/strong&gt;로 구성됩니다. 계층적으로 TCP, UDP가 IP보다 상위 계층으로, TCP, UDP가 애플리케이션에서 보낸 의뢰를 받아서 &lt;strong&gt;데이터의 송수신&lt;/strong&gt;을 담당하고, 그 아래의 IP 프로토콜을 사용해서 &lt;strong&gt;패킷의 송수신&lt;/strong&gt; 동작을 제어하게 됩니다. IP 안에는 ARP, ICMP 같은 프로토콜을 다루는 부분도 포함되어있는데, 자세한 건 뒤에서 살펴보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;소켓은-통신-제어용-제어-정보다&quot;&gt;소켓은 통신 제어용 제어 정보다&lt;/h3&gt;

&lt;p&gt;소켓은 프로토콜 스택이 통신 동작을 수행하기 위해서 필요한 제어 정보(수신처 IP 주소, 포트 번호, 통신 동작의 진행 상태 등..)를 의미합니다. 혹은 이런 제어 정보를 저장하는 프로토콜 스택 내부의 메모리 영역이 소켓이라고 생각해도 무방합니다. 프로토콜 스택은 이 소켓의 정보를 참조하면서 동작합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;netstat&lt;/code&gt; 커맨드를 사용하면 소켓의 내용을 살펴볼 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;netstat &lt;span class=&quot;nt&quot;&gt;-an&lt;/span&gt;
Active Internet connections &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;including servers&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Proto  Local Address          Foreign Address        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;state&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
tcp4  192.168.0.10.49809     142.251.42.206.443     ESTABLISHED
tcp4  192.168.0.10.49804     172.217.25.99.443      ESTABLISHED
tcp46  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.80                   &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;                    LISTEN
tcp46  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.443                  &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;                    LISTEN
tcp4   &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.3306                 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;                    LISTEN
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Local Address는 로컬 ip주소와 포트 번호를 표시하고 Foreign Address는 통신 상대의 ip주소와 포트 번호를 나타냅니다. 192.168.0.10라는 ip를 할당한 LAN 어댑터를 사용해서 원격측과 통신을 하고 있습니다. state가 ‘ESTABLISHED’인 것을 통해 원격측과 접속이 끝나고 통신을 하고 있음을 의미하고, 그 중에서도 로컬측의 포트번호가 49809번인 프로세스가 142.251.42.206 ip주소를 가진 상대측의 443번 포트를 사용하는 프로세스와 통신을 하고 있고 포트번호가 49804번인 프로세스가 172.217.25.99 ip 주소를 가진 상대측의 443번 포트를 사용하는 프로세스와 통신을 하고 있습니다.
state가 ‘LISTEN’인 경우는 아직 상대의 접속을 기다리고 있음을 의미합니다. 로컬측, 원격측의 ip주소가 명확히 지정되지 않은 이유는 아직 통신이 시작되지 않았기 때문입니다. 만약에 로컬 주소에 ip 주소를 지정해주면, 그건 해당 ip 주소의 LAN 어댑터로만 요청을 처리하겠다는 것을 의미합니다. 보통 복수의 LAN 어댑터를 장착하고 있는 서버에서 접속 동작을 특정 LAN 어댑터로만 제한하려고 할 때 사용합니다.&lt;/p&gt;

&lt;h3 id=&quot;프로토콜-스택이-하는-일&quot;&gt;프로토콜 스택이 하는 일&lt;/h3&gt;

&lt;p&gt;이제 애플리케이션이 소켓 라이브러리의 루틴을 호출했을 때 프로토콜 스택이 실제로 하는 일을 살펴봅니다.&lt;/p&gt;

&lt;h4 id=&quot;socket을-호출했을-때-프로토콜-스택이-하는-일&quot;&gt;socket()을 호출했을 때 프로토콜 스택이 하는 일&lt;/h4&gt;

&lt;p&gt;소켓의 제어 정보를 저장하기 위한 메모리 공간을 할당받습니다. 이 시점은 아직 송/수신 동작이 시작되지 않은 초기상태이기 때문에 제어 정보를 소켓의 메모리 영역에 기록해둡니다. 이렇게 소켓이 만들어지면 소켓 식별자인 디스크립터를 반환해줍니다.
애플리케이션은 이 디스크립터를 이후의 동작 의뢰시에 함께 전달해서 프로토콜 스택이 어떤 소켓에 대해서 작업을 해야할지 결정할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;connect를-호출했을-때-프로토콜-스택이-하는-일&quot;&gt;connect()를 호출했을 때 프로토콜 스택이 하는 일&lt;/h4&gt;

&lt;p&gt;만들어둔 소켓을 통신 대상 서버측 소켓에 접속합니다. 제어 정보를 의미하는 물리적 실체가 없는 소켓에 접속이라는 단어가 사용되어서 다소 모호하게 느껴진다면 접속 대신 ‘준비’라고 생각해도 좋습니다. 그럼 무엇을 준비해야 할까요? 크게 두가지가 있습니다.
하나는 클라이언트와 서버가 서로의 &lt;strong&gt;제어정보&lt;/strong&gt;를 교환하는 것입니다. 제어정보는 &lt;strong&gt;패킷의 헤더&lt;/strong&gt;를 의미합니다. 헤더는 실제 요청 데이터의 앞쪽에 붙는 정보로, TCP, IP, 이더넷의 제어정보가 순차적으로 붙게 됩니다. 이 헤더는 항상 고정되어있기 때문에 접속단계뿐만 아니라 데이터를 송/수신할 때, 연결을 끊을 때와 같이 클라이언트와 서버가 통신을 할 때는 항상 헤더에 명시된 정보를 토대로 이루어집니다. 접속단계에서는 아직 데이터의 송/수신이 이루어지지 않기 때문에 이때 주고받는 패킷은 헤더(제어정보)로만 이루어져있습니다. 프로토콜 스택이 처음에 소켓을 생성한 직후에는 통신 상대에 대한 정보가 존재하지 않습니다. 그래서 접속 단계에서 애플리케이션이 통신 대상에 대한 정보를 connect()의 인자로 함께 전달합니다. 그럼 프로토콜 스택은 제어정보(ip주소, 포트번호 등..)를 담은 헤더로만 구성된 패킷을 서버로 보내게 됩니다. 클라이언트의 제어정보를 받은 서버도 클라이언트의 정보를 알 수 있게 되고 비로소 통신을 할 준비가 끝나게 됩니다.
다른 하나는 송/수신하는 데이터를 일시적으로 저장할 버퍼 메모리를 확보하는 것입니다.
위 두가지 준비가 끝나면 접속이 됐다고 이해하면 됩니다.&lt;/p&gt;

&lt;p&gt;그럼 데이터의 송/수신을 위해 무엇을 준비해야하는지 알았으니 그 중에서도 클라이언트와 서버가 제어정보(헤더만으로 구성된 패킷)를 어떻게 교환하는지 구체적으로 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56672937/151005977-df270e91-1e6b-4bc6-8fa6-174c98a1c008.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;프로토콜 스택의 TCP가 데이터 송/수신 동작의 개시를 나타내는 제어 정보를 기록한 TCP 헤더를 생성합니다. 이 헤더에 세팅하는 주요 값들은 &lt;strong&gt;송신처(클라이언트)의 포트 번호&lt;/strong&gt;, &lt;strong&gt;수신처(서버)의 프토 번호&lt;/strong&gt;, 그리고 컨트롤 비트 중 &lt;strong&gt;SYN 비트를 1로&lt;/strong&gt; 설정합니다. SYN는 Sync의 약어로 상대방과 연결을 시작할 때 설정하는 비트입니다. 즉 연결을 통해 상대방과 동기화를 하겠다는 의미로 이해하면 됩니다. 사실 이때 헤더에 &lt;strong&gt;시퀀스 번호와 윈도우&lt;/strong&gt;라는 값도 함께 설정해서 보내게 되는데 이건 뒤에서 살펴보겠습니다. 이렇게 TCP가 만든 패킷을 IP에게 건네주면 송신 동작을 실행해서 서버로 패킷을 전달합니다. IP가 패킷을 송신하는 동작은 뒤에서 구체적으로 살펴보겠습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서버가 패킷을 받으면 서버의 프로토콜 스택의 IP가 패킷을 TCP로 전달해줍니다. 그럼 패킷의 헤더를 조사해서 수신처 포트번호를 보고 그 번호에 해당하는 소켓을 찾고 그 소켓에 클라이언트의 제어 정보를 기록하고 접속 동작이 진행중이라는 상태로 바뀝니다. 그리고 서버의 TCP가 클라이언트에 응답을 해주게 됩니다. 이때 TCP 헤더에 &lt;strong&gt;SYN 컨트롤 비트와 ACK 컨트롤 비트를 1로&lt;/strong&gt; 만듭니다. 서버도 클라이언트와 연결을 하겠다는 의미에서 &lt;strong&gt;SYN 비트를 시퀀스 번호, 윈도우와 함께 설정&lt;/strong&gt;합니다. ACK는 Acknowledgement의 약어로 클라이언트의 SYN 요청 패킷을 잘 전달받았고 그것을 승인하겠다 의미를 지닙니다. 이때 ACK 번호도 헤더에 함께 세팅해서 보내게 되는데 이는 뒤에서 살펴보겠습니다. 이렇게 세팅된 TCP 헤더를 IP에 전달하여 클라이언트에 응답하게 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;응답을 받은 클라이언트는 마찬가지로 IP에서 TCP로 패킷이 흘러가게 되고 서버측이 ACK 컨트롤 비트를 1로 설정했는지 확인해서 접속 동작이 성공했는지 확인합니다. 성공했으면 서버의 제어정보를 소켓에 저장하게 됩니다. 여기서 끝나지 않고, 클라이언트에서 서버쪽에 TCP 헤더의 &lt;strong&gt;ACK 컨트롤 비트를 1로&lt;/strong&gt; 세팅해서 ACK 번호와 함께 한 번 더 패킷을 응답합니다. 서버쪽에도 클라이언트가 패킷을 잘 받았음을 알리기 위함입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기까지가 접속 동작의 구체적인 플로우입니다. 접속 동작에서 클라이언트와 서버 사이에서 3번의 패킷이 오가는데 이런 연결 동작을 &lt;strong&gt;3-way-handshake&lt;/strong&gt;라고 합니다. 이제 서버와 클라이언트의 소켓은 데이터를 송/수신할 수 있는 상태입니다. 이런 걸 비유적인 표현으로 &lt;strong&gt;두 소켓이 파이프로 연결됐다&lt;/strong&gt;고 하기도 합니다. 저 파이프를 &lt;strong&gt;커넥션, 세션&lt;/strong&gt;이라고 하기도 합니다. 이는 네트워크에서 자주 등장하는 용어들이기 때문에 이런 용어들을 마주하면 양쪽의 소켓이 서로의 제어정보를 가지고 통신을 할 수 있는 상태라고 이해하면 될 것 같습니다.&lt;/p&gt;

&lt;h4 id=&quot;write를-호출했을-때-프로토콜-스택이-하는-일&quot;&gt;write()를 호출했을 때 프로토콜 스택이 하는 일&lt;/h4&gt;

&lt;p&gt;클라이언트가 서버에 접속했다면 이제 데이터를 송/수신해야 합니다. 먼저 송신을 위해 write()를 호출하면 프로토콜 스택은 전달받은 &lt;strong&gt;데이터를 송신용 버퍼 메모리에 저장하고 애플리케이션이 다음 데이터를 전달해주기를 기다립니다.&lt;/strong&gt; 바로 전달을 하지 않는 이유는 한번 패킷을 보낼 때 최대한 많은 양의 데이터를 담아서 보내기 위함입니다. 애플리케이션별로 프로토콜 스택에 전달하는 데이터의 길이는 저마라 다르기 때문에 어떤 애플리케이션은 전체 데이터를 한번에 전달할 수도 있고 어떤 애플리케이션은 1바이트씩 쪼개서 전달할 수도 있습니다. 이는 프로토콜 스택에서 제어할 수 없는 것입니다. 만약 전체 데이터를 너무 작은 단위로 쪼개서 송신 의뢰를 할 때 버퍼에 쌓아두지 않고 매번 실제로 패킷을 보내버리면 네트워크의 효율이 저하되기 때문에 기다리는 것입니다. 이때 프로토콜 스택은 한 패킷에 저장할 수 있는 데이터의 최대 크기인 MTU(Maximum Transmission Unit)라는 매개변수를 기준으로 실제 전송 동작을 수행할 타이밍을 잡습니다. 보통 이더넷에서는 1500바이트가 됩니다. 여기서 헤더를 제외해야 실제로 전송할 수 있는 데이터의 최대 크기가 나오는데 이것을 MSS(Maximum Segment Size)라고 합니다. 보통 TCP, IP 헤더를 합치면 40바이트가 되기 때문에 MSS는 일반적으로 1460바이트가 됩니다. 애플리케이션에게 받은 데이터의 크기가 MSS를 초과하거나 MSS에 가까운 크기가 됐을 때 송신 동작을 수행하면 효율이 높은 송신을 수행할 수 있는 것입니다.
하지만 데이터의 크기에만 의존해서 송신 동작을 수행할 타이밍을 잡으면 안 됩니다. 애플리케이션의 송신 속도가 느려서 MSS에 가깝게 데이터를 송신 버퍼에 쌓는 시간이 오래 걸릴 수도 있기 때문입니다. 그래서 프로토콜 스택은 내부적으로 &lt;strong&gt;타이머를 두고 일정 시간이 경과하면 데이터가 MSS에 미치지 못하더라도 패킷을 송신&lt;/strong&gt;합니다.
프로토콜 스택에는 이렇게 상충되는 송신 동작의 판단 요소를 적절하게 절충해서 송신 동작을 언제 수행할지 판단하게 됩니다. 이때 두 판단 요소를 어떻게 절충할지에 대한 명확한 규정이 없기 때문에 이는 전적으로 프로토콜 스택을 개발하는 개발자에게 달려있습니다.
이때 송신 타이밍을 애플리케이션이 제어하게 할 수도 있습니다. write()를 호출할 때 송신 버퍼에 쌓아두지 말고 바로 전송하라는 옵션을 전달하면 프로토콜 스택은 바로 송신 동작을 수행합니다. 보통 브라우저 같이 대화형 애플리케이션이 서버에 메시지를 보낼 때 버퍼에 머무는 시간만큼 응답 지연이 발생하기 때문에 이런 옵션을 많이 사용할 것입니다.&lt;/p&gt;

&lt;p&gt;그럼 반대로 데이터가 MSS를 초과하는 크기를 가진 경우는 어떻게 될까요? 이때는 MSS를 초과하기 때문에 바로 송신 동작에 들어가는데 데이터를 MSS 크기에 맞게 분할해서 송신 버퍼에 저장합니다. 그럼 분할된 각각의 데이터 조각들에 TCP 헤더를 붙이고 조각별로 IP에게 건네서 송신 동작을 수행합니다. 이때 조각화된 패킷들이 서버에 도착하면 그 패킷들의 데이터를 다시 완결된 형태로 합칠 수 있어야 합니다. 이렇게 조각화된 데이터를 합칠 수 있는 단서들은 IP 헤더에 기록되어있고 이는 뒤에서 자세히 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;TCP 통신은 데이터의 송신만 하고 끝나지 않습니다. 항상 상대방에게 송신한 패킷이 잘 도착했는지 &lt;strong&gt;확인하는 동작&lt;/strong&gt;을 수행해서 도착하지 않았으면 다시 송신해서 &lt;strong&gt;신뢰성을 보장&lt;/strong&gt;합니다. 이 확인 동작은 TCP 헤더의 &lt;strong&gt;시퀀스 번호&lt;/strong&gt;와 &lt;strong&gt;ACK 번호&lt;/strong&gt;를 통해서 하게 됩니다.
시퀀스 번호는 송신 데이터의 일련번호로 데이터 조각을 송신할 때 각 패킷의 맨 앞 위치의 데이터가 전체 데이터의 몇번째 바이트인지를 송신측에서 수신측으로 전달하기 위한 값입니다. ACK 번호는 수신 데이터의 일련번호로 수신측이 전체 데이터 중 몇바이트까지 수신했는지를 송신측에 전달하기 위한 값입니다. 구체적인 예로 살펴보겠습니다. 클라이언트에서 데이터를 1460바이트(MSS)로 조각화해서 여러 패킷을 전달한다고 가정하겠습니다. 그리고 초기 시퀀스 번호 1이라고 가정하겠습니다. 이 초기 시퀀스 값은 연결시점에 3-way-handshake에서 클라이언트가 SYN 컨트롤 비트를 1로 설정해서 패킷을 전송할 때 설정하게 됩니다. 참고로 이 시퀀스 번호는 항상 랜덤하게 생성됩니다. 시퀀스 번호가 고정되면 시퀀스 번호를 예측할 수 있게 되기 때문에 악의적인 공격이 발생할 수 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56672937/151006334-6a0b33d8-aae6-485e-87b4-84c5f029c322.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 클라이언트에서 시퀀스 번호를 1로 설정해서 서버로 첫번째 조각 패킷을 보내겠습니다. 그럼 서버는 데이터의 크기를 계산해서 1460바이트인 것을 확인하고 시퀀스 번호에 데이터 크기만큼 더한 1461로 ACK 번호를 세팅해서 클라이언트로 응답하게 됩니다.(ACK 컨트롤 비트도 1로 세팅) 이때 서버는 다음 패킷의 시퀀스 번호가 1461번일 것으로 기대하게 됩니다. 그럼 클라이언트는 다음 시퀀스 번호를 서버에게 받은 ACK 번호인 1461로 설정하고 다시 전송합니다. 그럼 서버는 ACK 번호를 시퀀스 번호에 데이터 크기만큼 더한 2921로 설정해서 응답합니다. 이렇게 응답측에서 ACK 번호를 돌려주는 것을 &lt;strong&gt;수신 확인 응답&lt;/strong&gt;이라고 합니다. 즉, 송신측의 시퀀스 번호와 응답측의 ACK 번호는 계속 동기화되는 것입니다. 이를 통해 패킷의 누락을 검출할 수 있습니다. 가령 서버가 응답한 ACK 번호가 1461인데 그 다음 전달된 패킷의 시퀀스 번호가 2921이면 패킷이 누락되었음을 알 수 있기 때문입니다.
지금까지 살펴본 과정은 클라이언트에서 서버로만 패킷을 전달하는 흐름만 고려한 것인데 사실 서버에서 클라이언트로 패킷을 전달하는 흐름에서도 이런 과정은 동일하게 일어납니다. 서버에서 클라이언트에게 응답 데이터를 생성해서 보내면 클라이언트도 마찬가지로 ACK 번호를 산출해서 서버에 전달하게 됩니다.&lt;/p&gt;

&lt;p&gt;그럼 시퀀스 번호와 ACK 번호를 중점으로 클라이언트와 서버의 연결부터 데이터 송/수신을 다시 한번 살펴보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;연결 동작&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;클라이언트는 SYN비트를 1로 설정하고 시퀀스 번호 초기값을 서버에 전송&lt;/li&gt;
      &lt;li&gt;서버는 SYN, ACK 비트를 1로 설정하고 ACK 번호와 시퀀스 번호 초기값을 클라이언트로 전송&lt;/li&gt;
      &lt;li&gt;클라이언트는 ACK 비트 1로 설정하고 ACK 번호를 서버로 전송&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;송/수신 동작&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;클라이언트는 서버로 데이터와 함께 시퀀스 번호를 전송&lt;/li&gt;
      &lt;li&gt;서버는 ACK 번호를 클라이언트로 전송&lt;/li&gt;
      &lt;li&gt;서버는 응답 데이터와 함께 시퀀스 번호를 전송&lt;/li&gt;
      &lt;li&gt;클라이언트는 ACK 번호를 서버로 전송&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이처럼 클라이언트건, 서버건 서로가 보낸 패킷의 시퀀스 번호를 확인하고 ACK 번호를 반환합니다. 이때 클라이언트, 서버 모두 &lt;strong&gt;ACK 번호를 확인하기 전까지는 송신용 버퍼 메모리에 송신한 패킷을 보관&lt;/strong&gt;합니다. 송신한 데이터에 대응하는 ACK 번호가 돌아오지 않으면 동일한 패킷을 다시 보내기 위함입니다. TCP는 이런 방식으로 신뢰성을 보장합니다. 그리고 TCP의 이런 동작 덕분에 LAN 어댑터, 버퍼, 라우터, 애플리케이션 모두 오류가 발생해도 회복 조치를 취하지 않습니다.&lt;/p&gt;

&lt;p&gt;TCP가 오류를 검출하고 회복하는 과정을 좀 더 구체적으로 살펴보겠습니다. 가장 중요한 것은 ACK 번호가 돌아오는 것을 기다리는 대기시간(타임아웃)을 적절하게 설정하는 것입니다. 네트워크가 혼잡한 상황이면 ACK 번호 응답이 지연되기 때문에 대기시간을 넉넉하게 잡아야 합니다. 그렇지 않으면 ACK 번호가 돌아오기 전에 패킷을 다시 보내게 됩니다. 이는 불필요한 패킷 전송으로 인해 네트워크를 더 혼잡하게 만듭니다. 하지만 반대로 대기시간이 너무 길어도 정말 패킷을 다시 보내야 하는 상황에서 패킷을 다시 보내는 동작에 지연이 발생합니다. 하지만 서버와 클라이언트의 거리, 네트워크의 혼잡도 등의 다양한 변수 때문에 적절한 대기시간을 정하는 것은 매우 어려운 일입니다. 그래서 TCP는 대기시간을 동적으로 변경하는 전략을 취하고 있습니다. TCP는 데이터 송신 동작을 할 때 항상 ACK 번호가 돌아오는 시간을 항상 기록해두고, ACK 번호가 돌아오는 시간이 기록해둔 시간보다 지연되면 대기 시간도 늘리게 됩니다. 반대로 더 빨리 도착하면 대기시간을 짧게 설정합니다.&lt;/p&gt;

&lt;p&gt;TCP는 윈도우 제어를 통해 ACK 번호가 돌아올 때까지 기다리는 시간 낭비를 줄입니다. 윈도우 제어 방식은 응답측에서 ACK 번호를 받기 전까지 기다리지 않고 보내야 하는 패킷을 계속 보내게 됩니다. 아주 효율적인 방식이지만 &lt;strong&gt;송신측의 패킷 전송 속도가 수신측의 수신 버퍼 처리 속도보다 빨라져서 수신 버퍼의 용량이 초과&lt;/strong&gt;하는 문제가 발생할 수 있습니다. 이 문제를 해결하기 위해서 &lt;strong&gt;TCP 헤더의 윈도우 필드&lt;/strong&gt;를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56672937/151006561-f90a964e-c265-4717-a045-04cafbb2449c.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;윈도우 필드는 수신측의 수신 버퍼의 여유 공간을 담습니다. 수신측이 송신측에 수신 가능한 데이터의 양을 윈도우 필드에 세팅해서 통지하면 송신측은 수신측 버퍼에 공간이 얼마나 남았는지 알고, 자신이 패킷을 보낼때마다 데이터의 크기도 알기 때문에 스스로 계산을 해서 수신측 버퍼의 여유공간이 0이 되는 순간에 송신을 중단하게 됩니다. 수신측은 수신처리가 끝나서 수신 버퍼에 여유 공간이 생기면 다시 윈도우 필드를 세팅해서 송신측에 알리게 되고 송신측은 다시 패킷을 전송하기 시작합니다. 이렇게 해서 수신 버퍼의 용량 초과 없이 데이터를 전송할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;그런데 수신측의 입장에서 한가지 고려해야 할 것이 있습니다. 위의 그림에서는 수신측이 송신측에 윈도우 통지를 하는 플로우만 표현했지만 사실 송신측으로부터 받은 패킷에 응답하는 ACK 번호 통지도 함께 일어나게 됩니다. 그럼 효율성을 높이려면 왼도우와 ACK번호를 통지하는 타이밍을 잘 잡아야 합니다. 윈도우가 송신측으로 통지되는 타이밍은 수신측에서 애플리케이션에 데이터를 건네주고 수신 버퍼의 빈 영역이 늘어났을 때입니다. ACK 번호가 송신측으로 통지되는 타이밍은 데이터를 받았을 때 내용을 조사해서 정상 수신을 확인할 수 있는 경우 입니다. 다시 말해 데이터를 수신한 후 즉시 보내게 됩니다. 개념적으로만 보면 ACK 번호를 먼저 통지하고, 애플리케이션에 데이터를 전달해준 후 윈도우를 통지하는 게 맞지만, 이 둘을 따로따로 통지하는 건 비효율적입니다. 그래서 ACK 번호나 윈도우를 통지할 때 바로 보내지 않고 잠시 기다렸다가 다음 통지가 발생할 때 두 통지를 하나의 패킷으로 묶어서 보냅니다. 예를 들면 ACK번호 송신 대조를 하는 시점에 윈도우 통지도 발생하면 ACK번호와 윈도우를 하나의 패킷으로 묶어서 보내주는 것입니다. 또한 ACK 번호 통지가 연속해서 일어난 경우에도 마지막 통지만 해주면 됩니다. 윈도우 통지도 마찬가지입니다. 애플리케이션에 데이터를 전달하는 동작이 여러번 일어난다 하더라도 가장 마지막 통지 시점에 수신 버퍼 크기만 알려주면 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;read를-호출했을-때-프로토콜-스택이-하는-일&quot;&gt;read()를 호출했을 때 프로토콜 스택이 하는 일&lt;/h4&gt;

&lt;p&gt;애플리케이션이 write()로 송신 동작을 의뢰했으면 read()를 호출하여 응답 메세지 수신을 프로토콜 스택에 의뢰합니다. 수신 데이터는 앞서 살펴본 수신 버퍼에 쌓이게 됩니다. 송신을 하자마자 수신이 되지는 않기 때문에 프로토콜 스택은 수신버퍼에 데이터가 쌓일 때까지 대기를 합니다. 대기를 하는동안 프로토콜 스택은 다른 작업을 수행하다가 패킷이 도착하면 작업을 다시 시작합니다. 수신한 데이터 조각과 TCP 헤더의 내용(시퀀스 번호와 ACK 번호)을 조사해서 데이터 누락이 되지 않았는지 검사합니다. 문제가 없으면 ACK 번호를 반송합니다. 그리고 데이터 조각은 수신 버퍼에 TCP가 설정한 시간만큼 보관하고 쌓인 조각들을 복원하여 애플리케이션에 건내줍니다. 이후 통지 타이밍을 가늠해서 윈도우를 송신측에 통지합니다.&lt;/p&gt;

&lt;h4 id=&quot;close를-호출했을-때-프로토콜-스택이-하는-일&quot;&gt;close()를 호출했을 때 프로토콜 스택이 하는 일&lt;/h4&gt;

&lt;p&gt;송/수신 동작까지 끝나면 애플리케이션은 close()를 호출하여 프로토콜 스택에게 연결 끊기 동작에 들어가게 됩니다. 연결 끊기 동작은 송신을 완료한 쪽에서 하게 됩니다. 어디에서 송신을 완료하는지는 애플리케이션마다 다르지만 웹의 경우에는 서버가 요청에 응답하면서 데이터의 송신이 완료되기 때문에 서버에서 연결 끊기에 들어갑니다. 그런데 이건 HTTP 1.0에 해당하는 내용이고 HTTP 1.1에서는 클라이언트가 하나의 소켓으로 계속해서 요청 메시지를 보낼 수 있기 때문에 더 이상 보낼 요청이 없다고 판단하는 순간 클라이언트에서 먼저 끊기 단계에 돌입할 수도 있습니다. 이 장에서는 서버가 연결 끊기를 시작하는 것으로 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56672937/151006774-b254bf09-f6fd-4a71-93b6-5d45e76908cb.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서버측의 프로토콜 스택이 TCP 헤더의 FIN 컨트롤 비트를 1로 세팅하고 IP에게 클라이언트로 송신을 의뢰합니다. 동시에 소켓에 연결 끊기 동작에 들어갔다는 정보를 기록하게 됩니다. 패킷을 받은 클라이언트의 프로토콜 스택은 서버측의 TCP 헤더를 확인하고 자신의 소켓에 서버측이 연결 끊기 동작에 들어갔음을 기록합니다. 서버의 연결 끊기를 잘 수신했음을 통지하기 위해 ACK 번호를 서버에 통지하고 애플리케이션이 read()를 호출하여 데이터를 가지러 올 때까지 기다립니다. read()가 호출되면 데이터 수신을 완료했다는 사실을 애플리케이션에게 알립니다. 그럼 애플리케이션도 close()를 호출하고 프로토콜 스택은 서버와 같이 TCP 헤더에 FIN 비트를 1로 세팅하고 IP에 의뢰해서 서버로 송신합니다. 서버에서 ACK 번호가 돌아오면 끝입니다.&lt;/p&gt;

&lt;p&gt;상대와의 연결이 끊기면 소켓을 말소하게 됩니다. 이때 &lt;strong&gt;오작동을 막기 위해 바로 말소하지 않고 좀 기다린 후 말소&lt;/strong&gt;하게 됩니다. 오작동이 일어나는 한 가지 케이스를 살펴보겠습니다. 연결 끊기를 클라이언트에서 먼저 시작하면 마지막에 서버의 연결 끊기 통지에 대한 ACK 번호를 보낼 건데 이 마지막 ACK 번호가 잘 가지 않았다고 가정해보겠습니다. 그럼 서버에서는 다시 FIN 비트를 세팅해서 송신을 할 건데 이때 클라이언트 소켓이 말소되어있고, 직전에 다른 애플리케이션에 대해서 동일한 포트 번호로 소켓이 만들어진 상태면 그 애플리케이션의 소켓에 FIN이 도착하게 되어서 그 애플리케이션의 소켓이 바로 종료 동작을 수행하는 오작동을 일으키게 됩니다. 이런 이유로 소켓을 바로 말소시키지 않고 기다리는 것입니다. 이때 기다리는 시간은 패킷을 다시 보내는 동작이 지속되는 시간을 기준으로 판단합니다. 패킷을 다시 보내는 동작은 몇분 정도 계속되고 그 시간이 모두 경과하면 회복 불가로 판단하여 보내기 동작을 멈춥니다. 하지만 기존에 다시 보낸 패킷들이 네트워크에 존재할 가능성이 있기 때문에 다시 보내기 동작이 완전히 끝나는 시간만큼은 기다리는 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;프로토콜-스택의-ip는-패킷을-만들어서-상대에게-송신한다&quot;&gt;프로토콜 스택의 IP는 패킷을 만들어서 상대에게 송신한다&lt;/h3&gt;

&lt;p&gt;앞서 TCP가 실제로 패킷을 송신하기 위해서는 IP에 의뢰해야 한다는 것을 알게 됐습니다. 그럼 실제로 어떻게 패킷을 상대에게 송신하는지 살펴보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;패킷이란&quot;&gt;패킷이란&lt;/h4&gt;

&lt;p&gt;그 전에 패킷에 대해서 알아보겠습니다. 패킷은 실제로 네트워크를 통해서 주고받는 데이터 그 자체입니다. 패킷은 크게 &lt;strong&gt;헤더와 데이터(페이로드)로 구성&lt;/strong&gt;됩니다. 앞서 많이 살펴봤지만 헤더는 통신에 필요한 여러 제어 정보를 담고 있습니다. 이 헤더의 앞에는 하위 계층의 헤더가 계속 붙게 되는데 예를 들면 데이터에 TCP 헤더가 붙고나면 그 앞에는 IP 헤더, 그리고 그 앞에는 MAC 헤더가 붙게 됩니다. 이처럼 상위 계층 프로토콜에서 하위 계층 프로토콜 계층으로 내려오면서 헤더를 하나씩 붙이는 과정을 &lt;strong&gt;캡슐화&lt;/strong&gt;라고 합니다. 실제로 패킷은 상위 계층에서 하위 계층으로 내려오면서 캡슐화를 통해 완성됩니다.&lt;/p&gt;

&lt;p&gt;완성된 패킷은 중계장치(허브, 라우터..)에 송신됩니다. 각 중계장치들은 패킷의 목적지(수신처)가 어느 방향에 있는지에 대한 정보를 기록한 테이블을 가지고 있습니다. 그리고 중계장치는 자신의 계층에 해당하는 헤더까지 &lt;strong&gt;디캡슐화&lt;/strong&gt;를 하여 헤더에 기록된 수신처와 테이블의 데이터를 통해 어떤 케이블로 패킷을 전송할지 결정하게 됩니다. 예를 들면 L2장비인 허브는 2계층인 이더넷 프로토콜 헤더까지 디캡슐화를 하고 L3 장비인 라우터는 3계층인 IP 프로토콜 헤더까지 디캡슐화하여 제어정보를 취득하게 됩니다. 즉 허브는 MAC 헤더의 맥 주소를 보고 패킷을 서브넷 내에서 이동시키고, 라우터는 IP 헤더의 ip 주소를 보고 패킷을 다음 라우터로 전달합니다.&lt;/p&gt;

&lt;p&gt;이 동작을 좀 더 구체적으로 서술해보자면, 수신처 ip 주소를 확인해서 어느 방향에 있는지 조사하고 그 방향에 있는 다음 라우터를 조사하여 그 라우터의 맥 주소를 MAC 헤더의 수신처 맥 주소로 기록합니다. 그리고 그 라우터에 패킷을 보내도록 이더넷에 의뢰합니다. 패킷을 받은 이더넷은 허브로 패킷을 전송합니다. 패킷을 받은 허브는 앞서 말한 것처럼 MAC 헤더까지 디캡슐화를 해서 수신처 맥 주소(다음 라우터의 맥 주소)를 보고 자신이 관리하는 테이블에 기록된 정보와 결합하여 패킷의 다음 목적지를 중계합니다. 만약 서브넷 내의 허브가 여러 개라면 순차적으로 경유하여 라우터에 도착합니다. 라우터는 ip 헤더까지 디캡슐화를 하고 자신의 테이블 정보와 결합하여 중계해줄 다음 라우터를 결정합니다. 그럼 그 라우터의 맥 주소를 조사해서 그것을 다시 MAC 헤더의 수신처 맥 주소로 갱신해줍니다. 그럼 다시 허브를 타면서 다음 라우터에 도착하는 과정이 반복되고, 수신처까지 도착을 하게 됩니다.&lt;/p&gt;

&lt;p&gt;잘 살펴보면 &lt;strong&gt;이더넷 프로토콜(2계층)은 같은 네트워크 대역 내의 장비로 패킷을 전달하기 위한 역할&lt;/strong&gt;을 수행하고, &lt;strong&gt;ip 프로토콜(3계층)은 서로 다른 네트워크 대역으로 패킷을 전달하기 위한 역할&lt;/strong&gt;을 수행합니다.&lt;/p&gt;

&lt;h4 id=&quot;ip의-패킷-송수신-동작&quot;&gt;IP의 패킷 송수신 동작&lt;/h4&gt;

&lt;p&gt;이제 프로토콜 스택의 IP가 하는 일을 구체적으로 살펴보겠습니다. 먼저 TCP가 IP에게 패킷 송신을 의뢰하는 지점부터 시작해야겠군요. TCP는 TCP 헤더를 추가한 패킷을 IP에 전달합니다. 그리고 IP는 IP 헤더와 MAC 헤더를 순차적으로 붙이게 됩니다. IP의 역할은 이렇게 완성한 패킷을 LAN 어댑터로 전달하는 것이 끝입니다. 반대로 상대로부터 패킷을 받은 경우에는 LAN 어댑터가 IP에게 패킷을 건네주고 TCP 헤더와 데이터를 TCP에게 건내주게 됩니다.&lt;/p&gt;

&lt;p&gt;먼저 IP 헤더를 만드는 과정을 살펴보겠습니다. IP 헤더에는 수신처와 송신처의 IP 주소가 들어갑니다. 수신처 IP 주소는 애플리케이션이 접속동작을 TCP에 의뢰하면서 전달한 상대측 IP 주소를 TCP가 IP에 그대로 전달하는 것입니다. 그래서 그것이 잘못된 주소이더라도 IP주소는 그냥 그 주소로 세팅을 해서 보내게 됩니다. 이에 대한 잘못된 동작은 애플리케이션의 책임으로 간주합니다.
송신처 IP 주소는 LAN 어댑터에 할당된 IP 주소로 세팅하게 됩니다. 만약 LAN 어댑터가 여러 개 장착된 경우라면 어떤 어댑터의 IP로 설정할지를 판단해야 하는데, 그것은 어떤 라우터로 보내야할지를 통해 결정할 수 있습니다. 그 방법은 라우터에서 라우팅 테이블로 다음 라우터를 결정하는 것과 동일합니다. IP용 표를 라우팅 테이블이라고 하는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;route print&lt;/code&gt; 커멘드로 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;route print
Network Destination  Netmask           Gateway           Interface         Metric
0.0.0.0              0.0.0.0           125.129.69.254    125.129.69.101    20
125.129.69.0         255.255.255.0     125.129.69.101    125.129.69.101    20
125.129.69.101       255.255.255.255   127.0.0.1         127.0.0.1         20
125.255.255.255      255.255.255.255   125.129.69.101    125.129.69.101    20
127.0.0.0            255.0.0.0         127.0.0.1         127.0.0.1         1
224.0.0.0            240.0.0.0         125.129.69.101    125.129.69.101    20
255.255.255.255      255.255.255.255   125.129.69.101    125.129.69.101    1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Network Destination은 패킷의 최종 목적지로 수신처 IP를 이 행과 비교해서 대상 행을 찾습니다. Interface는 LAN 어댑터 등의 네트워크 인터페이스를 나타냅니다. ‘125.129.69.101’이 LAN 어댑터에 할당된 ip입니다. Gateway는 다음 중계 라우터 주소가 됩니다. 다음 라우터에서 패킷을 받으면 그 라우터는 마찬가지로 라우팅 테이블을 조회하여 다음으로 중계해줄 라우터를 찾게 됩니다. 만약 Interface와 Gateway가 같으면 이때는 라우터로 중계하지 않고 상대에게 직접 패킷을 전할 수 있음을 의미합니다. 예를 들어 Gateway, Interface가 ‘125.129.69.101’로 동일한 행의 목적지 주소인 ‘125.129.69.0’으로는 패킷을 바로 전달할 수 있음을 의미합니다. 최상단에는 목적지와 넷마스크가 ‘0.0.0.0’으로 등록되어있는데 이는 &lt;strong&gt;기본 게이트웨이&lt;/strong&gt;라고 합니다. 다른 행에 일치하는 항복이 없으면 이 행에 해당하는 것으로 간주합니다. 바로 이 테이블을 보고 &lt;strong&gt;어떤 LAN 어댑터에서 패킷을 내보낼지 결정하고 그 LAN 어댑터에 할당된 주소로 송신처 IP 주소를 결정&lt;/strong&gt;하게 됩니다.
IP 헤더에는 프로토콜 번호라는 필드에도 값을 설정합니다. 이 필드에는 상위 계층의 헤더가 어떤 프로토콜인지 지정합니다. 다르게 말하면 어디로부터 의뢰가 되었는지를 명시하는 것이기도 합니다. 예를 들어 TCP로부터 의뢰를 받았다면 06, UDP로부터 의뢰를 받았으면 17이 됩니다.&lt;/p&gt;

&lt;p&gt;이제 MAC 헤더를 만드는 과정을 살펴보겠습니다. MAC 헤더에는 송신측 LAN 어댑터의 MAC 주소와 수신측 MAC 주소를 담습니다. 그리고 IP 헤더와 마찬가지로 상위 계층의 프로토콜 타입을 이더 타입이라는 필드에 세팅합니다. 보통 이 이더 타입에는 IP(0800)나 ARP(0806) 프로토콜이 들어갑니다. 송신측 MAC 주소는 LAN 어댑터 내부의 ROM이라는 공간에 기록되어 있어서 여기서 읽어들이게 됩니다. 이미 IP 헤더를 작성하는 과정에서 어떤 LAN 어댑터로 패킷을 내보낼지 결정된 상태이기 때문에 그 어댑터에서 읽어들이면 됩니다. 그럼 수신측 MAC 주소는 어떻게 지정할 수 있을까요? 바로 ARP(Address Resolution Protocol)를 통해서 지정하게 됩니다. 이더넷에는 연결된 모든 노드에게 패킷을 전달하는 브로드캐스트라는 구조가 존재합니다. ARP 헤더는 송신측과 수신측의 IP, MAC 주소를 모두 담습니다. 이때 수신측의 IP주소는 다음 중계 라우터의 IP 주소(Gateway)를 입력하고 MAC주소는 알지 못하기 때문에 0으로만 채워둡니다. 그리고 MAC 헤더의 수신측 MAC 주소를 브로드캐스트(FF.FF.FF.FF.FF.FF)로 설정해서 패킷을 내보내면 패킷을 받은 모든 노드들은 MAC 헤더의 브로드캐스트 주소를 보고 모든 노드들에게 보낸 패킷이라는 것을 알고 패킷을 확인하게 됩니다. 그리고 ARP 헤더의 수신처 IP 주소를 확인해서 자신에게 온 패킷임을 확인했으면 ARP 헤더에 자신의 MAC 주소를 채워서 응답하게 됩니다. 그럼 비로소 수신측의 MAC 주소까지 알게 되어 MAC 헤더도 완성됩니다. 그런데 패킷을 보낼 때마다 ARP 동작을 수행하면 비효율적이기 때문에 한번 조회한 MAC 주소는 ARP 캐시라는 메모리에 보관합니다. 그래서 먼저 ARP 캐시에서 목적지 IP에 대한 MAC 주소가 있는지 확인하고 없는 경우에만 ARP 패킷을 전송합니다. 이때 ARP 캐시에 특정 노드의 MAC 주소를 저장했는데 이후 그 노드의 MAC 주소가 변경되어 캐시에 있는 MAC 주소가 유효하지 않은 문제가 발생할 수 있기 때문에 ARP 캐시에 저장된 값은 일정 시간이 경과하면 삭제하게 되어있습니다.
이렇게 완성된 패킷은 LAN 어댑터로 전달하게 됩니다. 여기까지가 프로토콜 스택의 IP의 역할입니다.&lt;/p&gt;

&lt;h3 id=&quot;lan-어댑터의-역할&quot;&gt;LAN 어댑터의 역할&lt;/h3&gt;

&lt;p&gt;LAN 어댑터는 IP로부터 받은 &lt;strong&gt;디지털 데이터인 패킷을 전기나 빛의 신호로 변환하여 네트워크 케이블로 송출&lt;/strong&gt;하는 역할을 수행합니다. LAN 어댑터는 LAN 어댑터 제조사에서 제공하는 LAN 드라이버 소프트웨어가 제어하게 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;lan-어댑터의-구성요소&quot;&gt;LAN 어댑터의 구성요소&lt;/h4&gt;

&lt;p&gt;LAN 어댑터의 동작을 살펴보기 전에 어떻게 구성되어있는지 먼저 살펴보겠습니다. LAN 어댑터에는 버퍼 메모리, MAC 회로, PHY(MAU) 회로, RJ-45 커넥터, ROM 등으로 구성되어 있습니다. LAN 어댑터는 전원이 공급되면 다른 하드웨어들처럼 초기화 작업이 필요합니다. 그 동작을 LAN 드라이버가 수행합니다. LAN 어댑터의 MAC 주소는 ROM에 저장됩니다. 여기서 MAC 주소를 읽어서 MAC 회로에 설정하게 됩니다. MAC 회로는 이더넷의 송/수신 동작을 제어합니다. 다른 구성요소들은 실제로 LAN 어댑터의 동작을 살펴보면서 더 보도록 하겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;ip로부터-전달받은-패킷에-3개의-제어용-데이터를-추가한다&quot;&gt;IP로부터 전달받은 패킷에 3개의 제어용 데이터를 추가한다&lt;/h4&gt;

&lt;p&gt;프로토콜 스택의 IP로부터 패킷을 받으면 우선 LAN 어댑터의 버퍼 메모리로 복사해둡니다. 그리고 MAC 회로에 패킷 송신 명령을 보내면 MAC 회로 버퍼 메모리에서 패킷을 읽어서 3개의 데어터를 붙이게 됩니다. 하나는 패킷의 맨 앞에 붙는 &lt;strong&gt;프리앰블&lt;/strong&gt;입니다. 프리앰블은 수신측이 계속해서 흐르는 전기 신호 속에서 송신측으로부터 받은 패킷을 읽기 시작할 타이밍을 잡게 할 수 있게 도움을 주기 위한 데이터 입니다. 프리앰블은 ‘10101010..’같이 1, 0이 번갈아 나타나는 56비트 데이터 입니다. 이 비트 패턴을 신호로 바꾸면 파형이 일정한 모습이 되고 수신측에서 이 일정한 파형을 통해 패킷을 읽을 준비를 해야함을 알게 됩니다. 다음은 프리앰블 바로 뒤에 오는 &lt;strong&gt;스타트 프레임 딜리미터&lt;/strong&gt;입니다. 이 데이터는 ‘101010….11’와 같이 1과 0이 반복되다가 마지막에 ‘11’로 끝이납니다. 수신측은 저 ‘11’로 끝나는 지점을 통해서 패킷의 시작점을 파악할 수 있게 됩니다. 즉 스타트 프레임 딜리미터는 패킷의 시작지점을 캐치할 수 있게 하기 위한 데이터가 됩니다. 나머지 하나는 패킷의 맨 뒤에 붙는 &lt;strong&gt;FCS&lt;/strong&gt;라는 데이터 입니다. 이 데이터는 패킷이 네트워크를 타고 전달되는 과정에서 잡음 등의 영향으로 파형이 흐트러져 데이터가 손상된 경우 검출을 하기 위해 사용합니다. 이 값은 패킷의 맨 앞부터 맨 끝까지의 내용을 어떤 계산식을 이용해서 도출한 32비트의 비트열입니다. 그래서 패킷 데이터의 값이 1비트라도 변하면 계산한 결과도 달라진 값이 됩니다. 수신측은 전달받은 패킷을 계산식을 토대로 계산한 결과와 FCS의 값과 비교를 해서 데이터 손상 여부를 파악합니다.&lt;/p&gt;

&lt;h4 id=&quot;허브를-향해서-패킷을-송신한다&quot;&gt;허브를 향해서 패킷을 송신한다&lt;/h4&gt;

&lt;p&gt;앞서 언급한 3개의 데이터를 패킷에 부가했으면 이제 패킷을 허브로 송신하게 됩니다. 이때 리피터 허브일 때는 반이중 모드, 스위칭 허브일 때는 전이중 모드로 동작하는데 먼저 반이중 모드부터 살펴보겠습니다.
반이중 모드는 동시에 송신과 수신을 할 수 없습니다. LAN 어댑터의 PHY(MAU)는 케이블에 다른 기기가 송신한 신호가 흐르고 있는지 확인하고 신호가 흐르고 있으면 끝날 때까지 기다립니다. 만약 송신하고 있는 신호가 있는데 송신동작을 시작하면 충돌이 발생합니다. 그리고 신호가 흐르고 있지 않으면 송신 동작을 시작합니다. 송신 동작은 먼저 &lt;strong&gt;MAC 회로가 프리앰블의 맨 앞부터 1비트씩 차례로 디지털 데이터를 신호로 변환하고 PHY 혹은 MAU라는 송/수신 신호 부분에 보냅니다.&lt;/strong&gt; 이때 디지털 데이터를 신호로 변환하는 속도가 전송 속도가 됩니다. 1초에 10메가비트 분량의 디지털 데이터를 신호로 변환하여 보내면 10메가비트/초 전송률이 됩니다. 그럼 &lt;strong&gt;PHY는 다시 이 신호를 실제 케이블에 송출하는 형식으로 변환해서 송신&lt;/strong&gt;을 합니다. MAC에서 한번, PHY에서 한번 신호를 변환하는 절차를 2번으로 나눈 이유는 PHY는 여러 신호 형식의 종류에 구애받지 않고 공통 형식의 신호로만 변환해서 송신을 할 수 있게 하기 위함입니다. 이렇게 PHY가 송신을 완료할 때까지 수신 신호선에 신호가 들어오지 않으면 송신 동작은 끝납니다. 그런데 신호를 송신하는데 적은 확률로 복수의 기기가 송신 동작에 들어가서 수신 신호가 흘러들어오는 경우가 있습니다. 이렇게 신호가 충돌하게 되면 송신을 계속 해도 의미가 없기 때문에 송신 중단을 하고 충돌 사실을 다른 기기에 통지하기 위해 &lt;strong&gt;재밍 신호&lt;/strong&gt;라는 특수한 신호를 잠시 흘리고 일정 시간 대기했다가 다시 송신 동작을 수행합니다. 이때 모든 기기의 대기 시간이 동일하면 다시 출돌이 일어나기 때문에 대기 시간은 기기들의 MAC 주소를 바탕으로 난수를 생성해서 계산하도록 고안되어 있습니다. 그런데도 이더넷의 혼잡으로 다시 충돌이 발생하면 대기 시간을 2배로 늘리고 다시 보내게 됩니다. 그렇게 열번까지 재시도가 일어나게 되었는데도 해결이 안 되면 오류로 판단합니다.
전이중 모드는 송신과 수신의 충돌이 일어나지 않기 때문에 반이중모드처럼 충돌에 대한 고민을 할 필요가 없습니다. 리피터, 스위칭 허브에 대한 내용은 3장에서 더 자세하게 살펴봅니다.&lt;/p&gt;

&lt;h4 id=&quot;lan-어댑터의-패킷-수신&quot;&gt;LAN 어댑터의 패킷 수신&lt;/h4&gt;

&lt;p&gt;패킷의 수신은 앞서 살펴본 송신과 반대로 일어난다고 이해하면 됩니다. 리피터 허브의 반이중 동작을 기준으로 살펴보겠습니다. 앞서 살펴봤듯이 이더넷에서는 1대가 송신을 하면 같은 허브에 접속된 모든 케이블로 신호가 흘러갑니다. 이렇게 신호를 받은 기기들은 패킷의 맨 앞에 붙은 프리앰블을 통해 파형을 계산하고 스타트 프레임 딜리미터가 나오면 그 다음 비트부터 PHY 회로에서 신호를 공통 형식 신호로 변환해서 MAC 회로로 보내고, MAC 회로에서 신호를 차례로 디지털 데이터로 변환합니다. 그리고 신호의 마지막에 다다르면 FCS를 검사합니다. 여기까지 통과하면 MAC 헤더의 수신처 MAC 주소를 조사해서 MAC 회로에 설정된 주소와 비교해서 자신에게 온 것인지 확인합니다. 이때 자신에게 온 것이 아니면 패킷을 폐기하고, 자신에게 온 것이면 버퍼 메모리에 저장합니다. MAC 회로가 일을 끝마치면 패킷 수신 사실을 컴퓨터 본체에 통지합니다.
통지는 인터럽트를 통해서 하게 됩니다. LAN 어댑터는 확장 버스 슬롯에 있는 인터럽트용 신호선에 신호를 보냅니다. 이 신호선은 컴퓨터 본체의 인터럽트 컨트롤러를 통해 CPU에 연결되어 있고, 신호를 받으면 CPU는 하던 작업을 보류하고 OS 내부의 인터럽트 처리용 프로그램으로 전환합니다. 여기서 LAN 드라이버가 호출되어서 LAN 어댑터를 제어하면서 송/수신 동작을 실행합니다.
LAN 어댑터의 버퍼 메모리에서 수신 패킷을 추출하면 LAN 드라이버는 MAC 헤더의 타입 필드 값을 통해서 상위 계층 프로토콜을 판별합니다. 그리고 프로토콜 스택의 해당 프로토콜 담당 부분에 패킷을 전달해줍니다.(보통 IP, TCP)&lt;/p&gt;

&lt;h3 id=&quot;프로토콜-스택-tcpip의-수신-동작&quot;&gt;프로토콜 스택 TCP/IP의 수신 동작&lt;/h3&gt;

&lt;p&gt;LAN 어댑터에게 건네받은 패킷을 프로토콜 스택의 IP, TCP가 어떻게 처리하는지 정리해보겠습니다. IP담당은 IP 헤더의 포맷에 문제가 없는지 확인하고, 수신처 IP 주소를 확인합니다. 만약 현재 기기가 라우터 같은 중계 장비가 아닌 클라이언트(엔드 노드)인 경우라면 수신처 IP가 자신의 IP와 다르다면 오류로 간주합니다. 클라이언트가 패킷 중계를 할 일은 없기 때문입니다. 그래서 이럴 때는 &lt;strong&gt;ICMP&lt;/strong&gt;를 통해 상대에게 오류 통지를 하게 됩니다. 다양한 오류 케이스를 통지할 수 있는데 이 경우에는 Destination unreachable 메시지를 통지합니다. IP 주소까지 올바르면 IP 담당은 &lt;strong&gt;조각화된 패킷을 원래의 모습으로 합치는 리어셈블링 작업&lt;/strong&gt;을 수행합니다. 리어셈블링에 필요한 정보는 ip 프로토콜 헤더에 기록되어있습니다. 플래그, ID 정보, 프래그먼트 오프셋이 바로 그 정보들인데, 플래그는 이 패킷이 조각화된 패킷인지 아닌지를 판별할 수 있는 정보입니다. 만약 이 패킷이 조각화된 패킷이면 IP 담당 내부의 메모리에 일시적으로 보관하게 됩니다. 그리고 ID 정보를 통해 조각화된 패킷들이 한몸임을 식별할 수 있습니다. 한몸이 되어야 하는 패킷들은 동일한 ID 정보를 가집니다. 그리고 이 패킷들이 어떤 순서로 합쳐져야 하는지에 대한 정보는 프래그먼트 오프셋이라는 항목으로 알 수 있습니다. 여기까지 수행하면 이제 패킷을 TCP 담당에 전달합니다.
TCP 담당은 IP 헤더의 수신처, 송신처 IP 주소와 TCP 담헤더의 수신처, 송신처 포트 번호를 조사해서 해당하는 소켓을 찾습니다. 소켓에는 현재 통신의 진행 상태가 기록되어 있기 때문에 적절한 동작을 수행하면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;udp-프로토콜의-송수신-동작&quot;&gt;UDP 프로토콜의 송/수신 동작&lt;/h3&gt;

&lt;p&gt;UDP 프로토콜은 TCP 프로토콜처럼 신뢰성을 보장하지 않아도 될 경우 사용하면 효율적입니다. TCP와 달리 패킷이 잘 도착했는지 확인하고 도착하지 않았으면 패킷을 다시 보내는 동작을 하지 않기 때문입니다. UDP는 TCP처럼 수신 확인, 윈도우 같은 것이 없기 때문에 송, 수신 전에 제어 정보를 주고 받을 필요가 없고, 접속, 연결 끊기 단계도 없습니다. 애플리케이션으로부터 데이터를 받으면 그냥 UDP 헤더를 붙이고 IP에 의뢰하고 바로 송신합니다. 수신도 IP 헤더의 수신처, 송신처의 IP 주소와, TCP 헤더의 수신처, 송신처의 포트 번호로 소켓을 찾아서 애플리케이션에게 데이터를 건네주고 끝입니다. 오류가 발생해도 UDP는 신경쓰지 않습니다. UDP는 DNS 서버에 IP 주소를 조회할 때나, 음성 및 동영상 데이터의 송수신에 사용됩니다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><category term="CS" /><summary type="html">Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘2장 TCP/IP의 데이터를 전기 신호로 만들어 보낸다’를 정리했습니다.</summary></entry><entry><title type="html">성공과 실패를 결정하는 1%의 네트워크 원리 1장</title><link href="https://anstn1993.github.io/2022/01/18/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-1%EC%9E%A5.html" rel="alternate" type="text/html" title="성공과 실패를 결정하는 1%의 네트워크 원리 1장" /><published>2022-01-18T00:00:00+09:00</published><updated>2022-01-18T00:00:00+09:00</updated><id>https://anstn1993.github.io/2022/01/18/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1%25%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-1%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2022/01/18/%EC%84%B1%EA%B3%B5%EA%B3%BC-%EC%8B%A4%ED%8C%A8%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%98%EB%8A%94-1-%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9B%90%EB%A6%AC-1%EC%9E%A5.html">&lt;p&gt;Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘1장 웹 브라우저가 메시지를 만든다’를 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;1장-웹-브라우저가-메시지를-만든다&quot;&gt;1장. 웹 브라우저가 메시지를 만든다.&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;1장에서는 웹 브라우저가 url을 입력해서 요청할 때 메시지가 만들어져서 바깥으로 나가는 순간까지를 추적합니다.&lt;/p&gt;

&lt;h3 id=&quot;dns가-ip주소를-찾는다&quot;&gt;DNS가 ip주소를 찾는다&lt;/h3&gt;

&lt;h4 id=&quot;ip-주소란&quot;&gt;ip 주소란?&lt;/h4&gt;

&lt;p&gt;ip 주소는 네트워크의 대역을 식별하는 &lt;strong&gt;네트워크 번호&lt;/strong&gt;와 그 대역 안에서 하나의 컴퓨터(노드)를 식별하는 &lt;strong&gt;호스트 번호&lt;/strong&gt;의 조합으로 이루어진 32비트 데이터 입니다. 이때 ip주소 값에서 어디까지가 네트워크 번호이고 어디까지가 호스트 번호인지 그 경계를 구분해주는 역할을 하는 것이 &lt;strong&gt;서브넷 마스크&lt;/strong&gt; 입니다. 서브넷은 작은 네틔워크 대역 하나를 의미하고, 이 대역 안에서의 장비들은 &lt;strong&gt;허브&lt;/strong&gt;로 연결됩니다. 그리고 이 서브넷들은 &lt;strong&gt;라우터&lt;/strong&gt;를 통해 서 연결되는데, 결국 전체 네트워크는 수많은 서브넷들이 연결된 형태라고 생각하면 됩니다. ip 주소는 결국 두 노드가 통신할 때 각 노드가 많은 서브넷들 중에서 어떤 서브넷의 어떤 장비인지를 식별하기 위한 값이라고 볼 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;dns란-무엇인가&quot;&gt;DNS란 무엇인가&lt;/h4&gt;

&lt;p&gt;브라우저에서 실제로 통신을 할 대상을 지정할 때 ip주소를 입력해도 되지만 대부분의 경우에는 도메인 주소를 입력하게 됩니다. ip주소가 아님에도 불구하고 원하는 대상과 통신을 할 수 있는 이유는 DNS(Domain Name System)에게 적절한 ip를 받을 수 있기 때문입니다. DNS 서버는 도메인 주소와 그에 대응되는 ip주소를 저장하고 있는 서버 입니다. 브라우저에서 도메인을 입력해서 요청을 하는 순간 DNS 서버에 도메인 주소를 전달하면서 그에 대응되는 ip주소를 돌려달라고 요청을 먼저 하게 되고 그렇게 전달 받은 ip 주소를 이용해서 실제 네트워크 통신이 시작됩니다.&lt;/p&gt;

&lt;h4 id=&quot;dns-서버에-요청을-보내는-건-소켓-라이브러리의-dns-리졸버다&quot;&gt;DNS 서버에 요청을 보내는 건 소켓 라이브러리의 DNS 리졸버다&lt;/h4&gt;

&lt;p&gt;DNS 서버에 ip 주소를 찾기 위한 요청은 &lt;strong&gt;DNS 리졸버&lt;/strong&gt;가 보내게 됩니다. DNS 서버를 통해서 ip 주소를 조사하는 것을 name resolution(이름 확인)이라고 하는데, 이를 실행하는 것이 DNS 리졸버 입니다.
리졸버는 소켓 라이브러리에 포함된 루틴(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gethostbyname(&amp;lt;domain name&amp;gt;)&lt;/code&gt;) 입니다. 소켓 라이브러리는 애플리케이션 레벨에서 네트워크 통신에 필요한 동작을 OS에 의뢰하기 위한 많은 루틴들을 포함하고 있습니다. 리졸버도 애플리케이션에서 OS에 작업 의뢰를 하기 위한 많은 인터페이스들 중 하나라고 이해하면 되겠습니다.&lt;/p&gt;

&lt;p&gt;애플리케이션에서 name resolution을 하기 위해서 소켓 라이브러리의 리졸버를 호출하면 다음과 같은 동작이 발생합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;DNS 서버에 보낼 요청 메시지를 만든다.&lt;/li&gt;
  &lt;li&gt;프로토콜 스택에 의뢰하여 DNS 서버에 전송한다.&lt;/li&gt;
  &lt;li&gt;프로토콜 스택이 DNS에서 돌아온 응답 메시지를 수신하면 리졸버에게 반환한다.&lt;/li&gt;
  &lt;li&gt;리졸버는 응답 메시지에서 ip 주소를 추출해서 애플리케이션에게 반환하고 애플리케이션은 그 ip 주소를 자신이 관리하는 변수에 저장한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;프로토콜 스택&lt;/strong&gt;은 DNS 서버와의 통신뿐만 아니라 모든 네트워크 통신에 필요한 동작을 담당하는 OS에 포함되어있는 프로그램입니다. 프로토콜 스택이 실제로 어떻게 동작하는지는 뒤에서 살펴보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;ip주소는-여러-dns가-연대해서-찾는다&quot;&gt;ip주소는 여러 DNS가 연대해서 찾는다&lt;/h3&gt;

&lt;h4 id=&quot;dns-서버가-ip를-찾는-과정&quot;&gt;DNS 서버가 ip를 찾는 과정&lt;/h4&gt;

&lt;p&gt;앞에서 클라이언트가 도메인 주소를 통해서 ip 주소를 찾기 위해서 DNS 서버에 요청을 보내는 과정을 살펴봤으면 이제 요청을 받은 DNS 서버가 실제로 ip를 어떻게 찾는지 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;클라이언트로부터 받은 조회 메시지에는 다음의 3가지 정보가 포함되어있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이름: 서버나 메일 배송 목적지(메일 주소에서 @ 뒷부분)와 같은 이름&lt;/li&gt;
  &lt;li&gt;클래스: DNS의 구조를 고안했을 때 인터넷 이외의 네트워크에서의 동작까지 고려해서 만든 네트워크 식별을 위한 값으로, 지금은 인터넷 이외의 네트워크는 소멸했기에 클래스는 항상 인터넷을 의미하는 ‘IN’이 사용됨&lt;/li&gt;
  &lt;li&gt;타입: 이름에 어떤 타입의 정보가 지원되는지를 표시한 것으로 ‘A’면 이름에 ip 주소가 지원됨을, ‘MX(Mail eXcahnge)’이면 이름에 메일 목적지가 지원됨을 나타냄&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DNS 서버는 위의 3가지 정보에 대응하는 ip주소나 메일의 배송 목적지를 설정 파일에 기록해두었습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;이름&lt;/th&gt;
      &lt;th&gt;클래스&lt;/th&gt;
      &lt;th&gt;타입&lt;/th&gt;
      &lt;th&gt;클라이언트에 회답하는 항목&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;www.lab.cyber.co.kr&lt;/td&gt;
      &lt;td&gt;IN&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;192.0.2.226&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cyber.co.kr&lt;/td&gt;
      &lt;td&gt;IN&lt;/td&gt;
      &lt;td&gt;MX&lt;/td&gt;
      &lt;td&gt;10 mail.cyber.co.kr&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mail.cyber.co.kr&lt;/td&gt;
      &lt;td&gt;IN&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;192.0,2.227&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위의 표가 DNS 서버가 관리하는 설정 파일에 들어있는 데이터 예시입니다. DNS 서버는 요청 메시지에 기재된 3가지 정보를 통해서 표에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;클라이언트에 회답하는 항목&lt;/code&gt;을 찾아서 응답하게 됩니다. 예를 들어 ‘www.lab.cyber.co.kr’의 ip주소를 조사하고 싶다면 클라이언트는 DNS 서버에 다음과 같은 정보를 포함해서 메시지를 보내는 겁니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이름: www.lab.cyber.co.kr&lt;/li&gt;
  &lt;li&gt;클래스: IN&lt;/li&gt;
  &lt;li&gt;타입: A&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그럼 DNS 서버는 192.0.2.226을 클라이언트에 응답해주게 됩니다. 그럼 메일 배송 목적지를 조회할 때 사용하는 MX에 대해서도 살펴보겠습니다. 예를 들면 ‘tone@cyber.co.kr’이라는 메일 주소가 있을 때 목적지 메일 서버의 이름은 @ 뒤에 있는 이름이 됩니다. 그럼 조회 메시지는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이름: cyber.co.kr&lt;/li&gt;
  &lt;li&gt;클래스: IN&lt;/li&gt;
  &lt;li&gt;타입: MX&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 표를 기준으로 DNS 서버는 ‘10’과 ‘mail.cyber.co.kr’이라는 두 값을 담아서 응답합니다. 여기서 숫자는 메일 서버의 우선순위를 의미합니다. 메일의 전송 목적지로 복수의 메일 서버가 등록되어있으면 어느 메일 서버를 우선 선택할지 판단하기 위한 값으로, 값이 작을수록 우선순위가 높습니다.
그런데 잘 보면 여기서 끝이 아닙니다. 어떠한 경우가 되었든 네트워크 통신은 ip를 통해서 이루어지기 때문에 저 전송 목적지의 ip주소를 찾아서 함께 담아서 응답하게 됩니다. 위의 표에서는 ‘192.0.2.227’이 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;dns-서버들은-도메인-주소를-기반으로-계층화되어있다&quot;&gt;DNS 서버’들’은 도메인 주소를 기반으로 계층화되어있다&lt;/h4&gt;

&lt;p&gt;사실 앞에서는 DNS 서버가 한대인 것을 가정해서 설명했습니다. 하지만 현실에는 엄청난 수의 서버가 있기에 1대의 DNS 서버만으로 운용하는 것은 불가능합니다. 그래서 실제로는 여러 대의 DNS 서버가 요청을 주고받으면서 최종적인 ip 주소를 찾게 됩니다. 하지만 각각의 DNS 서버가 응답할 값을 찾는 과정은 위에서 설명한 것과 동일하기 때문에 결국 DNS 서버들이 어떤 &lt;strong&gt;구조&lt;/strong&gt; 속에서 통신하는지만 이해하면 됩니다.&lt;/p&gt;

&lt;p&gt;DNS 서버들의 구조를 이해하려면 먼저 &lt;strong&gt;도메인의 계층&lt;/strong&gt;에 대해서 이해해야 합니다. 도메인 주소는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.&lt;/code&gt;으로 구분되는데, 이 점이 계층을 구분합니다. 오른쪽 끝이 최상위, 왼쪽 끝이 최 하위 계층이 됩니다. ‘www.lab.cyber.com’을 예로 들면, ‘com’이 최상위 계층이 되고, ‘www’는 최하위 계층이 됩니다. 회사의 조직으로 비유해보면, ‘com 사업부 cyber 부 lab과의 www씨’ 정도가 됩니다. 그리고 저 각각의 계층화된 주체가 바로 &lt;strong&gt;도메인&lt;/strong&gt;입니다. 결국 도메인 주소는 com, cyber, lab, www와 같은 도메인들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.&lt;/code&gt;으로 계층화한 값이라고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;다시 DNS 서버로 돌아와보면 DNS 서버들은 계층화된 도메인들을 하나씩 맡아서 저장하게 됩니다. 이때 &lt;strong&gt;하위의 도메인을 담당하는 DNS 서버의 주소를 그 상위의 DNS 서버에 등록합니다.&lt;/strong&gt; 예를 들면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lab.glasscom.com&lt;/code&gt;이라는 도메인을 담당하는 DNS 서버를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;glasscom.com&lt;/code&gt;의 DNS 서버에 등록하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;glasscom.com&lt;/code&gt;의 DNS 서버를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;com&lt;/code&gt; 도메인의 DNS 서버에 등록하는 식입니다. 그럼 상위의 DNS 서버에서 하위 DNS 서버의 ip 주소를 알 수 있고, 그 서버에 조회 메시지를 보내서 다시 그 하위 DNS 서버의 ip주소를 받음으로써 실제 타겟 서버의 ip주소를 조회할 때까지 계층적으로 타고 내려갈 수 있게 됩니다. 결국 &lt;strong&gt;DNS 서버는 도메인 주소와 같은 계층화된 구조를 가지는 것&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h4 id=&quot;세상의-모든-dns-서버는-root-도메인의-dns-서버-주소를-알아야-한다&quot;&gt;세상의 모든 DNS 서버는 root 도메인의 DNS 서버 주소를 알아야 한다&lt;/h4&gt;

&lt;p&gt;그럼 DNS 서버가 실제로 ip 주소를 찾는 과정을 좀 더 구체적으로 살펴보기에 앞서 DNS 서버들이 갖추어야 할 준비사항을 살펴보겠습니다. 우리가 살펴봤던 ‘lab.glasscom.com’에서 ‘com’이 최상위 계층이지만 사실 그 위에는 &lt;strong&gt;root 도메인&lt;/strong&gt;이 존재합니다. 이 도메인이 진짜 최상위 도메인이고 이 루트 도메인의 DNS 서버에 ‘com’, ‘kr’같은 도메인의 DNS 서버를 등록하게 됩니다. ip 조회 작업은 항상 root 도메인의 DNS 서버에서부터 시작하고 그 하위 DNS 서버로 타고 내려가면서 진행됩니다. 항상 root 도메인에서부터 조회가 시작되어야하기 때문에 &lt;strong&gt;세상에 존재하는 모든 DNS 서버는 root 도메인의 DNS 서버를 등록한 상태&lt;/strong&gt;입니다. 그래야 어떤 지역의 DNS서버로 요청을 보내도 그 요청을 다시 root 도메인의 DNS 서버로 보낼 수 있기 때문입니다.&lt;/p&gt;

&lt;h4 id=&quot;dns-서버가-ip를-찾는-실제-과정&quot;&gt;DNS 서버가 ip를 찾는 실제 과정&lt;/h4&gt;

&lt;p&gt;이제 모든 준비가 끝났습니다. 클라이언트가 ‘www.lab.glasscom.com’이라는 웹 서버에 관한 정보를 조회하기 위해서 클라이언트 pc에 설정된 DNS 서버로 조회 요청을 보내면 다음과 같은 일들이 벌어집니다. 편의상 클라이언트에게 최초 요청을 받은, 즉 클라이언트에게 ip를 찾아서 응답해줄 의무를 가지는 DNS 서버를 ‘A 서버’라고 칭하도록 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;최초 요청을 받은 A 서버에는 ‘www.lab.glasscom.com’이라는 이름이 등록되어 있지 않기에 root 도메인의 DNS 서버에 클라이언트로부터 받은 메시지를 전송&lt;/li&gt;
  &lt;li&gt;root 도메인의 DNS 서버는 마지막 도메인이 ‘com’인 것을 확인하고 ‘com’ 도메인의 DNS 서버의 ip 주소를 A 서버에 응답&lt;/li&gt;
  &lt;li&gt;A 서버는 응답받은 ip를 이용하여 ‘com’ 도메인이 있는 DNS 서버에 조회 요청&lt;/li&gt;
  &lt;li&gt;‘com’ 도메인의 DNS 서버에도 ‘www.lab.glasscom.com’는 등록되어있지 않기 때문에 ‘com’의 아래에 있는 ‘glasscom.com’ 도메인의 DNS 서버의 ip 주소를 A 서버에 응답&lt;/li&gt;
  &lt;li&gt;A 서버는 응답받은 ip를 이용하여 ‘glasscom.com’ 도메인의 DNS 서버에 조회 요청&lt;/li&gt;
  &lt;li&gt;‘glasscom.com’ 도메인의 DNS 서버에도 ‘www.lab.glasscom.com’는 등록되어있지 않기 때문에 ‘glasscom.com’의 아래에 있는 ‘lab.glasscom.com’ 도메인의 DNS 서버의 ip 주소를 A 서버에 응답&lt;/li&gt;
  &lt;li&gt;A 서버는 응답받은 ip를 이용하여 ‘lab.glasscom.com’ 도메인이 있는 DNS 서버에 조회 요청&lt;/li&gt;
  &lt;li&gt;‘lab.glasscom.com’ 도메인의 DNS 서버에는 ‘www.lab.glasscom.com’의 ip 주소가 있기 때문에 여기서 ip 주소를 응답받으면 A 서버는 클라이언트에 해당 ip 주소를 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이처럼 하나의 도메인 이름에 대응되는 ip를 찾으려면 여러 개의 DNS 서버에 요청을 보내야 합니다. 그런데 지금까지 살펴본 DNS 서버의 탐험은 DNS 서버 하나에 도메인 하나를 저장한 경우를 가정했지만, 현실에서는 한 대의 DNS 서버에 복수의 도메인 정보를 가질 수도 있습니다. 즉 상위와 하위 도메인을 같은 DNS 서버에 등록할 수도 있는데, 이 경우에 상위 DNS 서버에 조회를 하면 하위 DNS 서버를 하나 건너뛰고 그 아래의 DNS 서버에 관한 정보가 돌아옵니다.&lt;/p&gt;

&lt;h4 id=&quot;dns-서버는-캐싱을-통해-응답-속도를-높일-수-있다&quot;&gt;DNS 서버는 캐싱을 통해 응답 속도를 높일 수 있다&lt;/h4&gt;

&lt;p&gt;앞선 DNS 서버의 ip 조회 과정에서 꽤나 많은 요청과 응답이 필요하다는 것을 알게 됐습니다. 다소 비효율적인 것처럼 보이는데, 여기에 한 번 조사한 이름을 캐시에 기록하여 root 도메인의 DNS 서버부터 최하위 도메인의 DNS서버까지 요청을 보내지 않고 바로 응답을 내려줄 수 있습니다. 이렇게 하면 캐시 미스가 나는 경우에 한해서만 앞서 살펴본 과정을 거쳐서 ip를 획득하면 됩니다.&lt;/p&gt;

&lt;p&gt;하지만 캐싱을 적용할 때는 DNS 서버의 정보와 캐시에 저장된 정보의 동기화에 주의해야 합니다. 캐시에 정보를 저장한 후에 DNS 서버의 등록 정보가 변경되면, 캐시에 저장된 정보는 더 이상 유효하다고 할 수 없기 때문입니다. 그래서 DNS 서버에 등록하는 정보에는 유효기간을 설정하고, 캐시에 저장한 데이터의 유효기간이 지나면 캐시에서 삭제하게 됩니다. 그리고 조회에 응답할 때 정보가 캐싱된 정보인지, 등록처 DNS 서버에서 직접 응답을 받은 것인지 알려주게 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;os의-프로토콜-스택에-메시지-송신을-의뢰한다&quot;&gt;OS의 프로토콜 스택에 메시지 송신을 의뢰한다&lt;/h3&gt;

&lt;p&gt;ip 주소까지 구했으면 이제 통신 대상 서버에 메시지를 송신하도록 OS의 &lt;strong&gt;프로토콜 스택&lt;/strong&gt;에 의뢰하게 됩니다. 이 과정에서도 소켓 라이브러리의 루틴들을 호출하게 됩니다. 메시지를 송신하는 일련의 절차들을 알아보면서 각 절차들에서 호출되어야 하는 루틴들을 함께 살펴보겠습니다. 앞서 DNS 리졸버에서도 살펴봤지만 소켓 라이브러리는 애플리케이션이 OS의 프로토콜 스택에 필요한 동작을 의뢰하는 인터페이스 역할을 담당합니다. 소켓 라이브러리 자체가 통신에 필요한 직접적인 동작을 하지 않는다는 것을 명심하세요.&lt;/p&gt;

&lt;h4 id=&quot;소켓의-작성-단계&quot;&gt;소켓의 작성 단계&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gethostbyname&lt;/code&gt;을 호출하고나면 다음으로는 소켓 생성을 위해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket(&amp;lt;IPv4 사용&amp;gt;, &amp;lt;스트림형&amp;gt;, ...)&lt;/code&gt;을 호출하게 됩니다. 여기서 ‘소켓’은 ‘소켓 라이브러리’에서의 소켓과는 조금 다른 의미로 쓰였는데요. 여기서는 간단하게 ‘통신의 출입구’ 정도로 이해하면 됩니다. 자세한 의미는 2장에서 살펴봅니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket()&lt;/code&gt;을 호출해서 소켓을 생성하면 &lt;strong&gt;디스크립터&lt;/strong&gt;가 반환됩니다. 디스크립터는 소켓을 식별하기 위한 식별값입니다. 컴퓨터는 동시다발적으로 여러 서버와 통신하는 일이 비일비재하기 때문에 복수의 소켓이 동일한 시점에 존재할 가능성이 높습니다. 이런 상황에서 프로토콜 스택이 각각의 소켓을 식별할 필요가 있기 때문에 디스크립터를 쓰는 것입니다. 이 디스크립터는 애플리케이션의 메모리에 저장한 후 이후 루틴의 인자로 전달됩니다.&lt;/p&gt;

&lt;h4 id=&quot;두-노드-간의-파이프를-연결하는-접속-단계&quot;&gt;두 노드 간의 파이프를 연결하는 접속 단계&lt;/h4&gt;

&lt;p&gt;소켓을 만들었으면 그 소켓을 서버측의 소켓에 접속하도록 프로토콜 스택에 의뢰합니다. 이때 사용하는 루틴은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect(&amp;lt;디스크립터&amp;gt;, &amp;lt;서버의 ip 주소와 포트 번호&amp;gt;)&lt;/code&gt;입니다. 앞서 소켓 생성의 결과로 반환받은 디스크립터를 인자로 전달하여 어떤 소켓으로 서버 소켓에 연결해야하는지 찾습니다. ip 주소와 포트 번호도 인자로 전달하는데, ip 주소로는 통신 대상 노드를 찾고, 포트 번호로 그 노드의 연결할 소켓을 찾게 됩니다. 이때 소켓을 찾는다는 말은 결국 애플리케이션을 찾는다는 말과 같기 때문에 포트 번호를 통해서 통신 노드 내에서 어떤 애플리케이션과 연결을 할지를 결정한다고 봐도 좋습니다.&lt;/p&gt;

&lt;p&gt;그럼 서버도 클라이언트의 어떤 소켓과 통신해야할지 알아야 하기 때문에 클라이언트의 포터번호가 필요할 것입니다. 클라이언트 소켓의 포트 번호는 소켓을 생성할 당시에 프로토콜 스택이 적당한 값을 골라서 할당하게 됩니다. 그리고 접속 동작 시에 서버측에 통지해줍니다. 자세한 과정은 2장에서 설명합니다.&lt;/p&gt;

&lt;p&gt;이렇게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect()&lt;/code&gt;를 호출해서 프로토콜 스택이 접속 동작을 실행하고 상대와 연결되면 프로토콜 스택은 연결된 상대의 ip 주소나 포트 번호 등의 정보를 소켓에 기록합니다. 이제 데이터의 송/수신이 가능한 상태가 됐습니다.&lt;/p&gt;

&lt;h4 id=&quot;메시지를-주고-받는-송수신-단계&quot;&gt;메시지를 주고 받는 송/수신 단계&lt;/h4&gt;

&lt;p&gt;양쪽 소켓이 연결되었으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write(&amp;lt;디스크립터&amp;gt;, &amp;lt;송신 데이터&amp;gt;, &amp;lt;송신 데이터 길이&amp;gt;)&lt;/code&gt; 루틴을 호출해서 프로토콜 스택이 송신 데이터를 서버에게 송신하게 합니다. 이미 소켓에는 통신 상대 소켓에 대한 정보가 기록되어 있기 때문에 바로 전송을 할 수 있습니다. 서버는 수신 동작을 통해 받은 데이터에 대한 적절한 처리를 하고 응답 메시지를 반송합니다. 그럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read(&amp;lt;디스크립터&amp;gt;, &amp;lt;수신 버퍼&amp;gt;, ...)&lt;/code&gt;라는 루틴을 통해서 프로토콜 스택에 수신 동작을 의뢰할 수 있습니다. 수신한 응답 메시지는 &lt;strong&gt;수신 버퍼&lt;/strong&gt;라는 메모리 영역에 저장합니다. 이 버퍼는 애플리케이션에 할당된 메모리 공간이기 때문에 애플리케이션이 접근해서 읽게 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;송수신을-종료하는-연결-끊기-단계&quot;&gt;송/수신을 종료하는 연결 끊기 단계&lt;/h4&gt;

&lt;p&gt;통신이 모두 끝나면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close(&amp;lt;디스크립터&amp;gt;)&lt;/code&gt; 루틴을 호출해서 프로토콜 스택이 연결 끊기 동작을 수행하게 합니다. 일반적으로 HTTP1.0에서는 서버쪽에서 먼저 연결 끊기 동작을 실행합니다.(HTTP 1.1 버전에서는 요청할 데이터가 없어진 상태가 되면 브라우저에서 연결 끊기를 먼저 들어갈 수도 있습니다.) 이때 끊기 동작이 수행되었다는 것을 클라이언트에 전달하게 되는데, 그럼 클라이언트 애플리케이션도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; 루틴으로 그 사실을 전달받고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt;를 호출해서 연결 끊기 단계에 들어갑니다. 디스크립터를 인자로 전달하는 것은 여러 소켓 중에 말소시킬 소켓을 찾아야하기 때문입니다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><category term="CS" /><summary type="html">Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘1장 웹 브라우저가 메시지를 만든다’를 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 7장</title><link href="https://anstn1993.github.io/2021/12/22/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-7%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 7장" /><published>2021-12-22T00:00:00+09:00</published><updated>2021-12-22T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/12/22/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-7%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/12/22/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-7%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘7장 프로젝트 전에’를 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;7장-프로젝트-전에&quot;&gt;7장. 프로젝트 전에&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;36장-요구사항의-구렁텅이&quot;&gt;36장. 요구사항의 구렁텅이&lt;/h3&gt;

&lt;p&gt;우리가 현실에서 받아보는 요구사항은 진정한 요구사항이 아닌 경우가 많습니다. 요구사항은 무엇이 이루어져야 된다는 진술이 되어야 하는데 거기에 어떤 정책이 녹아든 경우가 많으며 그것은 요구사항이라고 말하기 힘듭니다. 예를 들면 ‘직원 기록은 지명된 사람들만 볼 수 있습니다.’는 요구사항이라고 할 수 있지만, ‘해당 직원의 관리자와 인사부에서만 그의 기록을 열람할 수 있습니다’는 요구사항이 아닙니다. 여기에는 비즈니스 정책에 녹아있기 때문입니다. 당장 내일 그의 기록을 열람할 수 있는 대상군이 추가될 수도 있고, 반대로 사라질 수도 있는 것입니다. 위의 두 문장을 다르게 표현해보자면 전자는 후자에 비해 상대적으로 추상적이고, 후자는 전자에 비해 구체적입니다. 항상 구체적인 것보다는 추상적인 것이 더 오래갑니다. 그래서 이런 요구사항과 정책을 잘 분리해서 문서화하고 양자를 하이퍼링크하는 것이 중요합니다. 둘을 나누고 정책과 관련된 정보는 구현의 한 예시로 제시합니다. 그럼 정책은 결국 애플리케이션의 메타데이터로 빠져서 잘 분리될 것입니다.
요구사항을 잘 정리했다면 문서화를 잘 합시다. 유스케이스, 유스케이스 다이어그램 등을 잘 활용하면 문서화를 잘 할 수 있습니다.이때 지나치게 자세하게 서술하는 것에 주의해야 합니다. 요구사항은 최대한 간단하고 명료하게 작성해야 합니다. 요구사항에 설계, 사용자 인터페이스가 들어가서는 안 됩니다.
마지막으로 한 프로젝트를 만들기 위해 달려드는 모든 구성원들의 의사소통을 원활하게 하기 위해서 공통의 용어사전을 만들고 유지합시다. 이때 이 용어는 웹 기반의 문서로 작성해두면 접근성이 높아져 더 많은 사람들이 찾아볼 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;37장-불가능한-퍼즐-풀기&quot;&gt;37장. 불가능한 퍼즐 풀기&lt;/h3&gt;

&lt;p&gt;해결이 불가능에 가까워보이는 어려운 문제를 해결할 때는 항상 자신의 상상이 아닌 실제의 제약 조건을 알아내고 그 안에서 해법을 찾는 것입니다. 그리고 이 제약조건이 한번 밝혀지면 그것이 마음에 들든, 들지 않든 절대적인 것이라는 사실을 인정하는 것이 중요합니다. 이때 진정 제약조건이 아닌 것에 휘말리지 않도록 주의합시다. 많은 경우 이런 것에 휘말려서 문제 해결이 더 어렵게 느껴지는 경우가 많습니다.&lt;/p&gt;

&lt;h3 id=&quot;38장-준비가-되어야만&quot;&gt;38장. 준비가 되어야만&lt;/h3&gt;

&lt;p&gt;프로젝트를 진행하기에 앞서 아직 시작할 때가 아니라는 생각이 든다면 본인의 판단을 믿고 준비가 되었을 때 시작합시다. 경력이 쌓이면 쌓일수록 비슷한 일을 많이 경험하게 되기에 이유를 명확히 설명할 수는 없지만 뭔가 꺼림칙하다면 그 직감을 믿어도 괜찮습니다.
하지만 그 미룸이 늑장부림일 수도 있습니다. 과연 좋은 판단과 늑장부림을 어떻게 구분할 수 있을까요? 프로토타입을 만들기 시작하는 것입니다. 어려울 것 같은 부분을 고르고 그것의 개념 입증을 위한 코드를 작성해보면 시작한지 얼마 되지 않아 시간낭비라는 느낌이 드는 경우가 있을 것입니다. 이런 지루함이 느껴진다면 단순히 늑장부림이었을 가능성이 높아집니다. 이젠 진짜 개발을 시작할 때라는 좋은 징표입니다.
반면 프로토타입을 만드는 과정에서 몇몇 전제가 틀렸다는 것이 밝혀질 때도 있는데, 이런 경우 이제 어떻게 올바르게 해야할지도 명확해지기 때문에 진짜 개발을 시작해도 꺼림칙하지 않을 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;39장-명세의-함정&quot;&gt;39장. 명세의 함정&lt;/h3&gt;

&lt;p&gt;프로그램 명세화란 어떤 요구사항을 프로그래머가 자신의 기술로 작업할 수 있을 때까지 구체화하는 과정입니다. 즉, 추상적인 진술에서 올 수 있는 모호함을 제거하는 과정이라고도 볼 수 있죠. 명세는 지금 당장 구현을 할 개발자들과의 대화일 뿐만 아니라 미래에 유지보수하고 개선할 프로그래머들을 위한 기록입니다.
그런데 앞에서도 말했지만 이 명세를 지나치게 구체적으로 작성하는 것은 지양해야 합니다. 너무 세부적인 사항까지 명세에 작성하는 것은 여러 이유로 볼 때 실수입니다.
첫째, 명세서가 시스템이나 세스템에 대한 요구사항의 모든 세부사항과 미묘한 차이점을들 모두 잡아낼 수 없습니다. 그리고 명세에 작성하는 표기법의 의미를 결국에는 읽는 사람들에게 설명해줘야 하고, 사람들마다 해석 차이가 존재해서 일이 뒤죽박죽이 될 가능성이 있습니다.
둘째, 언어 자체의 표현 능력에도 문제가 있습니다. 우리가 수행할 작업을 기술할 때는 결국 자연 언어로 된 표현에 의존해야 하는데, 이는 명세에 그렇게 적합하지는 않습니다. 때론 이런 것들을 언어로 풀어내는 것보다 직접 해보는 것이 더 쉬울 수도 있습니다.
셋째, 실제 개발을 하는 사람의 기술적 자유를 빼앗아버릴 수도 있습니다. 너무 구체적이게 되면 개발을 하는 사람이 자신만의 판단이나 해석을 할 여지가 남지 않게 되기 때문에 어쩌면 더 좋은 선택, 더 좋은 구현을 하게 될 가능성을 차단하게 될 수도 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;40장-동그라미-화살표&quot;&gt;40장. 동그라미 화살표&lt;/h3&gt;

&lt;p&gt;여러 개발 방법론들과 같은 형식적 방법을 지나치게 맹신하면 안 됩니다. 형식적 방법에는 몇 가지 단점이 존재합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대부분의 형식적 방법은 다이어그램과 같은 어떤 형식을 이용해서 설명하는데, 이걸 보는 최종 사용자는 그 형식을 전혀 이해하지 못하기에 설계자가 해석을 해줘야만 합니다. 이는 결국 최종 사용자들이 그 시스템의 요구사항을 스스로 점검할 수 없음을 의미합니다.&lt;/li&gt;
  &lt;li&gt;형식적 방법들은 전문화를 권장하는 것처럼 보입니다. 어떤 집단은 데이터 모델 작업을 하고, 다른 집단은 아키텍처 수립하고, 또 다른 집단은 유스케이스를 모읍니다. 하지만 이런 방식은 의사소통 부족과 노력의 낭비로 이어지는 경우가 많습니다. 또한 구성원들이 시스템 전체에 대한 이해를 하지 못하게 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대부분의 방법론들은 저마다의 이점이 존재하지만 그 이점들이 발휘되기 위해서는 그것을 사용하는 사람들이 학습하는 상당한 시간이 필요한데, 이 상당한 노력은 가리고 이점만 과장하는 경우가 많으니 주의해야 합니다. 이런 사실을 받아들이고 주의 깊게 분석한 후에 그 방법론이 필요하다고 생각한다면 기꺼이 사용합시다. 하지만 그 방법론이라는 도구의 노예가 되면 안 됩니다. 동그라미와 화살표를 사용하는 우리가 주인이라는 사실을 기억합시다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘7장 프로젝트 전에’를 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 8장</title><link href="https://anstn1993.github.io/2021/12/22/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-8%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 8장" /><published>2021-12-22T00:00:00+09:00</published><updated>2021-12-22T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/12/22/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-8%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/12/22/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-8%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘8장 실용주의 프로젝트’를 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;8장-실용주의-프로젝트&quot;&gt;8장. 실용주의 프로젝트&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;41장-실용주의-팀&quot;&gt;41장. 실용주의 팀&lt;/h3&gt;

&lt;p&gt;앞서 살펴본 더 나은 프로그래머가 되기 위한 실용주의 기법들은 팀에도 그대로 적용됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;깨진 창문을 없애라: 팀 차원에서 깨진 창문을 없애려는 노력이 필요한 건 당연한 얘기입니다. 팀은 상품 품질에 책임이 있기에 만약 깨진 창문을 없애라는 철학을 이해하지 못한 팀원이 있다면 적극적으로 이해하도록 격려합시다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;삶은 개구리: 개인일 때보다 팀일 때 변화를 감지하지 못해 삶은 개구리가 되기 더 쉽습니다. 왜냐하면, 팀 내의 개개인들이 다른 구성원들이 이미 확인했을 것이라는 근거 없는 판단을 하기 쉽기 때문입니다. ‘다른 사람이 하겠지’라는 생각은 버리고 모든 사람이 적극적으로 환경 변화를 감시해야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;소통하라: 한 팀에 속한 개발자들이 대화하는 것은 당연합니다. 이를 넘어 팀 밖의 세상과도 소통을 한다는 사실도 잊지 맙시다. 바깥에서 봤을 때 무뚝뚝하고 과묵해보이는 팀은 최악입니다. 외부와 잘 소통하는 팀과의 회의는 언제나 기대되며, 그들이 작성한 문서는 깔끔하고 정확하며 일관적일 것입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;반복하지 마라: 팀 내에서 팀원 간의 중복된 일을 하도록 하지 않아야 합니다. 그렇게 하기 위해서 작업의 기능적 측면의 핵심 사안별로 담당자를 임명하면 효과적입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;직교성: 팀 간의 직교성을 높이려면 팀을 기능적으로 분리하는 것이 좋습니다. 각 팀이 최종 시스템의 특정한 기능에 전적으로 책임지게 하면 어떤 변화가 생겨도 그 변화에 책임이 있는 팀으로 영향 범위가 축소됩니다. 그리고 그 기능에 책임이 있다는 사실 때문에 팀원들이 주인의식을 더 많이 느낄 가능성이 높아집니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자동화: 일관성과 정확성을 보장하는 좋은 방법은 팀이 하는 모든 일을 자동화하는 것입니다. 자동화할 수 있는 것은 모조리 자동화해야 합니다. 자동화를 위해 팀 내에서 한 명의 팀원이 자동화 도구를 만들고 설치하도록 합시다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;덧칠을 언제 멈출지 알아라: 팀은 개인들로 이루어진다는 사실을 명심하고 각 팀원이 자신의 방식으로 자유롭게 개발할 수 있을 정도까지만 구조화하는 것이 중요합니다. 명세를 지나치게 구체적으로 작성할 때 발생하는 문제를 기억합시다!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;42장-유비쿼터스-자동화&quot;&gt;42장. 유비쿼터스 자동화&lt;/h3&gt;

&lt;p&gt;수작업은 일관성과 반복 가능성을 보장하지 않습니다. 그렇기 때문에 항상 운에 의존하게 됩니다. 하지만 자동화를 하게 되면 실행할 때마다 일관된 과정을 통한 결과가 보장되기 때문에 자동화는 개발부터 제품 전반의 안정화를 위해서 가능한 곳에는 모두 적용되어야 합니다.
자동화를 지원해주는 아주 다양한 도구들이 존재합니다. cron을 통해 어떤 작업이 정해진 시간에 주기적으로 수행되도록 할 수 있고, makefile로 프로젝트 컴파일을 할 수도 있습니다. 이런 도구들을 이용해서 빌드나 테스트 같은 것들도 자동화할 수 있도록 구성합시다!&lt;/p&gt;

&lt;h3 id=&quot;43장-가차없는-테스트&quot;&gt;43장. 가차없는 테스트&lt;/h3&gt;

&lt;p&gt;테스트 코드는 일찍 테스트하고, 자주 테스트해야 합니다. 가급적, 코드를 작성하자마자 테스트 코드를 해야 합니다. 버그는 빨리 발견하면 발견할수록 고치는 비용이 적어짐을 명심하고, 테스트 코드를 작성하고 모든 테스트가 통과했을 때 비로소 코딩이 끝났다고 생각하면서 코드를 작성합시다. 그리고 가능하다면 자동화해서 주기적으로 테스트 코드가 실행되도록 합시다.
그럼 무엇을 테스트해야 할까요? 테스트를 할 때는 크게 단위 테스트, 통합 테스트, 유효성 평가와 검증, 녹록치 않은 현실 속 한정된 자원에서의 동작 테스트, 성능 테스트(스트레스 테스트), 사용 편의성 테스트 등을 해야 합니다.
무엇을 테스트할지 알았다면, 어떻게 테스트할지도 알아야 합니다. 코드의 수정이 일어난 후에도 전체 기능이 수정 이전과 같이 동작하는지를 테스트해야 합니다. 이를 회귀 테스트라고 합니다. 그리고 실세계의 데이터, 통계적 조건 하에 인공적으로 생성된 합성 데이터와 같은 테스트 데이터를 많이 확보하고 이 데이터를 기반으로 테스트해야 합니다. 두 종료의 데이터가 갖는 다른 특징들이 다른 종류의 버그를 찾아줄 것이기 때문에 둘 다 사용해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;44장-결국은-모두-글쓰기&quot;&gt;44장. 결국은 모두 글쓰기&lt;/h3&gt;

&lt;p&gt;개발자들은 일반적으로 문서화보다는 코드를 작성하는 것을 더 좋아하는 것 같습니다. 하지만 실용주의 프로그래머들은 문서화도 개발 프로세스의 일부로 포용합니다. 문서를 코드에 녹여낼 수 있다면 문서 작성은 한결 더 쉬운 작업이 됩니다. 코드와 문서를 결합시키는 유틸리티는 많습니다. 자바의 경우 JavaDoc이 대표적입니다.
문서의 종류로는 소스 코드, 주석, 설계와 테스트 문서와 같은 내부 문서와 사용자 메뉴얼 같이 외부로 출간되는 모든 것이 포함된 외부 문서가 있습니다. 어떤 문서이든 문서는 코드의 거울이라고 생각하고 작성을 게을리하지 맙시다. 특히 주석을 작성할 때는 그 코드의 동작에 대해 작성하는 경우가 많은데 그 내용은 이미 코드 자체에서 파악이 가능한 내용이기 때문에 DRY 원칙 위배입니다. 주석에는 왜 이런 코드가 작성되었는지, 왜 이런 구조로 잡았는지와 같은 목적에 대한 설명이 들어가야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;45장-위대한-유산&quot;&gt;45장. 위대한 유산&lt;/h3&gt;

&lt;p&gt;위대한 소프트웨어는 명세를 올바르게 구현하는 것을 넘어서 사용자들의 기대를 충족시켜야 합니다. 아무리 설계가 훌륭하고, 효율적이고, 요구사항을 잘 충족하더라도 그것이 사용자에게 매력적이지 않고 기대를 충족하지 않는다면 그 소프트웨어는 실패작으로 간주됩니다.
사용자들의 기대를 충족시키려면 사용자들과 기대에 대해서 상호 소통해야 합니다. 즉, 그들이 기대하는 것이 무엇인지에 집중하면서 사용자들에게 우리가 어떤 결과물을 전달하게 될 것인지를 끊임없이 설명해서, 그들이 무엇을 기대해야 할지에 대해서 제어를 하는 것이 중요합니다. 이런 과정은 앞에서 살펴본 예광탄이나 프로토타입 등을 이용해서 수월하게 진행할 수 있을 것입니다. 사용자들에게 미리 대략의 결과물을 보여줄 수 있기 때문입니다.
그리고 가능하다면 사용자들이 요구하지 않은 추가 기능을 구현해서 그들을 놀라게 합시다. 물론 어디까지나 기본에 충실할 때의 이야기 입니다.&lt;/p&gt;

&lt;h3 id=&quot;46장-오만과-편견&quot;&gt;46장. 오만과 편견&lt;/h3&gt;

&lt;p&gt;실용주의 프로그래머는 자신의 결과물에 자부심을 가집니다. 그렇기 때문에 책임을 회피하지 않습니다. 하지만 이런 자부심이 때로는 오만으로 이어질 수도 있습니다. 각자 자신의 코드에 대한 자부심이 지나쳐 서로 협력하지 못하고 깎아내리고 편견을 가지게 될 수 있습니다. 이는 바람직하지 않습니다. 항상 다른 사람들의 코드를 존중하고 상호 존중을 지킵시다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘8장 실용주의 프로젝트’를 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 6장</title><link href="https://anstn1993.github.io/2021/12/16/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-6%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 6장" /><published>2021-12-16T00:00:00+09:00</published><updated>2021-12-16T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/12/16/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-6%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/12/16/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-6%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘6장 코딩하는 동안 해야 할 일들’을 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;6장-코딩하는-동안-해야-할-일들&quot;&gt;6장. 코딩하는 동안 해야 할 일들&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;31장-우연에-맡기는-프로그래밍&quot;&gt;31장. 우연에 맡기는 프로그래밍&lt;/h3&gt;

&lt;p&gt;우리는 항상 &lt;strong&gt;생각하면서&lt;/strong&gt; 코드를 작성해야 합니다. 즉 그냥 되는대로 작성하면 안 된다는 건데요. 항상 코드를 그렇게 작성하는 의도가 명확해야 합니다. 생각 없이 작성한 코드가 잘 돌아간다면 그것은 그저 그 코드를 돌리는 순간 운이 좋아서 잘 돌아가는 것이라고 생각합시다. 즉, 언제라도 제대로 돌아가지 않을 수 있다는 것을 의미합니다.
그럼 의도적으로 프로그래밍한다는 것은 무엇일까요? 책에서는 다음과 같이 설명합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자기가 무엇을 하고 있는지 알아야 한다.&lt;/li&gt;
  &lt;li&gt;맹목적인 코딩을 하지 말자. 왜 그렇게 동작하는지 아는 애플리케이션만 빌드하거고 이해하고 있는 기술을 사용하자.&lt;/li&gt;
  &lt;li&gt;코드를 작성하기 전에 계획을 세우고 진행하라.&lt;/li&gt;
  &lt;li&gt;신뢰할 수 있는 것에만 기대라.&lt;/li&gt;
  &lt;li&gt;자신의 가정을 문서로 남기고 그것을 통해 다른 사람들과 소통하라.&lt;/li&gt;
  &lt;li&gt;자신이 세운 가정을 반드시 테스트해서 증명해라.&lt;/li&gt;
  &lt;li&gt;우선순위를 정하고 중요한 것을 먼저 처리하라.&lt;/li&gt;
  &lt;li&gt;기존의 코드가 미래에 짤 코드의 발목을 잡지 못하게 해라. 더 이상 적절한 코드가 아니면 과감하게 리팩토링하라.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;32장-알고리즘의-속도&quot;&gt;32장. 알고리즘의 속도&lt;/h3&gt;

&lt;p&gt;프로그램을 만들 때 어떤 알고리즘이 사용하는 자원(시간, 프로세서, 메모리 등)을 추정하는 것이 중요할 때가 있습니다. 일반적으로 ‘big O’ 표기법을 통해 근사값을 추정할 수 있습니다. 이 표기법을 통해 우리가 작성한 코드의 차수를 추정해봅시다. 만약 코드만 봐서는 가늠이 되지 않는다면 입력 레코드의 수나, 그 외에 영향을 미칠 수 있는 요소를 바꾸어가면서 직접 실행해보면 됩니다. 몇 번만 실행해서 그래프를 그려본다면 대략적인 답이 나올 것입니다. 이 얘기의 연장으로, 코드만 보고 추정을 하는 것을 넘어서 실제 데이터를 입력받아서 돌아가는 코드의 수행시간이 진정으로 의미있는 수치입니다. O(n^2)이 O(nlogn)보다 수치상으로는 좋지 않지만 실제 코드가 수행되는 조건, 환경 하에서 수행시간이 전자가 더 짧다면 당연히 전자의 알고리즘을 채택하는 것이 맞습니다.&lt;/p&gt;

&lt;h3 id=&quot;33장-리팩터링&quot;&gt;33장. 리팩터링&lt;/h3&gt;

&lt;p&gt;코드는 생물과도 같습니다. 즉, 코드는 시간이 지나면 늘 문제에 직면하기 마련이고 그로 인해 항상 변하는 것이라는 사실을 명심하고 코드를 다시 작성하는 것에 대해 주저하지 맙시다. 중복, 성능, 유효기간이 끝난 지식, 직교적이지 않은 설계 등, 무슨 문제라도 생기면 바로 리팩터링을 해야 합니다. 사실 현실에서 일정의 압박 때문에 리팩터링을 하는 것이 쉽지는 않습니다. 결국 일정의 압박이 있다는 건 리팩터링을 할 시간까지는 고려하지 않았다는 것을 의미하는데, 이게 현재의 시점에서는 문제 없이 동작하는 것처럼 보이기 때문에 합리적인 판단이라고 생각할 수 있지만, 앞서 말했듯이 반드시 문제에 직면하게 된다는 것을 생각해보면 그렇게 합리적이라고 할 수 없습니다. 지금 당장 고치지 않아서 나중에 고치는 데 더 큰 비용이 들어갈 것이니까요. 그래서 책에서는 &lt;strong&gt;일찍, 그리고 자주 리팩터링하라&lt;/strong&gt;고 조언합니다.
리팩터링은 아주 천천히, 신중하게 해야합니다. 마틴 파울러는 올바른 리팩터링을 위해 다음과 같은 조언을 했습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;리팩터링을 할 때 새로운 기능 추가는 하지 말자.&lt;/li&gt;
  &lt;li&gt;리팩터링을 시작하기 전에 든든한 회귀 테스트 집합을 확보해야 한다. 그래야 리팩터링 과정에서, 그리고 리팩터링이 종료된 후에도 리팩터링 전과 같이 동작하는지 확인해볼 수 있다.&lt;/li&gt;
  &lt;li&gt;단계를 나누어서 신중하게 작업한다. 대부분의 커다란 작업은 사실 작은 규모의 것들이 합쳐진 것이다. 한 단계가 마무리될 때마다 테스트를 돌려서 디버깅의 지옥에서 벗어나자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;34장-테스트하기-쉬운-코드&quot;&gt;34장. 테스트하기 쉬운 코드&lt;/h3&gt;

&lt;p&gt;역할이 명확히 분리되게끔 모듈을 나누면 각 모듈들에 대한 단위 테스트를 하기 쉬워집니다. 단위 테스트는 모듈들의 루틴을 호출해보면서 그 루틴들이 계약을 잘 지키는지 테스트하는 것을 말합니다. 이때 테스트는 작은 것에서부터 점점 큰 것으로 진행되어야 합니다. 가장 작은 단위의 모듈들이 탄탄하게 테스트되면 그 모듈들에 의존하고 있는 다른 모듈들을 테스트할 때 문제가 생기더라도 이미 테스트가 완료된 모듈들은 후보에서 과감하게 제외할 수 있기 때문입니다. 물론 테스트를 하는 것은 성가시고, 귀찮고, 시간도 더 많이 필요하지만, 그렇게 하지 않았을 때 미래에 문제가 터져버려서 어디서부터 디버깅을 해야할지도 감이 안 오는 상황을 피하기 위해서 꼭 해야만 합니다.
테스트 코드는 다음의 아주 귀중한 자원도 제공합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모듈의 모든 기능을 어떻게 이용해야 하는지 보여주는 예제&lt;/li&gt;
  &lt;li&gt;코드 변경시 검증하기 위한 회귀 테스트 구축 수단&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;실제로 저도 작업을 하면서 코드 수정을 하고 작성해둔 모든 테스트 코드를 돌려봅니다. 돌려보고 모든 테스트가 통과하면 마음이 편해지고, 통과하지 못해도 좋습니다. 배포 전에 문제를 찾은 것이니까요.
책에서는 테스트를 위한 장치(도구)를 사용하라고 권장하는데요. 그 장치는 다음과 같은 기능이 있어야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시작할 때 할 일과 마칠 때 할 일을 지정할 수 있는 표준적인 방법&lt;/li&gt;
  &lt;li&gt;개별적인 테스트들을 선택하거나, 모든 테스트를 한꺼번에 선택하게 해주는 메서드&lt;/li&gt;
  &lt;li&gt;예상한(또는 예상치 못한) 결과에 비추어 결과를 분석할 수 있는 방법&lt;/li&gt;
  &lt;li&gt;실패를 보고하는 표준화된 형태&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자바에서는 이 모든 조건을 갖춘 도구로 JUnit을 많이 활용합니다. 저도 팀에서 테스트 코드를 Junit으로 작성하고 있습니다^^ 모든 코드에 대한 테스트 코드를 작성하지는 못하지만 그래도 작성하고나면 마음이 든든합니다. 어차피 프로그래머 자신, 혹은 팀에서 테스트를 하지 않으면 유저가 테스트를 하게 됩니다. 유저가 테스트하기 전에 먼저 테스트를 꼼꼼하게 진행해야겠습니다!&lt;/p&gt;

&lt;h3 id=&quot;35장-사악한-마법사&quot;&gt;35장. 사악한 마법사&lt;/h3&gt;

&lt;p&gt;오늘날 방대해진 애플리케이션을 빠르게 만들기 위해서 거의 대부분의 코드 골격을 대신 생성해주는 마법사 덕분에 우리는 정해진 시간 안에 서비스를 만들 수 있지만 마법사가 만든 코드를 이해하고 사용하는 것이 중요합니다. 그렇지 않으면 이는 우연에 맡기는 프로그래밍과 다를 게 없습니다. 마법사가 만들어준 코드가 지금 상황에 맞지 않으면 혼자 힘으로 코드를 바꿔야 하는데 기를 때 마법사의 코드를 이해하지 못하면 결국 마법사에게 끌려다니게 될 것입니다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘6장 코딩하는 동안 해야 할 일들’을 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 5장</title><link href="https://anstn1993.github.io/2021/12/08/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-5%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 5장" /><published>2021-12-08T00:00:00+09:00</published><updated>2021-12-08T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/12/08/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-5%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/12/08/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-5%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘5장 구부러지거나 부러지거나’을 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;5장-구부러지거나-부러지거나&quot;&gt;5장. 구부러지거나 부러지거나&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;26장-결합도-줄이기와-디미터-법칙&quot;&gt;26장. 결합도 줄이기와 디미터 법칙&lt;/h3&gt;

&lt;p&gt;결합도를 줄이는 것은 최대한 적은 객체와 상호작용하는 것에서 시작됩니다. 모든 객체를 모듈화하고 한 모듈이 너무 많은 모듈과 상호작용하는 것을 제한합시다. 그러면 한 모듈이 변경되더라도 다른 모듈들은 큰 변경 없이 수행될 수 있습니다. 책에서 재밌는 예시를 들었는데요. 우리가 집을 지을 때 이를 도맡아서 해줄 주계약자라는 주체와만 계약을 할 것입니다. 그럼 이 주계약자는 또 다시 집을 짓기 위해 필요한 역할들을 담당할 하도급자들과 계약을 합니다. 이때 우리는 하도급자들과 직접 부딪힐 일도 없고 이들에게 무슨 일이 생긴다고 하더라도 신경쓸 것이 없습니다. 모든 건 주계약자가 처리할 거니까요. 이처럼 어떤 객체에게 특정한 서비스를 요청하면 그 서비스가 어떻게 처리되는지 요청자는 알 필요가 없게 하는게 중요합니다.
프로그램에서 모듈 간의 결합도를 최소화하고 싶다면 디미터 함수 법칙을 따르는 것도 좋은 방법입니다. 디미터 함수 법칙에 따르면 객체의 한 메서드 내에서 다음에 해당하는 메서드만 호출해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체 자신이 가지는 다른 메서드&lt;/li&gt;
  &lt;li&gt;인자로 전달된 객체의 메서드&lt;/li&gt;
  &lt;li&gt;객체 자신이 포함하고 있는 멤버의 메서드&lt;/li&gt;
  &lt;li&gt;지역 변수 객체의 메서드&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;물론 이 법칙을 엄격하게 따르는 것에 대한 대가도 있습니다. 역할에 대한 위임을 위해서 위임하는 객체의 메서드를 호출하기 위한 위임용 메서드를 많이 만들어야 합니다. 하지만 그럼에도 불구하고 깨지기 쉽고, 유연하지 않은 프로그램을 만드는 것이 가져오는 후폭풍은 어마무시하기 때문에 가능하다면 디미터 함수 법칙을 잘 지키는 것이 좋을 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;27장-메타프로그래밍&quot;&gt;27장. 메타프로그래밍&lt;/h3&gt;

&lt;p&gt;메타데이터는 최대한 많이 코드에서 분리하여 별도로 관리하도록 하는 것이 좋습니다. 데이터에 관한 데이터인 메타데이터는 애플리케이션 구성에 필요한 모든 데이터를 의미합니다. 다음과 같은 것들입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터베이스 연동 정보&lt;/li&gt;
  &lt;li&gt;api url&lt;/li&gt;
  &lt;li&gt;컨텐츠 업로드/다운로드 경로&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같은 데이터가 코드레벨에 뿌리내려 박혀있다면 그 프로그램은 매우 경직된, 변화에 쉽게 대응할 수 없는 프로그램이 될 것입니다. 우리의 애플리케이션의 db가 바뀌더라도 그것이 코드 바깥에 있다면 코드의 수정은 최소화될 것입니다. 메타데이터를 코드 바깥에서 별도로 관리하면 코드의 추상화 레벨은 올라갈 것이고, 애플리케이션의 설정 변경을 위해 다시 컴파일할 필요가 없어집니다.
저에게 가장 익숙한 스프링도 메타데이터 관리를 위한 지원을 아주 잘 해줍니다. properties나 yaml파일에 애플리케이션의 모든 메타 데이터를 몰아두고 코드에서는 그 설정 파일의 값을 동적으로 읽어들일 수 있게 구성해서 유연성을 높일 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;28장-시간적-결합&quot;&gt;28장. 시간적 결합&lt;/h3&gt;

&lt;p&gt;시간적 결합은 어떤 메서드나 함수의 호출이 다른 것의 호출보다 이전, 혹은 이후에만 실행되어야 하는 순서에 의존하는 것을 의미합니다. 물론 이런 순서가 반드시 지켜져야하는 경우도 있지만 순서와 무관하게 호출되어도 되는(혹은 동시에 호출되어도 되는) 경우에도 순차적으로 호출되는 경우가 있습니다. 이런 경우에는 시간적 결합을 끊어낼 수 있는 방법을 고려해보는 것이 좋습니다. 주로 동시성을 허용하는 것인데요. 이 책에서는 아래와 같은 방법들을 제시합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;작업 흐름
요구사항을 분석할 때 작업의 흐름을 모델화해서 분석해보는 것입니다. UML 활동 다이어그램을 통해 작업 흐름을 시각화하는 것이 하나의 방법이 되겠습니다. 그렇게 분석하다보면 &lt;strong&gt;동시에 일어나도 되는 것들&lt;/strong&gt;이 보이는데요. 이를 통해 병렬성을 극대화할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아키텍처
여러 시스템들이 결합되어 동작하는 분산 애플리케이션에서 동시에 처리되어도 되는 시스템들끼리 집합으로 묶고 순차적으로 처리되는 시스템 집합 사이에는 큐를 통해 순차적으로 실행되어야하는 시스템 집합들 간의 동기화를 할 수 있습니다. 이렇게 하면 같은 시스템 집합 속의 시스템들 간의 시간적 결합을 끊어내서 효율을 극대화할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;동시성을 고려한 설계
책은 자바의 스레드를 예로 들면서 동시성 제어를 위해 고려해야할 것들을 강조합니다. 가장 대표적으로 static한 변수들을 동시 접근으로부터 보호하는 것이 있는데요. 더 중요한 건 정적 변수가 정말 필요한지를 자문하는 것입니다. 다음은 여러 스레드의 손을 타는 전역 변수의 상태가 손을 탈 가능성이 있는 모든 시간대에 언제나 유효한 상태에 있도록 하는 것이 중요합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;29장-단지-뷰일-뿐이야&quot;&gt;29장. 단지 뷰일 뿐이야&lt;/h3&gt;

&lt;p&gt;적절히 책임을 잘 분리해서 모듈들을 만드는 것은 매우 중요합니다. 그런데 이렇게 만들고나서 각 모듈들이 소통하게 하려면 어떻게 해야할까요. 이벤트를 사용하면 됩니다. 이벤트는 어떤 객체의 상태 변화가 생기면 그 변화에 관심이 있는 다른 객체들에게 알리는 것입니다. 이벤트를 구현할 수 있는 대표적인 방법이 출판/구독인데요. 출판자는 이벤트를 발신하는 역할을 구독자는 이벤트를 수신하는 역할을 합니다. 구독자가 관심을 가지는 이벤트에 구독을 하면 출판자는 구독자 목록을 저장하고 해당 이벤트가 발생하면 목록에 있는 구독자에게 이벤트가 발생했다고 알리게 됩니다. 이 둘 간의 관계는 여러 형태를 가지는데, 직접 통신을 하는 ‘p2p’방식부터 중간에서 중계를 하는 객체를 두는 ‘소프트웨어 버스 방식’ 등 다양합니다.
이런 출판/구독 메커니즘은 MVC 패턴에서 뷰와 컨트롤러에서 모델을 분리해내기 위해서 사용할 수 있습니다. 모델은 출판자, 뷰는 구독자가 됩니다. 모델에서 어떤 데이터의 변화라는 이벤트가 생기면 뷰는 그 사실을 전달받아 갱신하는 것입니다.
하지만 여전히 구독자와 출판자 사이에는 서로에 대한 의존성이 존재합니다. 가령 자바에서 출판자에게 인터페이스를 전달하더라도 콜백을 위해 어떤 루틴을 호출해야할지에 대한 지식을 가지고 있어야 합니다. 다음 장에서 결합도를 더 많이 낮추는 방법을 보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;30장-칠판&quot;&gt;30장. 칠판&lt;/h3&gt;

&lt;p&gt;형사들이 수사를 할 때 칠판을 어떻게 활용하는지 살펴보면 다른 모듈들 간의 결합도를 낮추는 실마리를 찾을 수 있습니다. 형사들은 칠판을 다음과 같이 활용합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;어떤 형사도 다른 형사들의 존재를 알 필요가 없다. 그저 칠판에 업데이트된 새로운 정보만 얻고 자신이 발견한 것을 추가한다.&lt;/li&gt;
  &lt;li&gt;형사들은 저마다 속한 환경이 다르고 받은 훈련의 종류가 다르고, 교육 수준도 다르며, 관할 구역이 다를 수도 있다. 단지 그들의 공통점은 사건 해결 하나다.&lt;/li&gt;
  &lt;li&gt;수사 과정에서 여러 형사들이 들어오고 나갈 수 있고, 임무의 교대 시간도 다 다를 수 있다.&lt;/li&gt;
  &lt;li&gt;칠판에 어떤 정보를 올려야 하는지에 대한 제한은 없다. 사진, 증언, 물리적 증거 등 모든 것이 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 내용을 프로그래밍으로 적용해본다면, 형사들은 모듈들이 되고 칠판은 각 모듈들이 비동기적으로 데이터를 주고받을 수 있는 공간을 의미합니다. 이제 칠판에 데이터를 주고 받는 단 하나의 인터페이스만 정한다면 이벤트를 보내는 쪽과 받는 쪽의 결합은 완전히 끊어낼 수 있습니다. 이 내용을 보면서 메세징 큐가 떠올랐는데요. 카프카나, rabbit MQ를 이용하면 이런 메세징 큐에 데이터를 밀어넣고, 소비하기 위한 인터페이스를 하나로 통일할 수 있게 되어서 서로 다른 모듈들 간에 데이터 교환을 위한 제각각 다른 인터페이스를 구현하면서 생기는 의존성을 끊어낼 수 있습니다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘5장 구부러지거나 부러지거나’을 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 4장</title><link href="https://anstn1993.github.io/2021/12/01/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-4%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 4장" /><published>2021-12-01T00:00:00+09:00</published><updated>2021-12-01T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/12/01/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-4%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/12/01/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-4%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘4장 실용주의 편집증’을 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;4장-실용주의-편집증&quot;&gt;4장. 실용주의 편집증&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;21장-계약에-의한-설계&quot;&gt;21장. 계약에 의한 설계&lt;/h3&gt;

&lt;p&gt;정직한 거래를 보장하는 최선의 해법은 계약입니다. 계약의 당사자들은 모두 자신의 권리와 책임을 지고, 서로에게 기대한 바를 수행하도록 강제합니다. 이런 컨셉을 소프트웨어 모듈에도 적용하면 프로그램의 정확성을 높일 수 있습니다. 정확한 프로그램은 자신의 일이라고 주장하는 것에 대해 더 많지도, 적지도 않게 수행하는 것입니다. 그 주장을 문서화하고 검증하는 것이 바로 계약에 의한 설계(Design By Contract, DBC)입니다.
이 계약은 보통 함수, 메서드와 그것의 호출자 사이에 적용됩니다. 계약에 의한 설계 개념을 개발한 버트란드 마이어는 계약을 이행하기 위한 조건으로 다음 3가지를 말합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;선행조건: 루틴이 호출되기 위해 지켜져야 할 조건으로 이 조건이 위반된 경우에는 루틴이 호출되지 않아야 합니다. 즉 조건이 충족된 데이터를 루틴에 전달하는 것은 호출하는 쪽의 책임입니다.&lt;/li&gt;
  &lt;li&gt;후행조건: 루틴이 완료되었을 때의 상태를 의미합니다. 어떤 루틴에 후행조건이 있으면 그 루틴은 반드시 종료됨을 보장합니다.&lt;/li&gt;
  &lt;li&gt;클래스 불변식: 호출자의 입장에서 루틴이 종료되고 호출자로 제어권이 반환될 때 불변식이 항상 참임을 보장하는 것입니다. 루틴이 진행 중일 때는 불변식이 일시적으로 참이 아닐 수도 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 조건을 정리하자면 만약 호출자가 루틴의 모든 선행조건을 이행한다면, 루틴은 종료시에 모든 호행조건과 불변식이 참이 될 것을 보장해야 하는 것입니다.&lt;/p&gt;

&lt;p&gt;상속과 다형성에서도 이런 계약은 빛을 발합니다. 서브타입은 항상 부모 타입의 한 종류라는 간단한 사실을 잊지 않고 서브클래스에서는 자신의 부모 이상으로 받아들이고, 최소한 자신의 부모만큼은 보증해야 하는데 이런 규칙을 잘 이행하게 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;22장-죽은-프로그램은-거짓말을-하지-않는다&quot;&gt;22장. 죽은 프로그램은 거짓말을 하지 않는다.&lt;/h3&gt;

&lt;p&gt;우리는 코드를 작성하는 그 순간부터 무슨 일이든 일어날 수 있다는 것을 인정해야 합니다. 많은 경우 ‘그런 일은 절대 일어날 리 없어’라는 생각과 함께 방어적으로 코딩을 하지 않는데, 가능하면 방어적으로 코딩하면서 에러를 최대한 빨리 잡아내고 &lt;strong&gt;가능한한 일찍 프로그램의 작동을 멈추게 하는 것&lt;/strong&gt;이 좋습니다. 대표적으로 자바는 예외를 던져서 그것을 잡지 않으면 스택 트레이스를 출력하면서 프로그램을 종료합니다.
그렇게 하지 않으면 프로그램은 점점 망가져가고 결국 문제의 발생 지점과는 점점 멀어져서 어디서부터 잘못됐는지 알 수 없는 지경에 다다를 수도 있습니다. 멈출 수 있을 때 바로 멈춰버립시다!&lt;/p&gt;

&lt;h3 id=&quot;23장-단정적-프로그래밍&quot;&gt;23장. 단정적 프로그래밍&lt;/h3&gt;

&lt;p&gt;단정문(assertion)을 사용해서 절대 일어나선 안 될 일들에 대비를 해야 합니다. 단정문을 통한 검사 없이 ‘이런 일은 절대 일어날 수 없어’라고 생각하고 있다면 그것은 아주 큰 오산입니다. 혹자들은 단정문에 대한 오해를 가지고 단정문을 사용하지 않는데 주로 다음과 같은 오해가 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;단정문은 과부하를 준다. 단정문은 코드의 테스트를 위해 존재하고, 테스트가 끝나면 단정을 꺼야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 주장은 테스트가 모든 버그를 발건한다는 가정이 깔려있는데, 복잡한 프로그램에서는 모든 버그를 테스트만으로 못 잡을 가능성이 높습니다. 그리고 우리의 프로그램은 험한 세상에서 돌아가고있기 때문에 런타임에도 단정문으로 최대한 빨리 일어나선 안 될 일이 일어나는 것에 대비해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;24장-언제-예외를-사용할까&quot;&gt;24장. 언제 예외를 사용할까&lt;/h3&gt;

&lt;p&gt;예외는 말 그대로 예외적인 상황에서 사용해야 합니다. 예를 들면, 파일을 열어서 읽어들일 때 파일이 존재하지 않는다면 예외가 발생해야 할까요? 정답은 파일이 반드시 존재해야 한다면 그렇고, 파일이 있을 수도 있고, 없을 수도 있다면 그렇지 않다는 것입니다. 파일이 반드시 존재해야 한다면 예외를 던지고 그렇지 않다면 에러만 반환합시다.
예외를 사용하지 말아야 할 때도 알아야 합니다. 예외는 절대 정상적인 로직을 처리하기 위해서 사용하면 안 됩니다. 모든 예외 처리를 다 제거했을 때 프로그램이 잘 동작하지 않는다면 예외를 잘못 사용하고 있는 건 아닌지 의심해봐야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;25장-리소스-사용의-균형&quot;&gt;25장. 리소스 사용의 균형&lt;/h3&gt;

&lt;p&gt;리소스 사용의 균형은 &lt;strong&gt;사용을 마쳤으면 반드시 반납하는 것&lt;/strong&gt;을 의미합니다. 메모리, 트랜잭션, 파일 등 어떤 종류의 리소스가 되었든 할당이 되었으면 반납이 되어야 합니다. 그리고 이 둘은 같은 객체가 책임져야 합니다. 이때 할당과 반납을 하는 함수는 별도로 만드는 것이 추후 유지보수 측면에서 좋습니다. 특정 역할을 하는 함수에서 반납까지 함께 처리하게 되면 시간이 지나면서 요구사항이 추가되고 그 함수가 조건에 따라 호출되지 않는 경우가 생겼을 때 자원이 반납되지 않게 되는 등의 문제가 생길 수 있습니다.
자원을 두개 이상 중첩할당할 수도 있습니다. 이때는 2가지를 주의해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;리소스를 할당한 순서의 반대로 해제하라. 그렇게 해야 한 리소스가 다른 리소스를 참조하는 경우에도 리소스를 고아로 만들지 않는다.&lt;/li&gt;
  &lt;li&gt;코드의 여러 곳에서 동일한 리소스 집합을 할당받으려고 하면 할당 순서는 모든 곳에서 동일하게 해라. 그렇게 애햐 교착 상태에 빠질 가능성을 줄일 수 있다. 할당의 순서가 달라서 한 곳에서는 resource A -&amp;gt; B, 다른 한 곳에서는 resouce B -&amp;gt; A 순서로 할당을 요청하는데 공교롭게도 각각 A와 B를 할당받은 상태에서 다음 자원 할동을 요청하게 되면 그 다음 필요한 자원은 서로가 이미 할당받은 상태이기 때문에 계속해서 기다려야 합니다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘4장 실용주의 편집증’을 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 3장</title><link href="https://anstn1993.github.io/2021/11/23/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-3%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 3장" /><published>2021-11-23T00:00:00+09:00</published><updated>2021-11-23T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/11/23/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-3%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/11/23/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-3%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘3장 기본적인 도구’를 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;3장-기본적인-도구&quot;&gt;3장. 기본적인 도구&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;14장-일반-텍스트의-힘&quot;&gt;14장. 일반 텍스트의 힘&lt;/h3&gt;

&lt;p&gt;프로그래밍은 인간이 하는 것이고 인간은 소위 일반 텍스트(plain text)를 통해서 소통하기 때문에 설계, 구현, 테스트, 문서화 등 대부분의 지식을 저장할 때는 일반 텍스트를 사용하는 것이 바람직합니다. 일반 텍스트가 아닌 이진수, 암호화된 무작위로 나열된 문자들은 그 데이터를 이해하는 데에 필요한 맥락이 없는한 의미를 파악할 수 없습니다. 물론 일반 텍스트를 사용하면 저장 공간에 대한 오버헤드가 생길 수 있고 다른 포맷에 비해 연산에 대한 오버헤드도 생길 수 있지만 그것을 일반 텍스트를 사용했을 때의 장점이 그것을 다 보상하고도 남습니다. 다음이 그 장점입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;구식이 되는 것에 대한 보험: 사람이 읽을 수 있는 형태의 데이터를 사용하면 그 데이터를 생성한 애플리케이션이 죽더라도 살아남을 수 있습니다. 완전히 소멸해버린 레거시 시스템이 생성한 주민등록번호 데이터가 있을 때 그것이 이진 데이터로 표현되어있으면 그 레거시 시스템 없이는 그 데이터의 의미를 파악하지 못합니다. 하지만 일반 텍스트로 되어있다면 그 데이터를 파싱해서 새로운 애플리케이션에 적용하는 건 매우 간단한 작업이 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;호환성: 소스코드 관리 시스템, 컴파일러, ide등과 같이 오늘날의 모든 도구들은 일반 텍스트를 다룰 수 있게 지원합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;더 쉬운 테스트: 시스템 테스트를 구동하게 할 합성 데이터를 만들기 위해 일반 텍스트를 사용하면 별도의 도구 없이 테스트 데이터를 추가, 업데이트, 수정할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;15장-조개-놀이&quot;&gt;15장. 조개 놀이&lt;/h3&gt;

&lt;p&gt;오늘날의 많은 GUI 프로그램은 프로그래머들에게 편리함을 제공하지만, 그럼에도 여전히 셸 명령어들은 프로그래머에게 없어서는 안 될 작업대라고 할 수 있습니다. GUI나 IDE의 장점은 우리가 보는 것이 우리가 얻는 것(WYSIWYG-What You See Is What You Get)이라는 점입니다. 즉 매우 직관적으로 우리에게 필요한 것을 얻을 수 있다는 것이죠. 하지만 동시에 우리가 보는 것이 우리가 얻는 전부(WYSIAYG - What You See Is All You Get)라는 단점이 있습니다. 즉 GUI, IDE가 제공하는 기능 이상의 것은 얻을 수 없습니다.
하지만 셸의 명령어들을 조합하면 우리가 원하는 거의 모든 기능을 얻을 수 있습니다. 그렇기 때문에 반드시 셸과 친근해져야 합니다. 또 이런 자주 사용되는 조합을 스크립트로 작성하여 자동화할 수도 있습니다. 현재 회사에서 배포 자동화에도 셸 스크립트가 사용되고 있는데 이를 제대로 이해하지는 못 한 것 같습니다. 셸의 중요성에 대해서 인지하고는 있지만 그 특유의 지루함 때문에 미루어왔는데 앞으로는 억지로라도 공부를 해야겠습니다..&lt;/p&gt;

&lt;h3 id=&quot;16장-파워-에디팅&quot;&gt;16장. 파워 에디팅&lt;/h3&gt;

&lt;p&gt;에디터는 프로그래밍의 기본적인 원재료인 텍스트를 매우 효율적으로 조작할 수 있게 해주는 도구이기 때문에 마치 자신의 손을 움직이는 것과 같이 익숙한 수준으로 에디터에 대한 숙련도를 높일 필요가 있습니다. 특히 &lt;strong&gt;하나의 에디터를 마스터&lt;/strong&gt;하는 것이 중요합니다. 그리고 모든 편집 작업에서 그 에디터를 사용합시다.
그럼 어떤 에디터를 선택하는지가 중요한데 다음의 요소를 만족해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 플랫폼에서 가능해야 한다.&lt;/li&gt;
  &lt;li&gt;환경 설정이 가능해야 한다.(폰트, 색깔, 윈도우 크기, 키 입력 설정 등)&lt;/li&gt;
  &lt;li&gt;확장이 가능해야 한다. 새 프로그래밍 언어가 나와도 에디터는 사용 가능해야 합니다. 즉 어떤 컴파일러 환경과도 결합 가능해야 합니다.&lt;/li&gt;
  &lt;li&gt;복잡하고 다단계의 작업 수행이 가능하도록 에티터를 프로그램할 수 있어야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;17장-소스코드-관리&quot;&gt;17장. 소스코드 관리&lt;/h3&gt;

&lt;p&gt;소스코드 관리, 즉 형상관리는 프로젝트에서 발생한 실수를 되돌릴 수 있게 해주는 거대한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;undo&lt;/code&gt; 키와 같습니다. 형상관리를 통해서 언제든지 소스코드를 원하는 시점으로 되돌릴 수 있다는 것은 프로젝트의 안정감을 극도로 높여주는 것을 의미합니다. 뿐만 아니라 특정 시점에 어떤 코드를 누가 수정했는지 알 수 있고, 무수히 많은 브랜치를 생성해서 저마다 독립적으로 코드를 작성하고 한 번에 합칠 수도 있기에 생산성도 높아집니다. 또한 결국 형상관리의 핵심은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;undo&lt;/code&gt;에 있기 때문에 소스코드가 아닌 모든 컨텐츠(각종 문서, 메모, makefile, 셸 스크립트, 환경설정 등)는 다 형상관리 하에 두는 것이 좋습니다.
책에는 나오지 않지만 최근에는 많은 프로젝트가 git flow의 규칙에 따라 관리되는데 이런 형상관리가 당연하다고 생각하다가도 막상 이게 없다고 생각하면 너무 암담할 것 같습니다^^&lt;/p&gt;

&lt;h3 id=&quot;18장-디버깅&quot;&gt;18장. 디버깅&lt;/h3&gt;

&lt;p&gt;현존하는 모든 프로그램은 완벽하지 않고 우리가 만든 프로그램도 마찬가지 입니다. 항상 버그가 존재하기 때문에 디버깅을 잘해야 합니다. 디버깅을 잘 하려면 우선 마음가짐을 다잡아야 합니다. 디버깅은 단지 &lt;strong&gt;문제해결&lt;/strong&gt; 그 이상, 이하도 아니라고 생각하고 접근해야 합니다. 버그를 만들어낸 장본인이 누구인지 색출하고, 비난하는 것은 아무 도움이 안 됩니다. 그렇게 한다고 버그가 고쳐지는 것도 아닙니다. 그 다음은, 디버깅을 할 때 당황하지 않아야 합니다. 일정이 촉박하거나 상사나 클라이언트의 압력에 시달리고 있는 상황에서 디버깅을 하는 것은 분명히 쉽지 않겠지만 그럼에도 불구하고 차분하게 원인을 생각해야 합니다. 그리고 디버깅을 할 때 표면에 보이는 문제를 해결하는 것이 아닌 몇 단계 더 깊이 있는 근본적인 문제를 해결하려고 노력해야 합니다.
이렇게 마음가짐을 다잡았다면 이젠 실제로 디버깅을 어떻게 할지 살펴보겠습니다. 당연한 얘기처럼 들릴 수도 있지만 수집할 수 있는 모든 정보를 수집해야 합니다. 필요하다면 최초로 버그를 발견한 사람을 인터뷰할 수도 있어야 합니다. 그리고 제한적인 테스트를 넘어 최종 사용자의 입장에서 모든 케이스를 철저하게 테스트해야 합니다.
이렇게 어떤 버그가 발생하고 있는지를 확실히 파악했으면 그게 프로그램의 입장에서 어떻게 발생하는지 찾아야 합니다. 그걸 알아내는 가장 쉬운 방법은 그 프로그램이 다루는 데이터를 살펴보는 것입니다. 이때 데이터들 간의 상호관계를 시각화해서 보여주는 디버거를 쓸 수 있다면 아주 쉽게 깊이 있는 파악이 가능합니다. 그리고 현재 상태를 넘어 시간별로 데이터의 상태가 어떻게 변하는지를 살펴봐야 할 수도 있습니다. 특히 실시간 시스템, 동시 프로세스, 이벤트 기반 애플리케이션 등에서 그런데, 이럴 때는 트래이싱을 이용합시다. 트레이스 메시지는 규칙적이고 일관된 형식으로 작성되어야 합니다. 왜냐하면 그 메시지에서 특정 영역만 자동으로 뽑아내서 해석하고 싶은 경우가 많기 때문입니다. 예를 들면 자원 누수가 있는지 확인하고 싶어서 open/close를 남겨서 open은 있는데 close는 없는 경우를 찾을 수 있습니다. 또 다른 방법으로는 버그가 발생한 코드에 대해서 다른 사람에게 설명을 해보는 것입니다. 그러면 혼자서 코드를 봤을 때 당연하게 생각하고 지나갈 것을 명시적으로 설명하게 되는데 여기서 의외의 통찰을 얻을 수도 있습니다. 그 외로 자신이 작성한 코드에 근거가 없는 신뢰와 믿음을 가지기보단 항상 증명하려고 하고 서드파티 모듈보단 자신의 코드에 문제가 있을 것이라고 가정하고 디버깅을 합시다.&lt;/p&gt;

&lt;h3 id=&quot;19장-텍스트-처리&quot;&gt;19장. 텍스트 처리&lt;/h3&gt;

&lt;p&gt;텍스트 처리를 위한 언어는 텍스트를 원하는 형태로 제어하기 위해서 꼭 숙달해야 합니다. 유닉스 계열에서는 awk, sed와 같은 명령어를 선호하기도 하고, 파이썬 같은 더 구조적이고 객체지향성을 갖춘 도구를 선호하기도 하는데 뭐가 됐든 이런 기반 언어들 중 하나를 익혀야 합니다. 이런 텍스트 처리 언어를 통해 다음과 같은 것을 할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터베이스 스키마가 들어있는 일반 텍스트 파일로 sql문 생성, 데이터베이스에 엑세스하는 c코드 생성 등..&lt;/li&gt;
  &lt;li&gt;자바 클래스에서 특정 플래그가 달린 멤버에 대한 getter/setter 자동 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;20장-코드-생성기&quot;&gt;20장. 코드 생성기&lt;/h3&gt;

&lt;p&gt;코드 작성하는 코드, 즉 코드 생성기를 만들면 똑같은 기능을 다른 맥락에서 사용할 때 반복할 필요가 없어집니다. 코드 생성기는 크게 두 가지 유형이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;수동적 코드 생성기: 결과를 내기 위해 한 번만 실행되는 생성기 입니다. 한번 생성되면 수동적 코드 생성기와는 독립적인 결과물이 됩니다. 즉 몇 개의 입력을 받으면 그에 맞게 출력을 생성해주는 템플릿이라고 생각하면 됩니다. 가령 새 소스 파일 생성, 언어 간 일회용 변환 수행 등이 수동적 코드 생성기 입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;능동적 코드 생성기: 코드 생성이 필요할 때마다 작동하는 생성기 입니다. 단지 평하기 위해 사용하는 수동적 코드 생성기와 달리 능동적 코드 생성기는 DRY 원칙을 따르려면 필수 입니다. 이 생성기는 하나의 지식 뼈대를 만들어두면 그것을 사용하는 구체화된 형식으로 변환해줍니다. 가령 데이터베이스 애플리케이션을 만들 때 우리가 다루어야 할 환경은 데이터베이스와 데이터베이스에 접근하기 위한 언어 입니다. 이때 데이터베이스 스키마와 언어에서 데이터베이스 테이블 형식을 표현하는 구조체는 형태만 다를뿐 그 지식은 동일합니다. 이는 지식이 중복되는 것입니다. 이런 것을 능동적 코드 생성기로 해결할 수 있습니다. 스키마를 입력하면 그에 맞는 구조체들을 만들어주는 것입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘3장 기본적인 도구’를 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 1장</title><link href="https://anstn1993.github.io/2021/11/17/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-1%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 1장" /><published>2021-11-17T00:00:00+09:00</published><updated>2021-11-17T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/11/17/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-1%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/11/17/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-1%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘1장 실용주의 철학’을 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;1장-실용주의-철학&quot;&gt;1장. 실용주의 철학&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;1-고양이가-내-소스코드를-삼켰어요&quot;&gt;1. 고양이가 내 소스코드를 삼켰어요.&lt;/h3&gt;

&lt;p&gt;우리는 사람이기 때문에 일을 하다보면 실수를 하기 마련입니다. 이 실수에 잘 대처해야 합니다. 실수했을 때, 변명을 하거나 주변 환경(동료, 경영진, 사용하는 도구, 프로그래밍 언어 등..)을 탓하는 것은 프로답지 못합니다. 실수를 정직하게 받아들이고 그것에 &lt;strong&gt;책임&lt;/strong&gt;지는 태도가 중요합니다. 변명보단 &lt;strong&gt;대안&lt;/strong&gt;을 제시합시다. 소스코드를 다 날려놓고 고양이가 삼켰다는 구차한 변명은 하지맙시다! 저도 일을 하면서 이런 책임감을 가지면서 일을 하고 있는지에 대해서 많이 회고해보고 반성해야할 것 같습니다..!&lt;/p&gt;

&lt;h3 id=&quot;2-소프트웨어-엔트로피&quot;&gt;2. 소프트웨어 엔트로피&lt;/h3&gt;

&lt;p&gt;건물의 아주 일부분에 손상이 가해진 시점부터 그 건물의 손상이 매우 빠르게 진행된다는 ‘깨진 창문 이론’은 소프트웨어 개발에도 그대로 적용됩니다. 나쁜 설계, 잘못된 결정, 형편없는 코드와 같은 &lt;strong&gt;깨진 창문을 그대로 내버려 두면 안 됩니다.&lt;/strong&gt; 이런 깨진 창문은 전파력이 너무 강해서 그 소프트웨어를 담당하고 있는 모든 사람들로 하여금 ‘나머지 코드가 전부 쓰레기니까 나도 그렇게 하지 뭐’라는 생각을 하게 할 것입니다. 반대로 코드가 너무 잘 관리되고 있는 소프트웨어를 개발하고 있다면 최소한 자신이 깨진 창문을 만드는 첫번째 사람이 되지 않기 위해 노력할 것입니다. 저도 제가 작업한 내용 중에 저런 깨진 창문을 좀 만든 것 같은데 아직 고치진 않은 것 같습니다.. 빨리 고쳐야겠네요 ㅎㅎ&lt;/p&gt;

&lt;h3 id=&quot;3-돌멩이-수프와-삶은-개구리&quot;&gt;3. 돌멩이 수프와 삶은 개구리&lt;/h3&gt;

&lt;p&gt;어떤 것을 해야 하는지 확실하게 알고, 그것을 하는 것이 좋은 결과를 가져올 것이라는 믿음이 있지만, 그 일을 시작하기까지 많은 난관이 있을 수 있습니다. 그것은 그 일을 할 수 있게 허가를 받는 것이 될 수도 있고, 일을 진행하기 위한 예산을 받는 것이 될 수도 있고, 함께 그 일을 할 동료들의 비관과 무관심이 될 수도 있습니다. 이런 ‘시작 피로’에서 빨리 벗어나기 위해서는 우리 스스로가 &lt;strong&gt;변화의 촉매가 되어야 합니다.&lt;/strong&gt; 하고자 하는 일이 얼마나 매력적이고 좋은 결과를 가져올지를 보여줄 수 있는 프로토 타입을 살짝 보여줍시다. 그리고 ‘여기서 이것만 추가되면 더 좋아질 것 같긴 해’와 같이 중요한 것을 그렇게 중요하지 않은 것처럼 말하면, 주변 사람들은 그 일을 하는 것에 큰 부담을 느끼지 않으면서 열정적으로 참여할 것입니다. 이때 항상 &lt;strong&gt;큰 그림을 기억&lt;/strong&gt;하면서 그 일을 해야 합니다. 일을 계속 하다보면 처음에 그렸던 전체는 잊고 자신이 맡은 일에만 정신이 팔릴 수 있는데, 주변에서 무슨 일을 하는지 항상 살펴보고 큰 그림을 상기합시다.
이 파트는 시간이 지나면 지날수록 저에게 더 중요한 내용이라고 생각합니다. 직급이 올라갈수록 팀 내 동료들이 자신의 역할을 잘 수행하게 하고 시너지를 낼 수 있을지 고민해야 할텐데, 그때 이 파트를 다시 떠올려봐야 할 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;4-적당히-괜찮은-소프트웨어&quot;&gt;4. 적당히 괜찮은 소프트웨어&lt;/h3&gt;

&lt;p&gt;현실에서 완벽한 소프트웨어는 찾아볼 수도 없고, 적당히 괜찮은 소프트웨어를 만드는 것도 어렵습니다. ‘적당히 괜찮은’이 어떤 수준인지는 주관적이기 때문에 타협하는 것이 중요합니다. 이 타협과정에는 당연히 소프트웨어를 사용하게 될 사용자들이 참여해야 합니다. 너무 당연한 말 같지만 실 사용자들에게 요구사항이나 그 소프트웨어가 얼마나 좋아야 하는지 물어보는 경우는 거의 없는 것 같습니다. 우리의 소프트웨어는 결국 사용자들을 위해서 만드는 것이기에 그 사용자들에게 언제부터 그 소프트웨어를 사용할 수 있는지 약속해야 하고, &lt;strong&gt;사용자가 요구한 품질을 맞추는 것이 가장 중요&lt;/strong&gt;합니다. 그 최소한의 약속에 못 미치는 건 당연히 안 되지만, 그 최소한의 약속을 넘어서 더 좋은 기능을 추가하거나, 코드를 더 예쁘게 다듬는다고 출시 데드라인을 넘기는 짓도 해서는 안 됩니다. 즉 &lt;strong&gt;언제 멈춰야 할지 알아야 합니다.&lt;/strong&gt; 대부분의 사람들은 일 년 뒤에 완벽한 소프트웨어보다 오늘 당장 조금 불편한 소프트웨어를 사용하고 싶어 합니다. 그리고 적당히 괜찮은 소프트웨어로 빨리 출시를 할수록 사용자의 피드백을 빨리 받을 수 있게 되고 결국 더 빠른 시간에 더 좋은 솔루션이 될 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;5-지식-포트폴리오&quot;&gt;5. 지식 포트폴리오&lt;/h3&gt;

&lt;p&gt;우리가 프로그래머로서의 자산을 증식하기 위해서는 &lt;strong&gt;지식 포트폴리오&lt;/strong&gt;를 만드는 것이 중요합니다. 이는 금융 포트폴리오 관리와 매우 유사한데 하나씩 살펴보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주기적인 투자: 말 그대로 지식 포트폴리오에 주기적으로 투자해야 합니다. 아주 조금씩이라고 지식 축적을 위한 학습 습관을 기릅시다. 아래 항목부터는 그 습관을 기를 수 있는 구체적인 방법이 나옵니다.&lt;/li&gt;
  &lt;li&gt;다각화: 하나만 보기보단 여러 가지를 알아야 합니다. 이 분야에서 기술의 등장과 퇴장은 매우 빠른 주기로 반복되기 때문입니다. 이는 다음의 항목과도 연관됩니다.&lt;/li&gt;
  &lt;li&gt;리스크 관리: 다각화는 결국 리스크 관리로 이어집니다. 다양한 기술을 학습하면 잠재적 보상이 높은 기술(즉, 장차 핫해질 수 있는 기술)을 접할 가능성이 높아집니다.&lt;/li&gt;
  &lt;li&gt;싸게 사서 비싸게 팔기: 앞서 말한 잠재적 보상이 높은 기술, 즉 아직 그렇게 핫하지 않은 기술을 학습해두면, 향후 이익도 커질 것입니다.&lt;/li&gt;
  &lt;li&gt;검토 및 재조정: 이 분야는 매우 빠르게 변하기 때문에 지금 인기 있는 기술이 내일 당장 쓸모없는 기술이 될 수도 있고, 옛날에 한번 보고 지나친 기술을 다시 꺼내들어야 하는 순간이 올 수도 있습니다. 이런 변화에 민첩하게 대응하기 위해서 항상 지금 투자하고 있는 기술에 대해 검토하고 재조정합시다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이번에는 위의 가이드라인을 통해서 지식 포트폴리오에 자금(지식)을 제공할 방법을 살펴보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;매년 새로운 언어를 최소 하나는 배워라&lt;/li&gt;
  &lt;li&gt;기술 서적을 분기마다 한 권씩 읽어라&lt;/li&gt;
  &lt;li&gt;비 기술 서적도 읽어라&lt;/li&gt;
  &lt;li&gt;수업을 들어라&lt;/li&gt;
  &lt;li&gt;지역 사용자 모임에 참여하라&lt;/li&gt;
  &lt;li&gt;다른 환경에서 실험해보라&lt;/li&gt;
  &lt;li&gt;요즘 흐름을 놓치지 마라&lt;/li&gt;
  &lt;li&gt;인터넷을 이용하라&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;마지막으로 명심해야 할 것은 &lt;strong&gt;비판적 사고&lt;/strong&gt;를 통해 급변하는 기술 시장에서 자신만의 확고한 기준을 갖추는 것입니다. 시기별로 뜨는 기술들이 있지만 그것은 때로 과장 광고일 수도 있습니다. 그리고 그 기술에 열광하는 사람들에게 쉽게 휩쓸려서도 안 됩니다. 이것으로부터 자신의 길을 걸으려면 결국 스스로의 기술적 기반이 탄탄해야 할 것 같습니다. 더 노력해야겠네요.. 하하&lt;/p&gt;

&lt;h3 id=&quot;6-소통하라&quot;&gt;6. 소통하라!&lt;/h3&gt;

&lt;p&gt;혼자서 기가 막힌 아이디어를 가지고 있어도 그것을 타인과 공유하지 않으면 아무 의미가 없습니다. 개발자는 여러 사람들과 소통해야 하기에 그것을 잘해야 합니다. 소통을 잘하기 위해서 다음을 기억합시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;말하고 싶은 게 무엇인지 알아라&lt;/li&gt;
  &lt;li&gt;청중을 알아라:&lt;/li&gt;
  &lt;li&gt;때를 골라라&lt;/li&gt;
  &lt;li&gt;스타일을 골라라&lt;/li&gt;
  &lt;li&gt;멋져 보이게 하라&lt;/li&gt;
  &lt;li&gt;청중을 참여시켜라&lt;/li&gt;
  &lt;li&gt;청자가 되어라&lt;/li&gt;
  &lt;li&gt;응답하라.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘1장 실용주의 철학’을 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 2장</title><link href="https://anstn1993.github.io/2021/11/17/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-2%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 2장" /><published>2021-11-17T00:00:00+09:00</published><updated>2021-11-17T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/11/17/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-2%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/11/17/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-2%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘2장 실용주의 접근법’을 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;2장-실용주의-접근법&quot;&gt;2장. 실용주의 접근법&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;7-중복의-해악&quot;&gt;7. 중복의 해악&lt;/h3&gt;

&lt;p&gt;우리가 만드는 소프트웨어는 계속해서 변합니다. 설계가 바뀔 수도 있고, 개발 중간에 요구사항이 변하거나, 새로운 요구사항이 도착할 수도 있습니다. 이에 대응하는 일련의 과정이 유지보수가 되는데, 이 유지보수를 방해하는 것이 바로 &lt;strong&gt;중복&lt;/strong&gt;입니다. 유지보수를 쉽게 하려면 &lt;strong&gt;DRY(Don’t Repeat Yourself) 원칙&lt;/strong&gt;을 지켜야 합니다.&lt;/p&gt;

&lt;p&gt;중복은 대부분 다음 범주 중 하나에 속합니다. 각 범주를 살펴보고 해결 방법도 살펴보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;강요된 중복: 환경에 의한 중복입니다. 문서의 내용 자체가 코드의 중복을 요구하는 것처럼 보일 수 있습니다. 때로는 프로그래밍 언어 자체가 중복된 구조를 강제할 수도 있습니다. 이런 문제를 해결하기 위해서 다음을 지킵시다.
    &lt;ul&gt;
      &lt;li&gt;주석의 내용으로 코드의 구현이 아닌 역할을 기술합시다. 구현을 적게 되면 필연적으로 중복되는 내용이 생기게 되고 변화가 생길 때마다 함께 바뀌어야 할 것입니다.&lt;/li&gt;
      &lt;li&gt;문서와 코드를 동기화합시다. 일정의 압박에 시달리기 시작하면 코드 변경에 대한 문서 갱신이 뒤로 미루어지는데 그러지 맙시다!
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부주의한 중복: 설계 실수로 나타난 중복입니다. 가령 선을 담당하는 클래스를 만들 때, 속성으로 선의 길이를 포함할 수 있을 것입니다. 하지만 잘 생각해보면 선은 두 점을 통해 계산되는 값이기 때문에 함수로 빼는 것이 맞습니다. 즉 선을 속성으로 가지는 것은 두 점으로 구할 수 있는 속성을 중복으로 가지는 것입니다.
&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;참을성 없는 중복: 일정의 압박 속에서 이미 존재하는 비슷한 로직에서 살짝만 수정해서 빨리 구현을 할 수 있을 때 발생할 수 있는 중복입니다. 하지만 지금 당장 몇 초를 절약하려고 하다가 필히 나중에 몇 시간을 잃게 될 것입니다. 급할수록 돌아갑시다!
&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;개발자간의 중복: 서로 다른 개발자가 같은 기능을 각자 개발해서 발생하는 중복입니다. 이 문제를 해결하기 위해 다음을 지킵시다.
    &lt;ul&gt;
      &lt;li&gt;개발자간에 적극적이고 빈번한 소통을 장려해야 합니다. 서로가 서로의 문서와 소스코드를 읽도록 장려해야 합니다. 서로가 만든 기존의 것을 찾아서 재사용도록 해야 합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여러 중에 부주의한 중복, 참을성 없는 중복, 개발자간의 중복은 읽으면서 크게 공감했습니다. 특히 개발자간의 중복 문제는 작업을 하면서도 최대한 발생하지 않게 하기 위해서 작업 시작 전에 최대한 비슷한 기능을 하는 유틸리티, 서비스 코드가 있는지 찾아보는데 그래도 중복이 발생하고 있을지도 모르겠습니다. 위 내용들을 명심하고 최대한 중복이 발생하지 않게 노력해야겠습니다!&lt;/p&gt;

&lt;h3 id=&quot;8장-직교성&quot;&gt;8장. 직교성&lt;/h3&gt;

&lt;p&gt;기하학에서 두 직선이 직각으로 만난다는 의미를 가지는 직교성은 프로그래밍에서는 독립성을 높이고 컴포넌트 간의 상호 의존성을 낮추는 것을 의미합니다. 이는 한 컴포넌트의 변화가 다른 컴포넌트들에 영향을 미치지 않는 것을 의미합니다. 직교적인 시스템을 구성하면 &lt;strong&gt;테스트의 용이함&lt;/strong&gt;, &lt;strong&gt;재사용성의 증가&lt;/strong&gt;와 같은 생선성 증가와 &lt;strong&gt;나쁜 코드가 전염되지 않게 격리&lt;/strong&gt;하고 특정 벤터, 플랫폼에 덜 종속적이게 되는 리스크 감소라는 장점을 취할 수 있습니다.&lt;/p&gt;

&lt;p&gt;설계를 할 때는 레이어식 접근을 통해 직교성을 높일 수 있습니다. 각 레이어들별로 추상화된 기능을 담당하여 하위의 구현을 바꾸더라도 상위 레이어에 변화를 유발하지 않도록 구성할 수 있습니다. 웹 개발에서도 항상 적용되고 있는 mvc 패턴이 대표적인 사례입니다. 코드를 작성할 때는 코드 간의 결합도를 낮추고 전역 데이터는 지양하고 유사한 기능을 하는 함수는 재사용성을 높여 중복을 줄여야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;9장-가역성&quot;&gt;9장. 가역성&lt;/h3&gt;

&lt;p&gt;우리가 만드는 소프트웨어는 항상 변하는 생물과 같기 때문에 그런 변화에 유연하게 대처할 수 있도록 항상 대비해야 합니다. 가역성이 높다는 것은 결국 변화가 요구될 때 그 요구를 쉽게 받아들이고 해결할 수 있음을 의미합니다. 예를 들어 중간에 데이터베이스가 변하더라도 데이터베이스와 연동되는 부분을 잘 추상화해두면 데이터베이스만 가볍게 교체하고 끝날 수 있습니다. 하지만 그런 추상화 없이 코드 전반에 걸쳐 데이터베이스 연동부가 강하게 결합된다면 매우 골치아픈 작업이 되겠죠^^. 늘 &lt;strong&gt;최종결정이란 없다&lt;/strong&gt;는 것을 명심하면서 작업을 해야겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;10장-예광탄&quot;&gt;10장. 예광탄&lt;/h3&gt;

&lt;p&gt;예광탄은 일반 탄환이 목표물을 맞추기 전에 먼저 목표물로 향하는 궤적에 빛을 남기면서 목표물에 도달하는 탄환을 의미합니다. 이 예광탄 덕분에 실제 탄환이 어디에 맞게될지 알 수 있는 것이죠. 우리가 제품을 만들 때도 이런 예광탄을 유용하게 사용할 수 있습니다. 프로그래밍에서 예광탄은 최종 제품의 초기 버전 정도로 생각하면 될 것 같습니다. 이 초기버전은 전체 기능의 일부만을 지니지만 제품 전체의 구조가 잡히고 모든 모듈 간의 연동이 잘 이루어져서 &lt;strong&gt;동작하는 것이 확인&lt;/strong&gt;된 정교한 상태입니다. 여기에 기능만 채워나간다면 결국 완성된 제품이 될 것입니다.&lt;/p&gt;

&lt;p&gt;예광탄은 다음과 같은 장점을 지닙니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;사용자들에게 뭔가 작동하는 제품을 매우 일찍부터 보여줄 수 있습니다. 이는 사용자들에게 시기별로 얼마나 최종 목표에 가까워졌는지를 매우 가시적으로 보여줄 수 있기에 그들로 하여금 관심도를 끌어올릴 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;개발자들에게 구조를 제공합니다. 애플리케이션의 모든 요소들 간 상호작용을 구성해두었기 때문에 개발자는 필요한 구역으로 가서 기능만 채우면 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;통합 작업을 수시로 쉽게 수행할 수 있습니다. 이미 모든 요소들이 통합된 상태이기 때문에 새롭게 추가된 기능을 하루에도 여러번 통합할 수 있습니다. 이렇게 자주자주 통합작업이 이루어지면 작은 단위의 기능 변화가 시스템 전체에 어떤 변화를 주는지를 더 명확하게 볼 수 있게 됩니다. 그래서 디버깅과 테스트 속도는 자연스럽게 더 빠르고 정확해질 것입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 보고나면 프로토타입이 떠오를 수 있는데, 프로토타입과 예광탄은 엄연히 다르다고 합니다. 예광탄은 실제 제품까지 사용될 코드인 반면 프로토타입은 최종 제품에 대한 특정한 측면을 평가하고 측정하기 위해 일시적으로 사용되고 버려지는 코드입니다. 즉 프로토타입은 예광탄이 발사되기 전에 선행되는 정찰과 정보 수집 행위 정도로 생각하면 됩니다.&lt;/p&gt;

&lt;p&gt;예광탄을 읽다보니 스프링과 같은 프레임워크가 결국 예광탄이 아닐까라는 생각이 들었습니다. 요즘에는 잘 만들어진 예광탄들이 넘쳐나니 감사하면서 개발해야할 것 같습니다!&lt;/p&gt;

&lt;h3 id=&quot;11장-프로토타입과-포스트잇&quot;&gt;11장. 프로토타입과 포스트잇&lt;/h3&gt;

&lt;p&gt;앞서 살펴봤지만 프로토타입을 만드는 것은 시스템 전반의 위험 요소를 조기에 분석해서 매우 저렵한 비용으로 바로잡을 기회를 얻기 위해 필요합니다. 프로토타입은 전체 시스템 중 특정 영역에 대한 검증을 위해 만들어지는 것이기 때문에 그 영역을 제외한 나머지에 대해서는 정교함을 요구할 필요가 없습니다. 만약 나머지에 대해서도 정교함을 가하고 있다면 그것은 프로토타입이 아닐 가능성이 높습니다. 프로토타입을 만들 때는 다음의 세부사항은 무시해도 됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정확성: 더미데이터를 사용해도 됩니다.&lt;/li&gt;
  &lt;li&gt;완전성: 제한된 기능만 제공하면 됩니다.&lt;/li&gt;
  &lt;li&gt;안정성: 에러에 대한 대비를 할 필요가 없습니다. 정해진 시나리오대로 실행시키지 않았을 때 와장창 깨지더라도 상관없습니다.&lt;/li&gt;
  &lt;li&gt;스타일: 프로토타입 코드에 대한 주석, 문서를 만들 필요는 없습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로토타입은 꼭 코드로 만들 필요는 없습니다. 전체 시스템의 아키텍처를 프로토타이핑할 때는 화이트보드, 포스트잇을 사용하는 것만으로도 충분할 때가 많습니다.&lt;/p&gt;

&lt;h3 id=&quot;12장-도메인-언어&quot;&gt;12장. 도메인 언어&lt;/h3&gt;

&lt;p&gt;특정 언어를 선택한다는 것은 그 언어적 특성이 사고방식과 의사소통에 영향을 미치는 것을 의미합니다. 이보다는 도메인의 언어를 이용해서 프로그래밍는 것을 고려해볼 수 있습니다. 여차하면 특정 애플리케이션 도메인에 맞추어진 소형 언어를 만들 수도 있습니다. 개발자 스스로에게 도메인에 더 밀접하게 일할 수 있는 도구를 스스로에게 제공합시다.&lt;/p&gt;

&lt;h3 id=&quot;13장-추정&quot;&gt;13장. 추정&lt;/h3&gt;

&lt;p&gt;프로젝트를 진행을 하다보면 일정 추정, 성능에 대한 추정과 같은 다양한 추정을 하게 됩니다. 하지만 이 추정을 정확히 해낸다는 것은 사실 불가능에 가깝습니다. 다만 누가 더 근사치에 가까울지가 다를 뿐이죠. 하지만 추정을 잘 할 수 있는 방법들은 존재합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;추정을 할 때 양을 표현하는 단위를 신중하게 선택합시다. 예를 들어 어떤 일을 끝내는 데 180일이 걸린다고하면 듣는 이의 입장세너는 가까운 시일 내에 끝날 것이라고 생각하고 정확한 일정이라는 기대를 하게 됩니다. 하지만 그것을 6개월이 걸린다고 바꿔서 말하면 180일보다 대략적이고 유동적인 느낌을 주게 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이미 그 일을 해본 사람에게 물어봅시다. 과거에 비슷한 상황에 처했던 사람이 있다면 그 사람들의 경험을 통해 상당히 성공적인 추정치를 도출해낼 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;시스템의 모델을 만들어봅시다. 가령 응답시간을 추정하고 있다면 몇 가지 트래픽 모델을 만들어보는 겁니다. 모델을 만드는 과정에서 표면에 잘 드러나지 않던 패턴과 프로세스를 발견할 수도 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;추정치를 기록합시다. 그 값이 실제 결과에 얼마나 가까운지 평가하기 위함입니다. 이렇게 추정치와 실제값을 비교하다보면 생각보다 추정치가 실제값에 꽤 가갑다는 것을 인지할 것이고 점차 자신이 도출한 추정치에 대한 믿음이 생길 것입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로젝트 일정 추정은 해당 프로젝트를 경험하는 것 말고는 답이 없습니다. 초기에는 얼마나 많은 공수가 필요한지 감이 안 오지만 시간이 지날수록 이전 작업들의 반복을 통한 감이 생기기 때문에 점차 추정치에 대한 확신이 생길 것입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘2장 실용주의 접근법’을 정리했습니다.</summary></entry></feed>