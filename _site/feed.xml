<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://anstn1993.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://anstn1993.github.io/" rel="alternate" type="text/html" /><updated>2021-12-01T11:03:05+09:00</updated><id>https://anstn1993.github.io/feed.xml</id><title type="html">MunSooKim’s devlog</title><subtitle>일상, 회고, 개발 지식을 기록하기 위한 공간 입니다.</subtitle><entry><title type="html">실용주의 프로그래머 4장</title><link href="https://anstn1993.github.io/2021/12/01/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-4%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 4장" /><published>2021-12-01T00:00:00+09:00</published><updated>2021-12-01T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/12/01/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-4%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/12/01/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-4%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘4장 실용주의 편집증’을 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;4장-실용주의-편집증&quot;&gt;4장. 실용주의 편집증&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;21장-계약에-의한-설계&quot;&gt;21장. 계약에 의한 설계&lt;/h3&gt;

&lt;p&gt;정직한 거래를 보장하는 최선의 해법은 계약입니다. 계약의 당사자들은 모두 자신의 권리와 책임을 지고, 서로에게 기대한 바를 수행하도록 강제합니다. 이런 컨셉을 소프트웨어 모듈에도 적용하면 프로그램의 정확성을 높일 수 있습니다. 정확한 프로그램은 자신의 일이라고 주장하는 것에 대해 더 많지도, 적지도 않게 수행하는 것입니다. 그 주장을 문서화하고 검증하는 것이 바로 계약에 의한 설계(Design By Contract, DBC)입니다.
이 계약은 보통 함수, 메서드와 그것의 호출자 사이에 적용됩니다. 계약에 의한 설계 개념을 개발한 버트란드 마이어는 계약을 이행하기 위한 조건으로 다음 3가지를 말합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;선행조건: 루틴이 호출되기 위해 지켜져야 할 조건으로 이 조건이 위반된 경우에는 루틴이 호출되지 않아야 합니다. 즉 조건이 충족된 데이터를 루틴에 전달하는 것은 호출하는 쪽의 책임입니다.&lt;/li&gt;
  &lt;li&gt;후행조건: 루틴이 완료되었을 때의 상태를 의미합니다. 어떤 루틴에 후행조건이 있으면 그 루틴은 반드시 종료됨을 보장합니다.&lt;/li&gt;
  &lt;li&gt;클래스 불변식: 호출자의 입장에서 루틴이 종료되고 호출자로 제어권이 반환될 때 불변식이 항상 참임을 보장하는 것입니다. 루틴이 진행 중일 때는 불변식이 일시적으로 참이 아닐 수도 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 조건을 정리하자면 만약 호출자가 루틴의 모든 선행조건을 이행한다면, 루틴은 종료시에 모든 호행조건과 불변식이 참이 될 것을 보장해야 하는 것입니다.&lt;/p&gt;

&lt;p&gt;상속과 다형성에서도 이런 계약은 빛을 발합니다. 서브타입은 항상 부모 타입의 한 종류라는 간단한 사실을 잊지 않고 서브클래스에서는 자신의 부모 이상으로 받아들이고, 최소한 자신의 부모만큼은 보증해야 하는데 이런 규칙을 잘 이행하게 할 수 있습니다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘4장 실용주의 편집증’을 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 3장</title><link href="https://anstn1993.github.io/2021/11/23/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-3%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 3장" /><published>2021-11-23T00:00:00+09:00</published><updated>2021-11-23T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/11/23/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-3%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/11/23/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-3%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘3장 기본적인 도구’를 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;3장-기본적인-도구&quot;&gt;3장. 기본적인 도구&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;14장-일반-텍스트의-힘&quot;&gt;14장. 일반 텍스트의 힘&lt;/h3&gt;

&lt;p&gt;프로그래밍은 인간이 하는 것이고 인간은 소위 일반 텍스트(plain text)를 통해서 소통하기 때문에 설계, 구현, 테스트, 문서화 등 대부분의 지식을 저장할 때는 일반 텍스트를 사용하는 것이 바람직합니다. 일반 텍스트가 아닌 이진수, 암호화된 무작위로 나열된 문자들은 그 데이터를 이해하는 데에 필요한 맥락이 없는한 의미를 파악할 수 없습니다. 물론 일반 텍스트를 사용하면 저장 공간에 대한 오버헤드가 생길 수 있고 다른 포맷에 비해 연산에 대한 오버헤드도 생길 수 있지만 그것을 일반 텍스트를 사용했을 때의 장점이 그것을 다 보상하고도 남습니다. 다음이 그 장점입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;구식이 되는 것에 대한 보험: 사람이 읽을 수 있는 형태의 데이터를 사용하면 그 데이터를 생성한 애플리케이션이 죽더라도 살아남을 수 있습니다. 완전히 소멸해버린 레거시 시스템이 생성한 주민등록번호 데이터가 있을 때 그것이 이진 데이터로 표현되어있으면 그 레거시 시스템 없이는 그 데이터의 의미를 파악하지 못합니다. 하지만 일반 텍스트로 되어있다면 그 데이터를 파싱해서 새로운 애플리케이션에 적용하는 건 매우 간단한 작업이 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;호환성: 소스코드 관리 시스템, 컴파일러, ide등과 같이 오늘날의 모든 도구들은 일반 텍스트를 다룰 수 있게 지원합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;더 쉬운 테스트: 시스템 테스트를 구동하게 할 합성 데이터를 만들기 위해 일반 텍스트를 사용하면 별도의 도구 없이 테스트 데이터를 추가, 업데이트, 수정할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;15장-조개-놀이&quot;&gt;15장. 조개 놀이&lt;/h3&gt;

&lt;p&gt;오늘날의 많은 GUI 프로그램은 프로그래머들에게 편리함을 제공하지만, 그럼에도 여전히 셸 명령어들은 프로그래머에게 없어서는 안 될 작업대라고 할 수 있습니다. GUI나 IDE의 장점은 우리가 보는 것이 우리가 얻는 것(WYSIWYG-What You See Is What You Get)이라는 점입니다. 즉 매우 직관적으로 우리에게 필요한 것을 얻을 수 있다는 것이죠. 하지만 동시에 우리가 보는 것이 우리가 얻는 전부(WYSIAYG - What You See Is All You Get)라는 단점이 있습니다. 즉 GUI, IDE가 제공하는 기능 이상의 것은 얻을 수 없습니다.
하지만 셸의 명령어들을 조합하면 우리가 원하는 거의 모든 기능을 얻을 수 있습니다. 그렇기 때문에 반드시 셸과 친근해져야 합니다. 또 이런 자주 사용되는 조합을 스크립트로 작성하여 자동화할 수도 있습니다. 현재 회사에서 배포 자동화에도 셸 스크립트가 사용되고 있는데 이를 제대로 이해하지는 못 한 것 같습니다. 셸의 중요성에 대해서 인지하고는 있지만 그 특유의 지루함 때문에 미루어왔는데 앞으로는 억지로라도 공부를 해야겠습니다..&lt;/p&gt;

&lt;h3 id=&quot;16장-파워-에디팅&quot;&gt;16장. 파워 에디팅&lt;/h3&gt;

&lt;p&gt;에디터는 프로그래밍의 기본적인 원재료인 텍스트를 매우 효율적으로 조작할 수 있게 해주는 도구이기 때문에 마치 자신의 손을 움직이는 것과 같이 익숙한 수준으로 에디터에 대한 숙련도를 높일 필요가 있습니다. 특히 &lt;strong&gt;하나의 에디터를 마스터&lt;/strong&gt;하는 것이 중요합니다. 그리고 모든 편집 작업에서 그 에디터를 사용합시다.
그럼 어떤 에디터를 선택하는지가 중요한데 다음의 요소를 만족해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 플랫폼에서 가능해야 한다.&lt;/li&gt;
  &lt;li&gt;환경 설정이 가능해야 한다.(폰트, 색깔, 윈도우 크기, 키 입력 설정 등)&lt;/li&gt;
  &lt;li&gt;확장이 가능해야 한다. 새 프로그래밍 언어가 나와도 에디터는 사용 가능해야 합니다. 즉 어떤 컴파일러 환경과도 결합 가능해야 합니다.&lt;/li&gt;
  &lt;li&gt;복잡하고 다단계의 작업 수행이 가능하도록 에티터를 프로그램할 수 있어야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;17장-소스코드-관리&quot;&gt;17장. 소스코드 관리&lt;/h3&gt;

&lt;p&gt;소스코드 관리, 즉 형상관리는 프로젝트에서 발생한 실수를 되돌릴 수 있게 해주는 거대한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;undo&lt;/code&gt; 키와 같습니다. 형상관리를 통해서 언제든지 소스코드를 원하는 시점으로 되돌릴 수 있다는 것은 프로젝트의 안정감을 극도로 높여주는 것을 의미합니다. 뿐만 아니라 특정 시점에 어떤 코드를 누가 수정했는지 알 수 있고, 무수히 많은 브랜치를 생성해서 저마다 독립적으로 코드를 작성하고 한 번에 합칠 수도 있기에 생산성도 높아집니다. 또한 결국 형상관리의 핵심은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;undo&lt;/code&gt;에 있기 때문에 소스코드가 아닌 모든 컨텐츠(각종 문서, 메모, makefile, 셸 스크립트, 환경설정 등)는 다 형상관리 하에 두는 것이 좋습니다.
책에는 나오지 않지만 최근에는 많은 프로젝트가 git flow의 규칙에 따라 관리되는데 이런 형상관리가 당연하다고 생각하다가도 막상 이게 없다고 생각하면 너무 암담할 것 같습니다^^&lt;/p&gt;

&lt;h3 id=&quot;18장-디버깅&quot;&gt;18장. 디버깅&lt;/h3&gt;

&lt;p&gt;현존하는 모든 프로그램은 완벽하지 않고 우리가 만든 프로그램도 마찬가지 입니다. 항상 버그가 존재하기 때문에 디버깅을 잘해야 합니다. 디버깅을 잘 하려면 우선 마음가짐을 다잡아야 합니다. 디버깅은 단지 &lt;strong&gt;문제해결&lt;/strong&gt; 그 이상, 이하도 아니라고 생각하고 접근해야 합니다. 버그를 만들어낸 장본인이 누구인지 색출하고, 비난하는 것은 아무 도움이 안 됩니다. 그렇게 한다고 버그가 고쳐지는 것도 아닙니다. 그 다음은, 디버깅을 할 때 당황하지 않아야 합니다. 일정이 촉박하거나 상사나 클라이언트의 압력에 시달리고 있는 상황에서 디버깅을 하는 것은 분명히 쉽지 않겠지만 그럼에도 불구하고 차분하게 원인을 생각해야 합니다. 그리고 디버깅을 할 때 표면에 보이는 문제를 해결하는 것이 아닌 몇 단계 더 깊이 있는 근본적인 문제를 해결하려고 노력해야 합니다.
이렇게 마음가짐을 다잡았다면 이젠 실제로 디버깅을 어떻게 할지 살펴보겠습니다. 당연한 얘기처럼 들릴 수도 있지만 수집할 수 있는 모든 정보를 수집해야 합니다. 필요하다면 최초로 버그를 발견한 사람을 인터뷰할 수도 있어야 합니다. 그리고 제한적인 테스트를 넘어 최종 사용자의 입장에서 모든 케이스를 철저하게 테스트해야 합니다.
이렇게 어떤 버그가 발생하고 있는지를 확실히 파악했으면 그게 프로그램의 입장에서 어떻게 발생하는지 찾아야 합니다. 그걸 알아내는 가장 쉬운 방법은 그 프로그램이 다루는 데이터를 살펴보는 것입니다. 이때 데이터들 간의 상호관계를 시각화해서 보여주는 디버거를 쓸 수 있다면 아주 쉽게 깊이 있는 파악이 가능합니다. 그리고 현재 상태를 넘어 시간별로 데이터의 상태가 어떻게 변하는지를 살펴봐야 할 수도 있습니다. 특히 실시간 시스템, 동시 프로세스, 이벤트 기반 애플리케이션 등에서 그런데, 이럴 때는 트래이싱을 이용합시다. 트레이스 메시지는 규칙적이고 일관된 형식으로 작성되어야 합니다. 왜냐하면 그 메시지에서 특정 영역만 자동으로 뽑아내서 해석하고 싶은 경우가 많기 때문입니다. 예를 들면 자원 누수가 있는지 확인하고 싶어서 open/close를 남겨서 open은 있는데 close는 없는 경우를 찾을 수 있습니다. 또 다른 방법으로는 버그가 발생한 코드에 대해서 다른 사람에게 설명을 해보는 것입니다. 그러면 혼자서 코드를 봤을 때 당연하게 생각하고 지나갈 것을 명시적으로 설명하게 되는데 여기서 의외의 통찰을 얻을 수도 있습니다. 그 외로 자신이 작성한 코드에 근거가 없는 신뢰와 믿음을 가지기보단 항상 증명하려고 하고 서드파티 모듈보단 자신의 코드에 문제가 있을 것이라고 가정하고 디버깅을 합시다.&lt;/p&gt;

&lt;h3 id=&quot;19장-텍스트-처리&quot;&gt;19장. 텍스트 처리&lt;/h3&gt;

&lt;p&gt;텍스트 처리를 위한 언어는 텍스트를 원하는 형태로 제어하기 위해서 꼭 숙달해야 합니다. 유닉스 계열에서는 awk, sed와 같은 명령어를 선호하기도 하고, 파이썬 같은 더 구조적이고 객체지향성을 갖춘 도구를 선호하기도 하는데 뭐가 됐든 이런 기반 언어들 중 하나를 익혀야 합니다. 이런 텍스트 처리 언어를 통해 다음과 같은 것을 할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터베이스 스키마가 들어있는 일반 텍스트 파일로 sql문 생성, 데이터베이스에 엑세스하는 c코드 생성 등..&lt;/li&gt;
  &lt;li&gt;자바 클래스에서 특정 플래그가 달린 멤버에 대한 getter/setter 자동 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;20장-코드-생성기&quot;&gt;20장. 코드 생성기&lt;/h3&gt;

&lt;p&gt;코드 작성하는 코드, 즉 코드 생성기를 만들면 똑같은 기능을 다른 맥락에서 사용할 때 반복할 필요가 없어집니다. 코드 생성기는 크게 두 가지 유형이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;수동적 코드 생성기: 결과를 내기 위해 한 번만 실행되는 생성기 입니다. 한번 생성되면 수동적 코드 생성기와는 독립적인 결과물이 됩니다. 즉 몇 개의 입력을 받으면 그에 맞게 출력을 생성해주는 템플릿이라고 생각하면 됩니다. 가령 새 소스 파일 생성, 언어 간 일회용 변환 수행 등이 수동적 코드 생성기 입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;능동적 코드 생성기: 코드 생성이 필요할 때마다 작동하는 생성기 입니다. 단지 평하기 위해 사용하는 수동적 코드 생성기와 달리 능동적 코드 생성기는 DRY 원칙을 따르려면 필수 입니다. 이 생성기는 하나의 지식 뼈대를 만들어두면 그것을 사용하는 구체화된 형식으로 변환해줍니다. 가령 데이터베이스 애플리케이션을 만들 때 우리가 다루어야 할 환경은 데이터베이스와 데이터베이스에 접근하기 위한 언어 입니다. 이때 데이터베이스 스키마와 언어에서 데이터베이스 테이블 형식을 표현하는 구조체는 형태만 다를뿐 그 지식은 동일합니다. 이는 지식이 중복되는 것입니다. 이런 것을 능동적 코드 생성기로 해결할 수 있습니다. 스키마를 입력하면 그에 맞는 구조체들을 만들어주는 것입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘3장 기본적인 도구’를 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 2장</title><link href="https://anstn1993.github.io/2021/11/17/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-2%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 2장" /><published>2021-11-17T00:00:00+09:00</published><updated>2021-11-17T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/11/17/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-2%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/11/17/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-2%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘2장 실용주의 접근법’을 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;2장-실용주의-접근법&quot;&gt;2장. 실용주의 접근법&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;7-중복의-해악&quot;&gt;7. 중복의 해악&lt;/h3&gt;

&lt;p&gt;우리가 만드는 소프트웨어는 계속해서 변합니다. 설계가 바뀔 수도 있고, 개발 중간에 요구사항이 변하거나, 새로운 요구사항이 도착할 수도 있습니다. 이에 대응하는 일련의 과정이 유지보수가 되는데, 이 유지보수를 방해하는 것이 바로 &lt;strong&gt;중복&lt;/strong&gt;입니다. 유지보수를 쉽게 하려면 &lt;strong&gt;DRY(Don’t Repeat Yourself) 원칙&lt;/strong&gt;을 지켜야 합니다.&lt;/p&gt;

&lt;p&gt;중복은 대부분 다음 범주 중 하나에 속합니다. 각 범주를 살펴보고 해결 방법도 살펴보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;강요된 중복: 환경에 의한 중복입니다. 문서의 내용 자체가 코드의 중복을 요구하는 것처럼 보일 수 있습니다. 때로는 프로그래밍 언어 자체가 중복된 구조를 강제할 수도 있습니다. 이런 문제를 해결하기 위해서 다음을 지킵시다.
    &lt;ul&gt;
      &lt;li&gt;주석의 내용으로 코드의 구현이 아닌 역할을 기술합시다. 구현을 적게 되면 필연적으로 중복되는 내용이 생기게 되고 변화가 생길 때마다 함께 바뀌어야 할 것입니다.&lt;/li&gt;
      &lt;li&gt;문서와 코드를 동기화합시다. 일정의 압박에 시달리기 시작하면 코드 변경에 대한 문서 갱신이 뒤로 미루어지는데 그러지 맙시다!
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부주의한 중복: 설계 실수로 나타난 중복입니다. 가령 선을 담당하는 클래스를 만들 때, 속성으로 선의 길이를 포함할 수 있을 것입니다. 하지만 잘 생각해보면 선은 두 점을 통해 계산되는 값이기 때문에 함수로 빼는 것이 맞습니다. 즉 선을 속성으로 가지는 것은 두 점으로 구할 수 있는 속성을 중복으로 가지는 것입니다.
&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;참을성 없는 중복: 일정의 압박 속에서 이미 존재하는 비슷한 로직에서 살짝만 수정해서 빨리 구현을 할 수 있을 때 발생할 수 있는 중복입니다. 하지만 지금 당장 몇 초를 절약하려고 하다가 필히 나중에 몇 시간을 잃게 될 것입니다. 급할수록 돌아갑시다!
&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;개발자간의 중복: 서로 다른 개발자가 같은 기능을 각자 개발해서 발생하는 중복입니다. 이 문제를 해결하기 위해 다음을 지킵시다.
    &lt;ul&gt;
      &lt;li&gt;개발자간에 적극적이고 빈번한 소통을 장려해야 합니다. 서로가 서로의 문서와 소스코드를 읽도록 장려해야 합니다. 서로가 만든 기존의 것을 찾아서 재사용도록 해야 합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여러 중에 부주의한 중복, 참을성 없는 중복, 개발자간의 중복은 읽으면서 크게 공감했습니다. 특히 개발자간의 중복 문제는 작업을 하면서도 최대한 발생하지 않게 하기 위해서 작업 시작 전에 최대한 비슷한 기능을 하는 유틸리티, 서비스 코드가 있는지 찾아보는데 그래도 중복이 발생하고 있을지도 모르겠습니다. 위 내용들을 명심하고 최대한 중복이 발생하지 않게 노력해야겠습니다!&lt;/p&gt;

&lt;h3 id=&quot;8장-직교성&quot;&gt;8장. 직교성&lt;/h3&gt;

&lt;p&gt;기하학에서 두 직선이 직각으로 만난다는 의미를 가지는 직교성은 프로그래밍에서는 독립성을 높이고 컴포넌트 간의 상호 의존성을 낮추는 것을 의미합니다. 이는 한 컴포넌트의 변화가 다른 컴포넌트들에 영향을 미치지 않는 것을 의미합니다. 직교적인 시스템을 구성하면 &lt;strong&gt;테스트의 용이함&lt;/strong&gt;, &lt;strong&gt;재사용성의 증가&lt;/strong&gt;와 같은 생선성 증가와 &lt;strong&gt;나쁜 코드가 전염되지 않게 격리&lt;/strong&gt;하고 특정 벤터, 플랫폼에 덜 종속적이게 되는 리스크 감소라는 장점을 취할 수 있습니다.&lt;/p&gt;

&lt;p&gt;설계를 할 때는 레이어식 접근을 통해 직교성을 높일 수 있습니다. 각 레이어들별로 추상화된 기능을 담당하여 하위의 구현을 바꾸더라도 상위 레이어에 변화를 유발하지 않도록 구성할 수 있습니다. 웹 개발에서도 항상 적용되고 있는 mvc 패턴이 대표적인 사례입니다. 코드를 작성할 때는 코드 간의 결합도를 낮추고 전역 데이터는 지양하고 유사한 기능을 하는 함수는 재사용성을 높여 중복을 줄여야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;9장-가역성&quot;&gt;9장. 가역성&lt;/h3&gt;

&lt;p&gt;우리가 만드는 소프트웨어는 항상 변하는 생물과 같기 때문에 그런 변화에 유연하게 대처할 수 있도록 항상 대비해야 합니다. 가역성이 높다는 것은 결국 변화가 요구될 때 그 요구를 쉽게 받아들이고 해결할 수 있음을 의미합니다. 예를 들어 중간에 데이터베이스가 변하더라도 데이터베이스와 연동되는 부분을 잘 추상화해두면 데이터베이스만 가볍게 교체하고 끝날 수 있습니다. 하지만 그런 추상화 없이 코드 전반에 걸쳐 데이터베이스 연동부가 강하게 결합된다면 매우 골치아픈 작업이 되겠죠^^. 늘 &lt;strong&gt;최종결정이란 없다&lt;/strong&gt;는 것을 명심하면서 작업을 해야겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;10장-예광탄&quot;&gt;10장. 예광탄&lt;/h3&gt;

&lt;p&gt;예광탄은 일반 탄환이 목표물을 맞추기 전에 먼저 목표물로 향하는 궤적에 빛을 남기면서 목표물에 도달하는 탄환을 의미합니다. 이 예광탄 덕분에 실제 탄환이 어디에 맞게될지 알 수 있는 것이죠. 우리가 제품을 만들 때도 이런 예광탄을 유용하게 사용할 수 있습니다. 프로그래밍에서 예광탄은 최종 제품의 초기 버전 정도로 생각하면 될 것 같습니다. 이 초기버전은 전체 기능의 일부만을 지니지만 제품 전체의 구조가 잡히고 모든 모듈 간의 연동이 잘 이루어져서 &lt;strong&gt;동작하는 것이 확인&lt;/strong&gt;된 정교한 상태입니다. 여기에 기능만 채워나간다면 결국 완성된 제품이 될 것입니다.&lt;/p&gt;

&lt;p&gt;예광탄은 다음과 같은 장점을 지닙니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;사용자들에게 뭔가 작동하는 제품을 매우 일찍부터 보여줄 수 있습니다. 이는 사용자들에게 시기별로 얼마나 최종 목표에 가까워졌는지를 매우 가시적으로 보여줄 수 있기에 그들로 하여금 관심도를 끌어올릴 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;개발자들에게 구조를 제공합니다. 애플리케이션의 모든 요소들 간 상호작용을 구성해두었기 때문에 개발자는 필요한 구역으로 가서 기능만 채우면 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;통합 작업을 수시로 쉽게 수행할 수 있습니다. 이미 모든 요소들이 통합된 상태이기 때문에 새롭게 추가된 기능을 하루에도 여러번 통합할 수 있습니다. 이렇게 자주자주 통합작업이 이루어지면 작은 단위의 기능 변화가 시스템 전체에 어떤 변화를 주는지를 더 명확하게 볼 수 있게 됩니다. 그래서 디버깅과 테스트 속도는 자연스럽게 더 빠르고 정확해질 것입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 보고나면 프로토타입이 떠오를 수 있는데, 프로토타입과 예광탄은 엄연히 다르다고 합니다. 예광탄은 실제 제품까지 사용될 코드인 반면 프로토타입은 최종 제품에 대한 특정한 측면을 평가하고 측정하기 위해 일시적으로 사용되고 버려지는 코드입니다. 즉 프로토타입은 예광탄이 발사되기 전에 선행되는 정찰과 정보 수집 행위 정도로 생각하면 됩니다.&lt;/p&gt;

&lt;p&gt;예광탄을 읽다보니 스프링과 같은 프레임워크가 결국 예광탄이 아닐까라는 생각이 들었습니다. 요즘에는 잘 만들어진 예광탄들이 넘쳐나니 감사하면서 개발해야할 것 같습니다!&lt;/p&gt;

&lt;h3 id=&quot;11장-프로토타입과-포스트잇&quot;&gt;11장. 프로토타입과 포스트잇&lt;/h3&gt;

&lt;p&gt;앞서 살펴봤지만 프로토타입을 만드는 것은 시스템 전반의 위험 요소를 조기에 분석해서 매우 저렵한 비용으로 바로잡을 기회를 얻기 위해 필요합니다. 프로토타입은 전체 시스템 중 특정 영역에 대한 검증을 위해 만들어지는 것이기 때문에 그 영역을 제외한 나머지에 대해서는 정교함을 요구할 필요가 없습니다. 만약 나머지에 대해서도 정교함을 가하고 있다면 그것은 프로토타입이 아닐 가능성이 높습니다. 프로토타입을 만들 때는 다음의 세부사항은 무시해도 됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정확성: 더미데이터를 사용해도 됩니다.&lt;/li&gt;
  &lt;li&gt;완전성: 제한된 기능만 제공하면 됩니다.&lt;/li&gt;
  &lt;li&gt;안정성: 에러에 대한 대비를 할 필요가 없습니다. 정해진 시나리오대로 실행시키지 않았을 때 와장창 깨지더라도 상관없습니다.&lt;/li&gt;
  &lt;li&gt;스타일: 프로토타입 코드에 대한 주석, 문서를 만들 필요는 없습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로토타입은 꼭 코드로 만들 필요는 없습니다. 전체 시스템의 아키텍처를 프로토타이핑할 때는 화이트보드, 포스트잇을 사용하는 것만으로도 충분할 때가 많습니다.&lt;/p&gt;

&lt;h3 id=&quot;12장-도메인-언어&quot;&gt;12장. 도메인 언어&lt;/h3&gt;

&lt;p&gt;특정 언어를 선택한다는 것은 그 언어적 특성이 사고방식과 의사소통에 영향을 미치는 것을 의미합니다. 이보다는 도메인의 언어를 이용해서 프로그래밍는 것을 고려해볼 수 있습니다. 여차하면 특정 애플리케이션 도메인에 맞추어진 소형 언어를 만들 수도 있습니다. 개발자 스스로에게 도메인에 더 밀접하게 일할 수 있는 도구를 스스로에게 제공합시다.&lt;/p&gt;

&lt;h3 id=&quot;13장-추정&quot;&gt;13장. 추정&lt;/h3&gt;

&lt;p&gt;프로젝트를 진행을 하다보면 일정 추정, 성능에 대한 추정과 같은 다양한 추정을 하게 됩니다. 하지만 이 추정을 정확히 해낸다는 것은 사실 불가능에 가깝습니다. 다만 누가 더 근사치에 가까울지가 다를 뿐이죠. 하지만 추정을 잘 할 수 있는 방법들은 존재합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;추정을 할 때 양을 표현하는 단위를 신중하게 선택합시다. 예를 들어 어떤 일을 끝내는 데 180일이 걸린다고하면 듣는 이의 입장세너는 가까운 시일 내에 끝날 것이라고 생각하고 정확한 일정이라는 기대를 하게 됩니다. 하지만 그것을 6개월이 걸린다고 바꿔서 말하면 180일보다 대략적이고 유동적인 느낌을 주게 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이미 그 일을 해본 사람에게 물어봅시다. 과거에 비슷한 상황에 처했던 사람이 있다면 그 사람들의 경험을 통해 상당히 성공적인 추정치를 도출해낼 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;시스템의 모델을 만들어봅시다. 가령 응답시간을 추정하고 있다면 몇 가지 트래픽 모델을 만들어보는 겁니다. 모델을 만드는 과정에서 표면에 잘 드러나지 않던 패턴과 프로세스를 발견할 수도 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;추정치를 기록합시다. 그 값이 실제 결과에 얼마나 가까운지 평가하기 위함입니다. 이렇게 추정치와 실제값을 비교하다보면 생각보다 추정치가 실제값에 꽤 가갑다는 것을 인지할 것이고 점차 자신이 도출한 추정치에 대한 믿음이 생길 것입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로젝트 일정 추정은 해당 프로젝트를 경험하는 것 말고는 답이 없습니다. 초기에는 얼마나 많은 공수가 필요한지 감이 안 오지만 시간이 지날수록 이전 작업들의 반복을 통한 감이 생기기 때문에 점차 추정치에 대한 확신이 생길 것입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘2장 실용주의 접근법’을 정리했습니다.</summary></entry><entry><title type="html">실용주의 프로그래머 1장</title><link href="https://anstn1993.github.io/2021/11/17/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-1%EC%9E%A5.html" rel="alternate" type="text/html" title="실용주의 프로그래머 1장" /><published>2021-11-17T00:00:00+09:00</published><updated>2021-11-17T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/11/17/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-1%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/11/17/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-1%EC%9E%A5.html">&lt;p&gt;앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘1장 실용주의 철학’을 정리했습니다.&lt;/p&gt;

&lt;h1 id=&quot;1장-실용주의-철학&quot;&gt;1장. 실용주의 철학&lt;/h1&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;1-고양이가-내-소스코드를-삼켰어요&quot;&gt;1. 고양이가 내 소스코드를 삼켰어요.&lt;/h3&gt;

&lt;p&gt;우리는 사람이기 때문에 일을 하다보면 실수를 하기 마련입니다. 이 실수에 잘 대처해야 합니다. 실수했을 때, 변명을 하거나 주변 환경(동료, 경영진, 사용하는 도구, 프로그래밍 언어 등..)을 탓하는 것은 프로답지 못합니다. 실수를 정직하게 받아들이고 그것에 &lt;strong&gt;책임&lt;/strong&gt;지는 태도가 중요합니다. 변명보단 &lt;strong&gt;대안&lt;/strong&gt;을 제시합시다. 소스코드를 다 날려놓고 고양이가 삼켰다는 구차한 변명은 하지맙시다! 저도 일을 하면서 이런 책임감을 가지면서 일을 하고 있는지에 대해서 많이 회고해보고 반성해야할 것 같습니다..!&lt;/p&gt;

&lt;h3 id=&quot;2-소프트웨어-엔트로피&quot;&gt;2. 소프트웨어 엔트로피&lt;/h3&gt;

&lt;p&gt;건물의 아주 일부분에 손상이 가해진 시점부터 그 건물의 손상이 매우 빠르게 진행된다는 ‘깨진 창문 이론’은 소프트웨어 개발에도 그대로 적용됩니다. 나쁜 설계, 잘못된 결정, 형편없는 코드와 같은 &lt;strong&gt;깨진 창문을 그대로 내버려 두면 안 됩니다.&lt;/strong&gt; 이런 깨진 창문은 전파력이 너무 강해서 그 소프트웨어를 담당하고 있는 모든 사람들로 하여금 ‘나머지 코드가 전부 쓰레기니까 나도 그렇게 하지 뭐’라는 생각을 하게 할 것입니다. 반대로 코드가 너무 잘 관리되고 있는 소프트웨어를 개발하고 있다면 최소한 자신이 깨진 창문을 만드는 첫번째 사람이 되지 않기 위해 노력할 것입니다. 저도 제가 작업한 내용 중에 저런 깨진 창문을 좀 만든 것 같은데 아직 고치진 않은 것 같습니다.. 빨리 고쳐야겠네요 ㅎㅎ&lt;/p&gt;

&lt;h3 id=&quot;3-돌멩이-수프와-삶은-개구리&quot;&gt;3. 돌멩이 수프와 삶은 개구리&lt;/h3&gt;

&lt;p&gt;어떤 것을 해야 하는지 확실하게 알고, 그것을 하는 것이 좋은 결과를 가져올 것이라는 믿음이 있지만, 그 일을 시작하기까지 많은 난관이 있을 수 있습니다. 그것은 그 일을 할 수 있게 허가를 받는 것이 될 수도 있고, 일을 진행하기 위한 예산을 받는 것이 될 수도 있고, 함께 그 일을 할 동료들의 비관과 무관심이 될 수도 있습니다. 이런 ‘시작 피로’에서 빨리 벗어나기 위해서는 우리 스스로가 &lt;strong&gt;변화의 촉매가 되어야 합니다.&lt;/strong&gt; 하고자 하는 일이 얼마나 매력적이고 좋은 결과를 가져올지를 보여줄 수 있는 프로토 타입을 살짝 보여줍시다. 그리고 ‘여기서 이것만 추가되면 더 좋아질 것 같긴 해’와 같이 중요한 것을 그렇게 중요하지 않은 것처럼 말하면, 주변 사람들은 그 일을 하는 것에 큰 부담을 느끼지 않으면서 열정적으로 참여할 것입니다. 이때 항상 &lt;strong&gt;큰 그림을 기억&lt;/strong&gt;하면서 그 일을 해야 합니다. 일을 계속 하다보면 처음에 그렸던 전체는 잊고 자신이 맡은 일에만 정신이 팔릴 수 있는데, 주변에서 무슨 일을 하는지 항상 살펴보고 큰 그림을 상기합시다.
이 파트는 시간이 지나면 지날수록 저에게 더 중요한 내용이라고 생각합니다. 직급이 올라갈수록 팀 내 동료들이 자신의 역할을 잘 수행하게 하고 시너지를 낼 수 있을지 고민해야 할텐데, 그때 이 파트를 다시 떠올려봐야 할 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;4-적당히-괜찮은-소프트웨어&quot;&gt;4. 적당히 괜찮은 소프트웨어&lt;/h3&gt;

&lt;p&gt;현실에서 완벽한 소프트웨어는 찾아볼 수도 없고, 적당히 괜찮은 소프트웨어를 만드는 것도 어렵습니다. ‘적당히 괜찮은’이 어떤 수준인지는 주관적이기 때문에 타협하는 것이 중요합니다. 이 타협과정에는 당연히 소프트웨어를 사용하게 될 사용자들이 참여해야 합니다. 너무 당연한 말 같지만 실 사용자들에게 요구사항이나 그 소프트웨어가 얼마나 좋아야 하는지 물어보는 경우는 거의 없는 것 같습니다. 우리의 소프트웨어는 결국 사용자들을 위해서 만드는 것이기에 그 사용자들에게 언제부터 그 소프트웨어를 사용할 수 있는지 약속해야 하고, &lt;strong&gt;사용자가 요구한 품질을 맞추는 것이 가장 중요&lt;/strong&gt;합니다. 그 최소한의 약속에 못 미치는 건 당연히 안 되지만, 그 최소한의 약속을 넘어서 더 좋은 기능을 추가하거나, 코드를 더 예쁘게 다듬는다고 출시 데드라인을 넘기는 짓도 해서는 안 됩니다. 즉 &lt;strong&gt;언제 멈춰야 할지 알아야 합니다.&lt;/strong&gt; 대부분의 사람들은 일 년 뒤에 완벽한 소프트웨어보다 오늘 당장 조금 불편한 소프트웨어를 사용하고 싶어 합니다. 그리고 적당히 괜찮은 소프트웨어로 빨리 출시를 할수록 사용자의 피드백을 빨리 받을 수 있게 되고 결국 더 빠른 시간에 더 좋은 솔루션이 될 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;5-지식-포트폴리오&quot;&gt;5. 지식 포트폴리오&lt;/h3&gt;

&lt;p&gt;우리가 프로그래머로서의 자산을 증식하기 위해서는 &lt;strong&gt;지식 포트폴리오&lt;/strong&gt;를 만드는 것이 중요합니다. 이는 금융 포트폴리오 관리와 매우 유사한데 하나씩 살펴보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주기적인 투자: 말 그대로 지식 포트폴리오에 주기적으로 투자해야 합니다. 아주 조금씩이라고 지식 축적을 위한 학습 습관을 기릅시다. 아래 항목부터는 그 습관을 기를 수 있는 구체적인 방법이 나옵니다.&lt;/li&gt;
  &lt;li&gt;다각화: 하나만 보기보단 여러 가지를 알아야 합니다. 이 분야에서 기술의 등장과 퇴장은 매우 빠른 주기로 반복되기 때문입니다. 이는 다음의 항목과도 연관됩니다.&lt;/li&gt;
  &lt;li&gt;리스크 관리: 다각화는 결국 리스크 관리로 이어집니다. 다양한 기술을 학습하면 잠재적 보상이 높은 기술(즉, 장차 핫해질 수 있는 기술)을 접할 가능성이 높아집니다.&lt;/li&gt;
  &lt;li&gt;싸게 사서 비싸게 팔기: 앞서 말한 잠재적 보상이 높은 기술, 즉 아직 그렇게 핫하지 않은 기술을 학습해두면, 향후 이익도 커질 것입니다.&lt;/li&gt;
  &lt;li&gt;검토 및 재조정: 이 분야는 매우 빠르게 변하기 때문에 지금 인기 있는 기술이 내일 당장 쓸모없는 기술이 될 수도 있고, 옛날에 한번 보고 지나친 기술을 다시 꺼내들어야 하는 순간이 올 수도 있습니다. 이런 변화에 민첩하게 대응하기 위해서 항상 지금 투자하고 있는 기술에 대해 검토하고 재조정합시다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이번에는 위의 가이드라인을 통해서 지식 포트폴리오에 자금(지식)을 제공할 방법을 살펴보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;매년 새로운 언어를 최소 하나는 배워라&lt;/li&gt;
  &lt;li&gt;기술 서적을 분기마다 한 권씩 읽어라&lt;/li&gt;
  &lt;li&gt;비 기술 서적도 읽어라&lt;/li&gt;
  &lt;li&gt;수업을 들어라&lt;/li&gt;
  &lt;li&gt;지역 사용자 모임에 참여하라&lt;/li&gt;
  &lt;li&gt;다른 환경에서 실험해보라&lt;/li&gt;
  &lt;li&gt;요즘 흐름을 놓치지 마라&lt;/li&gt;
  &lt;li&gt;인터넷을 이용하라&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;마지막으로 명심해야 할 것은 &lt;strong&gt;비판적 사고&lt;/strong&gt;를 통해 급변하는 기술 시장에서 자신만의 확고한 기준을 갖추는 것입니다. 시기별로 뜨는 기술들이 있지만 그것은 때로 과장 광고일 수도 있습니다. 그리고 그 기술에 열광하는 사람들에게 쉽게 휩쓸려서도 안 됩니다. 이것으로부터 자신의 길을 걸으려면 결국 스스로의 기술적 기반이 탄탄해야 할 것 같습니다. 더 노력해야겠네요.. 하하&lt;/p&gt;

&lt;h3 id=&quot;6-소통하라&quot;&gt;6. 소통하라!&lt;/h3&gt;

&lt;p&gt;혼자서 기가 막힌 아이디어를 가지고 있어도 그것을 타인과 공유하지 않으면 아무 의미가 없습니다. 개발자는 여러 사람들과 소통해야 하기에 그것을 잘해야 합니다. 소통을 잘하기 위해서 다음을 기억합시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;말하고 싶은 게 무엇인지 알아라&lt;/li&gt;
  &lt;li&gt;청중을 알아라:&lt;/li&gt;
  &lt;li&gt;때를 골라라&lt;/li&gt;
  &lt;li&gt;스타일을 골라라&lt;/li&gt;
  &lt;li&gt;멋져 보이게 하라&lt;/li&gt;
  &lt;li&gt;청중을 참여시켜라&lt;/li&gt;
  &lt;li&gt;청자가 되어라&lt;/li&gt;
  &lt;li&gt;응답하라.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><summary type="html">앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. ‘1장 실용주의 철학’을 정리했습니다.</summary></entry><entry><title type="html">이펙티브자바 - 12장. 직렬화</title><link href="https://anstn1993.github.io/2021/08/18/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-12%EC%9E%A5.html" rel="alternate" type="text/html" title="이펙티브자바 - 12장. 직렬화" /><published>2021-08-18T00:00:00+09:00</published><updated>2021-08-18T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/08/18/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-12%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/08/18/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-12%EC%9E%A5.html">&lt;p&gt;조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.&lt;/p&gt;

&lt;h1 id=&quot;12장-직렬화&quot;&gt;12장. 직렬화&lt;/h1&gt;

&lt;p&gt;직렬화는 자바가 객체를 바이트 스트림으로 인코딩하고(직렬화) 그 바이트 스트림으로부터 다시 객체를 재구성하는(역직렬화) 메커니즘입니다. 주로 다른 VM에 전송하거나 디스크에 저장하고 불러오기 위해서 사용합니다. 하지만 직렬화는 사용하지 않는 것이 좋습니다. 이 장에서는 직렬화의 위험과 위험을 최소화하는 방법을 살펴봅니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-85-자바-직렬화의-대안을-찾으라&quot;&gt;아이템 85. 자바 직렬화의 대안을 찾으라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;직렬화의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readObject&lt;/code&gt; 메서드로 바이트 스르팀을 역질렬화하는 과정에서 클래스패스 내의 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Serializable&lt;/code&gt;을 구현한) 모든 타입의 객체를 만들어낼 수 있습니다.(표준 라이브러리나 아파치 커먼즈 컬렉션 같은 서드파티 라이브러리도 포함됩니다.) 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readObject&lt;/code&gt; 메서드는 만들어내는 모든 타입들 안의 코드를 수행할 수 있기에 그 코드들이 모두 공격의 대상이 될 수 있습니다. 아무리 모든 공격에 대비하고 모범사례를 따른다고 자부하더라도 여전히 취약할 수 있습니다. 뿐만 아니라 역릭렬화에 시간이 매우 오래 걸리는 스트림(역직렬화 폭탄)을 역질렬화하게 되면 서비스 거부 공격에 노출됩니다. 역직렬화는 객체 그래프를 타고 들어가면서 객체를 생성해내기 때문에 이 그래프의 깊이가 너무 깊어지면 스택 오버플로가 발생하게 됩니다.&lt;/p&gt;

&lt;p&gt;이런 문제들에 대처하기 위한 방법을 살펴보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;아무것도 역직렬화하지 말자.&lt;/strong&gt;
우리가 작성하는 새로운 시스템에서 자바 직렬화를 써야 할 이유는 전혀 없습니다. 이미 자바 직렬화의 위험을 회피할 수 있는 좋은 크로스-플랫폼 구조화된 데이터 표현(cross-platform structured-data representation)들이 존재합니다. 대표적으로 &lt;strong&gt;JSON, 프로토콜 버퍼&lt;/strong&gt;가 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt;은 텍스트 기반이라서 사람이 읽을 수 있고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로토콜 버퍼&lt;/code&gt;는 이진 표현이라 효율이 좋습니다.(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로토콜 버퍼&lt;/code&gt;도 사람이 읽을 수 있는 텍스트 표현도 지원합니다.) 또한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt;은 데이터 표현을 위해서만 쓰이지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로토콜 버퍼&lt;/code&gt;는 문서를 위한 스키마를 제공하고 올바로 쓰게 강제합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;신뢰할 수 없는 데이터는 절대 역질렬화하지 말자.&lt;/strong&gt;
레거시 시스템 때문에 어쩔 수 없이 직렬화를 사용해야 한다면 신뢰할 수 있는 데이터만 역직렬화해야 합니다. 만약 역직렬화한 데이터가 안전한지 완전히 확신할 수 없다면 자바 9에 추가된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;역직렬화 필터링(ObjectInputFilter)&lt;/code&gt;를 사용합시다. 역직렬화가 되기 전에 필터를 설치하여 특정 클래스를 받아들이거나 거부할 수 있습니다. 크게 ‘기본 수용’ 모드와 ‘기본 거부’ 모드가 있습니다. ‘기본 수용’ 모드는 블랙리스트에 기록된 잠재적으로 위험한 클래스들을 거부합니다. ‘기본 거부’ 모드는 화이트리스트에 기록된 안전하다고 알려진 클래스들만 수용합니다. 기본적으로 ‘기본 거부’ 모드가 더 안전합니다. 블랙리스트 방식은 이미 알려진 위험만 차단할 수 있기 때문입니다. 스왓(SWAT, Serial Whitelist Appplication Trainer)이라는 도구로 화이트리스트를 자동 생성할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;아이템-86-serializable을-구현할지는-신중히-결정하라&quot;&gt;아이템 86. Serializable을 구현할지는 신중히 결정하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;직렬화를 지원하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Serializable&lt;/code&gt;만 구현하면 되기 때문에 매우 쉬워보이지만 길게 보면 아주 비싼 일입니다. 그 이유를 살펴보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Serializable을 구현하면 릴리스한 뒤에는 수정하기 어렵다.&lt;/strong&gt;
클래스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Serializable&lt;/code&gt;을 구현하면 직렬화된 바이트 스트림 인코딩도 하나의 공개 API가 됩니다. 그래서 이 클래스가 널리 퍼지면 그 직렬화 형태도 영원히 지원을 해야 합니다. 만약 커스텀 직렬화가 아닌 자바의 기본 직렬화를 적용하면 그 형태의 클래스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;private&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;package-private&lt;/code&gt; 필드들까지 공개되는 꼴이 되어서 정보 은닉이 무력화됩니다. 또한 추후에 클래스 내부 구현을 바꾸면 원래의 직렬화 형태와 달라지기 때문에 구버전과 신버전의 호환성 문제도 발생합니다. 물론 원래의 코드를 유지하면서 새로운 코드를 추가할 수 있지만 이는 쉽지 않고 불필요하고 지저분한 코드를 남겨두는 꼴입니다. 그러니까 직렬화를 꼭 적용해야 한다면 초기 설계부터 확장성을 고려해야 합니다.
직렬화가 클래스 개선을 방해하는 대표적인 예가 바로 스트림 고유 식별자, 즉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;직렬 버전 UID(Serial version UID)&lt;/code&gt;입니다. 모든 직렬화된 클래스는 고유 식별 번호를 부여받습니다. 해당 클래스에 명시적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;private static final long serialVersionUID&lt;/code&gt;필드를 선언하지 않으면 시스템이 임의로 런타임에 암호 해시 함수를 적용해서 자동으로 클래스에 식별 번호를 부여하게 됩니다. 이 값을 만드는 데 필요한 재료는 클래스 이름, 구현 인터페이스들, 대부분의 클래스 멤버 등입니다. 그래서 이후에 편의 메서드를 추가하는 식으로 하나라도 수정을 가하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;직렬 버전 UID&lt;/code&gt;의 값도 변해서 호환성이 깨집니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;버그와 보안 굼벙이 생길 위험이 높아진다.&lt;/strong&gt;
직렬화는 생성자를 통해 객체를 생성하는 기본적인 루트를 우회하여 객체를 생성하기 때문에 생성자에서 구축한 불변식을 모두 보장해야 하고 생성 도중 공격자가 객체 내부를 들여다볼 수 없도록 해야 한다는 사실을 떠올리기 어렵습니다. 기본 역직렬화를 사용하면 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Serializable을 구현한 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다.&lt;/strong&gt;
직렬화 가능 클래스가 수정되면 신버전 인스턴스를 직렬화하고 구버전으로 역직렬화가 가능한지, 그 반대도 가능한지를 검사해야 합니다. 그래서 테스트해야 할 양이 직렬화 가능 클래스의 수와 릴리스 횟수에 비례해서 증가합니다. 클래스를 처음 제작할 때 커스텀 직렬화 형태로 설계를 잘 했다면 이런 테스트 부담을 줄일 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Serializable&lt;/code&gt;의 구현 여부는 쉽게 결정할 사안이 아닙니다. 하지만 우리가 사용하려고 하는 프레임워크, 라이브러리가 객체의 전송과 저장을 할 때 직렬화를 이용하고 있다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Serializable&lt;/code&gt;의 구현을 할 수밖에 없습니다. 하지만 이런 경우를 제외하고는 구현 여부를 잘 생각해봐야 합니다. 역사적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BigInteger&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Instant&lt;/code&gt; 같은 ‘값’ 클래스와 컬렉션 클래스들은 Serializable을 구현했고, 스레드 풀처럼 ‘동작’하는 객체를 표현하는 클래스들은 대부분 Serializable을 구현하지 않았습니다.
특히 상속용으로 설계된 클래스는 대부분 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Serializable&lt;/code&gt;을 구현하면 안 되고 인터페이스도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Serializable&lt;/code&gt;을 확장하면 안 됩니다. 왜냐하면 이런 클래스를 확장하거나 구현하는 쪽에 부담이 생기기 때문입니다. 이런 클래스는 역질렬화를 하려면 그 상위 클래스는 기본 생성자를 제공해야 합니다. 그런데 만약 그런 생성자를 제공하지 않으면 하위 클래스에서 어쩔 수 없이 직렬화 프록시 패턴을 사용해야만 합니다.&lt;/p&gt;

&lt;p&gt;만약 우리가 작성하는 클래스의 인스턴스 필드가 직렬화와 확장이 모두 가능하면 주의해야 할 사항이 몇 가지 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;인스턴스 필드 값 중 불변식 보장이 필요한 게 있다면 반드시 하위 클래스에서 finalize 메서드를 재정의하지 못하게 막아야 한다.
이렇게 하는 이유는 finalizer 공격을 막기 위함입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;인스턴스 필드 중 기본값으로 초기화되면 위배되는 불변식이 있다면 클래스에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readObjectNoData&lt;/code&gt;메서드를 반드시 추가해야 한다.&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;readObjectNoData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InvalidObjectException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InvalidObjectException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;스트림 데이터가 필요합니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;이 메서드는 기존의 직렬화 가능 클래스에 직렬화 가능 상위 클래스를 추가하는 드문 드문 경우를 위한 메서드입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;마지막으로 정적 멤버 클래스를 제외한 내부 클래스는 직렬화를 구현하지 말아야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-87-커스텀-직렬화-형태를-고려해보라&quot;&gt;아이템 87. 커스텀 직렬화 형태를 고려해보라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;기본 직렬화 형태는 객체의 물리적 표현과 논리적 내용이 같은 경우에만 사용&lt;/strong&gt;해야 합니다. 다음의 예는 기본 직렬화 형태를 써도 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Serializable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/**
  * 성. null이 아니어야 함
  * @serial
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lastName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/**
  * 이름. null이 아니어야 함
  * @serial
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/**
  * 중간이름. 중간이름이 없다면 null
  * @serial
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;middleName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 나머지 코드는 생략&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 성명 클래스는 논리적으로 이름, 성, 중간이름이라는 3개의 문자열로 구성되고, 앞 코드의 인스턴스 필드들은 이 논리적 구성요소를 정확히 반영했습니다. 그런데 기본 직렬화 형태가 적합하다고 판단했더라도 불변식 보장과 보안을 위해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readObject&lt;/code&gt; 메서드를 제공해야 할 때가 많습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Name&lt;/code&gt; 클래스는 성과 이름이 null이 아님을 보장해야 합니다. 이에 관해서는 아이템 88, 90에서 살펴봅니다. 한 가지 더 주목할 점은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;private&lt;/code&gt; 필드임에도 문서화 주석이 달렸다는 것입니다. 앞에서도 말했지만 직렬화를 하는 순간 이미 그 클래스의 모든 구성요소는 공개 API가 되기 때문에 문서화의 대상이 됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@serial&lt;/code&gt; 태그를 사용하면 그 내용은 API 문서에서 직렬화 형태를 설명하는 특별한 페이지에 기록됩니다.&lt;/p&gt;

&lt;p&gt;이번에는 기본 직렬화에 적합하지 않은 예로 살펴보겠습니다. 아래 클래스는 문자열 리스트를 표현합니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StringList&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Serializable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Entry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Entry&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Serializable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Entry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Entry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;previous&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 나머지 코드는 생략&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 클래스는 논리적으로 일련의 문자열을 표현합니다. 물리적으로는 문자열을 이중 연결 리스트로 연결합니다. 이 클래스에 기본 직렬화를 적용하면 각 노드의 양방향 연결 정보를 포함해 모든 엔트리를 다 기록합니다. 이처럼 객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화를 사용하면 크게 네 가지 문제가 생깁니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;공개 API가 현재의 내부 표현 방식에 영구하게 묶인다.&lt;/strong&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;private&lt;/code&gt; 클래스인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StringList.Entry&lt;/code&gt;도 공개 API가 됩니다. 그래서 다음 릴리스에서 내부 표현 방식을 바꿔도 여전히 연결 리스트로 표현된 입력도 처리해야 하기에 사용하지 않음에도 불구하고 코드를 제거할 수 없습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;너무 많은 공간을 차지할 수 있다.&lt;/strong&gt;
위 코드에서 직렬화를 하면 연결 리스트의 모든 엔트리와 연결 정보까지 기록하는데 사실 이들은 직렬화 형태에 포함될 필요가 없습니다. 이런 데이터들로 인해 크기가 너무 커져 디스크에 저장하거나 네트워크로 전송하는 속도가 느려집니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;시간이 너무 많이 걸릴 수 있다.&lt;/strong&gt;
기본 직렬화 로직은 객체 그래프의 위상에 관한 정보가 없어서 그래프를 직접 순회해봐야 하기에 시간이 오래 걸립니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;스택 오버플로를 일으킬 수 있다.&lt;/strong&gt;
객체 그래프를 재귀적으로 순회하는 과정에서 스택 오버플로가 일어날 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StringList&lt;/code&gt;의 합리적인 직렬화 형태는 리스트가 포함한 문자열의 개수를 적고 그 뒤로 문자열들을 나열하는 수준이면 될 것입니다. StringList의 논리적인 구성만 담는 것입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StringList&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Serializable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Entry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 이제 직렬화하지 않는다.&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Entry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Entry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;previous&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 지정한 문자열을 이 리스트에 추가&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/**
  * 이 {@code StringList} 인스턴스를 직렬화한다.
  *
  * @serialData 이 리스트의 크기(포함된 문자열의 개수)를 기록한 후
  * ({@code int}), 이어서 모든 원소를(각각은 {@code String})
  * 순서대로 기록한다.
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writeObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ObjectOutputStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;defaultWriteObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;writeInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 모든 원소를 올바른 순서로 기록&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Entry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;writeObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;readObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ObjectInputStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IOException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;defaultReadObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numElements&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;readInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 모든 원소를 읽어서 이 리스트에 삽입&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numElements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;readObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 나머지 코드는 생략&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;writeObject&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readObject&lt;/code&gt; 메서드가 직렬화 형태를 처리합니다. 그리고 일시적이라는 의미를 가지는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transient&lt;/code&gt; 한정자는 해당 필드가 기본 직렬화 형태에 포함되지 않는다는 표시입니다. 팔드가 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transient&lt;/code&gt;라고 해도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;writeObject&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readObject&lt;/code&gt;가 각각 가장 먼저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;defaultWriteObject&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;defaultReadObject&lt;/code&gt; 메서드를 호출합니다. 이 메서드들은 오직 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;writeObject&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readObject&lt;/code&gt;에서만 호출 가능한 메서드로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;non-static&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;non-transient&lt;/code&gt;필드에 대한 값을 스트림에 쓰고 읽게 됩니다. 필드가 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transient&lt;/code&gt;임에도 이 메서드를 호출하는 이유는 직렬화 명세가 이 작업을 무조건 하라고 하기 때문입니다. 이렇게 해야 향후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;non-transient&lt;/code&gt; 필드가 추가되더라도 호환이 됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;defaultWriteObject&lt;/code&gt; 메서드를 호출하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transient&lt;/code&gt;로 선언하지 않은 모든 필드가 직렬화되니까 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transient&lt;/code&gt;로 선언해도 되는 필드에는 모두 사용합시다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transient&lt;/code&gt;한정자를 생략해야 하는 경우는 해당 객체의 논리적 상태와 무관한 필드라고 확신할 수 있을 때입니다. 그리고 기본 직렬화를 사용하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transient&lt;/code&gt; 필드들은 역직렬화시에 모두 기본값으로 초기화가 됩니다. 만약 기본값으로 초기화가 되면 안 되는 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readObject&lt;/code&gt; 메서드에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;defaultReadObject&lt;/code&gt;를 호출하고 해당 필드를 뭔하는 값으로 복원합시다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;writeObject&lt;/code&gt; 메서드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;private&lt;/code&gt;임에도 문서화 주석이 달린 건 앞에서 봤던 예와 동일한 이유입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@serialData&lt;/code&gt; 태그는 자바독 유틸리트에게 이 내용을 직렬화 형태 페이지에 추가하게끔 합니다.&lt;/p&gt;

&lt;p&gt;직렬화를 이렇게 커스텀하기만 해도 문자열들의 평균 길이가 10이라고 가정했을 때 커스텀 직렬화 버전이 기본 직렬화보다 공간을 절반만 차지하고 스택 오버플로도 발생하지 않아서 직렬화 크기 제한이 없어집니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 직렬화 사용 여부와 상관없이 객체의 전체 상태를 읽는 메서드에 적용해야 하는 동기화 메커니즘은 직렬화에도 적용해야 합니다.&lt;/strong&gt; 예를 들어 모든 메서드를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;로 선언하여 스레드 안전한 객체에서 기본 직렬화를 사용하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;writeObject&lt;/code&gt;도 동기화 메서드로 만들어야 합니다.&lt;/p&gt;

&lt;p&gt;마지막으로 어떤 직렬화 형태를 택하든 &lt;strong&gt;직렬화 가능 클래스 모두에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;직렬 버전 UID&lt;/code&gt;를 명시적으로 부여&lt;/strong&gt;합시다. 이렇게 하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;직렬 버전 UID&lt;/code&gt;가 매번 달라져서 발생하는 호환성 문제도 사라지고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;직렬 버전 UID&lt;/code&gt; 값을 런타임에 생성하는 연산도 하지 않기 때문에 성능 개선도 이루어집니다. 그냥 각 클래스에 아래 같은 한 줄만 추가하면 끝입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serialVersionUID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;무작위로&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;고른&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;값&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;어떤 값이라도 상관 없습니다. 고유할 필요도 없습니다. 클래스 일련 번호를 생성해주는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serialver&lt;/code&gt; 유틸리티를 이용해도 됩니다. 이 유틸리티는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;직렬 버전 UID&lt;/code&gt;가 없던 클래스를 구버전으로 직렬화된 인스턴스와 호환성을 유지하면서 수정하고 싶을 때 사용하기 좋습니다. 구버전에서 생성됐던 자동 생성된 값을 신버전에도 사용해야하기 때문에 직렬화된 인스턴스가 존재하는 구버전 클래스를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serialver&lt;/code&gt; 유틸리티에 입력으로 주고 실행해서 얻을 수 있습니다. 만약 구버전과의 호환성을 끊고 싶으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;직렬 버전 UID&lt;/code&gt;값을 바꿔버리면 됩니다. 이런 경우를 제외하고는 절대 수정하지 맙시다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-88-readobject-메서드는-방어적으로-작성하라&quot;&gt;아이템 88. readObject 메서드는 방어적으로 작성하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readObject&lt;/code&gt; 메서드는 직렬화 과정에서 마치 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public 생성자&lt;/code&gt;로 객체를 생성하는 것과 같기 때문에 그 어떤 바이트 스트림이 넘어오더라도 방어적 복사가 잘 이루어지도록 해야 합니다. 직렬화된 바이트 스트림에 어떤 조작이 가해졌을 지 모르기 때문입니다. 아이템 50에서 살펴봤던 불변인 날짜 범위 클래스를 만들 때 가변인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Date&lt;/code&gt;필드를 사용했습니다. 그 클래스를 직렬화하기로 결정했다고 가정하겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Period&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Serializable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/**
  * @param start 시작 시각
  * @param end 종료 시각; 시작 시각보다 뒤여야 한다.
  * @throws IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다.
  * @throws NullPointerException start나 end가 null이면 발행한다.
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;가&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;보다 늦다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; - &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 나머지 코드는 생략&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Serializable&lt;/code&gt;만 구현하면 될 것이라고 생각할 수 있지만 그렇게 하는 걸로는 불변식을 보장받지 못하게 됩니다. 왜냐하면 직렬화된 데이터를 객체로 변환하는 것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readObjcet&lt;/code&gt;로 일어나지, 위에 정의된 생성자로 일어나는 것이 아니기 때문입니다. 그래서 직렬화된 바이트 스트림이 불변식이 깨진 형태(start가 end보다 늦는 경우)로 변환되어서 들어오면 그대로 불변식이 깨진 객체가 만들어집니다. 아래의 코드를 참조하세요.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BogusPeriod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 진짜 Period 인스턴스에서는 만들어질 수 없는 바이트 스트림&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serializedForm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Period&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deserialize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serializedForm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deserialize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ObjectInputStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ByteArrayInputStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;readObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 문제를 해결학려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Period&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readObject&lt;/code&gt; 메서드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;defaultReadObject&lt;/code&gt;를 호출하고 역직렬화된 객체가 유효한지 검사해야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;readObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ObjectInputStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IOException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;defaultReadObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 불변식을 만족하는지 검사한다.&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;가&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;보다 늦다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;아이템-89-인스턴스-수를-통제해야-한다면-readresolve-보다는-열거-타입을-사용하라&quot;&gt;아이템 89. 인스턴스 수를 통제해야 한다면 readResolve 보다는 열거 타입을 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;싱글턴 패턴으로 인스턴스를 오직 하나만 만드는 것을 보장할 수 있지만, 그 클래스에 직렬화 기능을 구현하는 순간 더 이상 싱글턴을 보장할 수 없게 됩니다. 기본 직렬화를 쓰든, 명시적인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readObject&lt;/code&gt;를 제공하든 직렬화를 통해서 객체를 생성하면 싱글턴 인스턴스와 별개의 인스턴스를 반환하게 됩니다. 하지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readResolve&lt;/code&gt;메서드를 잘 정의해두면 역직렬화 후 새로 생성된 객체를 인수로 하여 이 메서드가 호출되고 이 메서드가 반환하는 객체의 참조가 역직렬화로 생성된 객체를 대신해서 반환하기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readResolve&lt;/code&gt;에서 싱글턴 인스턴스를 반환해주면 됩니다. 그리고 역직렬화된 기존 객체는 가비지 컬렉터에 의해 수거됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Elvis&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Elvis&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Elvis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Elvis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 인스턴스 통제를 위한 readResolve&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;readResolve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 진짜 Elvis를 반환하고, 가짜 Elvis는 가비지 컬렉터에 맡긴다.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;INSTANCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이처럼 역직렬화된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Elvis&lt;/code&gt;가 쓰이지 않으니 직렬화 영태는 아무런 실 데이터를 가질 이유가 없습니다. 그래서 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readResolve&lt;/code&gt;를 인스턴스 통제 목적으로 활용하는 경우에는 객체 참조 타입 인스턴스 필드는 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transient&lt;/code&gt;로 선언해야 합니다.&lt;/strong&gt; 그렇지 않으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readResolve&lt;/code&gt;가 수행되기 전에 역직렬화된 객체의 참조를 공격할 수 있게 됩니다. 싱글턴이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transient&lt;/code&gt;가 아닌 참조 필드를 가지고 있으면 그 필드의 내용은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readResolve&lt;/code&gt; 메서드가 실행되기 전에 격직렬화됩니다. 그럼 조작된 스트림을 써서 해당 참조 필드의 내용이 역직렬화되는 시점에 그 역직렬화된 인스턴스의 참조를 훔쳐올 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에 단순히 인스턴스 통제를 원한다면 &lt;strong&gt;열거 타입&lt;/strong&gt;을 이용하는 것이 가장 좋습니다. 하지만 직렬화가 가능한 인스턴스 통제 클래스를 작성해야 하는데, 컴파일 타임에 어떤 인스턴스들이 있는지 알 수 없는 상황이라면 열거 타입으로 표현하는 것이 불가능하기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readResolve&lt;/code&gt;를 써야 합니다. 이때 메서드의 접근성이 중요합니다. 만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt; 클래스라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readResolve&lt;/code&gt; 메서드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;private&lt;/code&gt;가 되어야 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt;이 아닌 클래스라면 주의해야 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;protected&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public&lt;/code&gt;이면서 하위 클래스에서 재정의하지 않고 사용하면 하위 클래스의 인스턴스를 역직렬화하면서 상위 클래스 인스턴스를 생성하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassCastException&lt;/code&gt;을 일으킬 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-90-직렬화된-인스턴스-대신-직렬화-프록시-사용을-검토하라&quot;&gt;아이템 90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;직렬화 프록시 패턴을 이용하면 직렬화로 인한 버그나 보안 문제를 크게 해결할 수 있습니다. 직렬화 프록시 패턴의 적용은 간단합니다. 바깥 클래스의 논리적 상태를 정밀하게 표현하는 중첩 클래스를 설계하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;private static&lt;/code&gt;으로 선언합니다. 이 클래스가 바깥 클래스의 직렬화 프록시입니다. 중첩 클래스의 생성자는 단 하나여야 하며, 바깥 클래스를 매개변수로 받고, 생성자에서는 단순히 인스턴스 데이터의 복사만 수행합니다.(일관성 검사, 방어적 복사 불필요)&lt;/p&gt;

&lt;p&gt;앞에서 살펴본 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Period&lt;/code&gt; 클래스를 예로 살펴보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SerializationProxy&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Serializable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;nc&quot;&gt;SerializationProxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Period&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serialVersionUID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;234098243823485285L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 아무 값이나 상관없다.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 바깥 클래스에 다음의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;writeReplace&lt;/code&gt; 메서드를 추가합니다. 이 메서드는 범용적이기 때문에 직렬화 프록시를 사용하는 모든 클래스에 그대로 사용하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writeReplace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SerializationProxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 메서드를 정의해두면 자바 직렬화시스템이 바깥 클래스의 인스턴스 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SerializationProxy&lt;/code&gt;의 인스턴스를 반환하게 합니다. 즉, 직렬화가 이루어지기 전에 바깥 클래스의 인스턴스를 직렬화 프록시로 변환해줍니다. 이 덕분에 직렬화 시스템은 절대로 바깥 클래스의 직렬화된 인스턴스를 생성할 수 없습니다. 하지만 공격자가 불변식 훼손 시도를 할 수 있기 때문에 다음의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readObject&lt;/code&gt; 메서드를 바깥 클래스에 추가하면 가볍게 막을 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;readObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ObjectInputStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thorws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InvalidObjectException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InvalidObjectException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;프록시가 필요합니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막으로 바깥 클래스와 논리적으로 동일한 인스턴스를 반환하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readResolve&lt;/code&gt; 메서드를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SerializationProxy&lt;/code&gt; 클래스에 추가합니다. 이 메서드를 통해서 역직렬화 시에 직렬화 시스템이 직렬화 프록시를 다시 바깥 클래스의 인스턴스로 변환하게 해줍니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;readResolve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// public 생성자 사용&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readResolve&lt;/code&gt; 메서드는 공개된 API만 사용해서 인스턴스를 생성합니다. 이 패턴이 아름다운 이유는 직렬화로 인스턴스를 생성하면서도 공개된 생성자, 정적 팩터리 같은 일반적인 방식으로 역직렬화된 인스턴스를 만들어내기 때문입니다. 이미 생성자에서 불변식 검사를 하기 때문에 역직렬화된 인스턴스가 해당 클래스의 불변식을 만족하는지 별도로 검사할 필요도 없습니다. 즉 직렬화 프록시 패턴은 가짜 바이트 스트림 공격과 내부 필드 탈취 공격을 프록시 수준에서 차단해주게 됩니다.
그리고 앞선 두 접근법과 달리 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Period&lt;/code&gt; 필드를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt;로 선언해도 되기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Period&lt;/code&gt; 클래스를 진정한 불변으로 만들 수도 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 직렬화 프록시 패턴도 한계는 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;클라이언트가 멋대로 확장할 수 있는 클래스에는 적용할 수 없다.&lt;/li&gt;
  &lt;li&gt;객체 그래프에 순환이 있는 클래스에도 적용할 수 없다.
이런 객체의 메서드를 직렬화 프록시의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readResolve&lt;/code&gt; 안에서 호출하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClassCastException&lt;/code&gt;이 발생할 것입니다. 직렬화 프록시만 가졌을 뿐, 실제 객체는 아직 만들어진 것이 아니기 때문입니다.&lt;/li&gt;
  &lt;li&gt;방어적 복사보다 느리다.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><category term="자바" /><summary type="html">조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.</summary></entry><entry><title type="html">이펙티브자바 - 11장. 동시성</title><link href="https://anstn1993.github.io/2021/08/11/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-11%EC%9E%A5.html" rel="alternate" type="text/html" title="이펙티브자바 - 11장. 동시성" /><published>2021-08-11T00:00:00+09:00</published><updated>2021-08-11T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/08/11/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-11%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/08/11/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-11%EC%9E%A5.html">&lt;p&gt;조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.&lt;/p&gt;

&lt;h1 id=&quot;11장-동시성&quot;&gt;11장. 동시성&lt;/h1&gt;

&lt;p&gt;동시성 프로그래밍은 단일 스레드 프로그래밍보다 어렵지만 오늘날은 당연하게 쓰이는 멀티코어 프로세서의 힘을 제대로 활용하기 위해서는 꼭 알아야 합니다. 이번 장에서는 동시성 프로그램을 정확하게 만들고 잘 문서화하기 위한 내용들을 살펴봅니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-78-공유-중인-가변-데이터는-동기화해-사용하라&quot;&gt;아이템 78. 공유 중인 가변 데이터는 동기화해 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;키워드는 메서드나 블록에 사용하여 한 스레드만 수행되도록 보장합니다. 대부분의 프로그래머들이 동기화를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;배타적 실행(한 스레드가 객체의 상태를 변경하는 동안 다른 스레드가 보지 못하게 막아서 일관되지 않은 객체의 상태를 보지 못 하게 함)&lt;/code&gt;의 용도로만 생각합니다. 하지만 사실 하나가 더 있습니다. 바로 &lt;strong&gt;동기화된 메서드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해준다는 것입니다.&lt;/strong&gt; 자바 언어 명세상 long, double 외의 변수를 읽고 쓰는 동작은 원자적입니다. 즉 굳이 동기화를 하지 않더라도 항상 어떤 스레드가 정상적으로 저장한 값을 온전히 읽어옴을 보장합니다. 하지만 그 저장된(혹은 수정된) 값이 다른 스레드에게 ‘보이는가(가시성)’는 보장하지 않습니다. 이는 다르게 말하면 시간상으로 가장 직전에 저장(수정)된 값을 다른 스레드가 읽을 수 있음을 보장하지 않는다는 것을 의미합니다. 이해를 돕기 위해 잠시 관련된 내용을 살펴보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;멀티스레드-환경에서의-가시성&quot;&gt;멀티스레드 환경에서의 ‘가시성’&lt;/h4&gt;

&lt;p&gt;멀티스레드로 동작하는 프로그램에서는 성능의 향상을 위해서 각 스레드는 변수를 각자의 캐시로 복사해서 읽어들이게 됩니다. 그렇기 때문에 가시성에 문제가 생기게 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextSerialNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 변수를 두 개의 스레드가 공유한다고 가정하겠습니다. 스레드 A는 우선 메인 메모리에 올라간 변수를 캐시 메모리로 복사해옵니다. 그리고 변수의 값을 1 증가시켰습니다. 일반적으로 우리가 원하는 결과는 나머지 스레드인 B가 다시 변수의 값을 사용할 때 1이 증가된 값으로 사용하는 것입니다. 하지만 그렇게 동작하지 않을 수 있습니다. 왜냐하면 스레드 A가 값을 1 증가시키더라도 그것은 캐시 메모리에 저장되지, 메인 메모리에 바로 저장되는 것은 아니기 때문입니다. 그리고 캐시 메모리에 저장된 값이 언제 메인 메모리로 반영될지 알 수 없습니다. 앞서 언급한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;저장된(혹은 수정된) 값이 다른 스레드에게 '보이는가(가시성)'는 보장하지 않는다&lt;/code&gt;는 것은 이처럼 값을 저장하더라도 그것이 메인 메모리에 바로 반영되지 않아서 다른 스레드가 그 저장된 값을 바로 읽을 수 있다는 보장이 없음을 의미합니다. 그래서 다음의 코드는 우리가 생각한대로 동작하지 않습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StopThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stopRequested&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;backgroundThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stopRequested&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;backgroundThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stopRequested&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드는 stopRequested 필드를 backgroundThread가 계속 폴링하다가 true가 되면 스레드 실행을 종료시킬 목적으로 작성을 했습니다. 하지만 위 코드를 실행시켜보면 종료되지 않고 계속 실행됩니다. 원인은 가시성이 보장되지 않기 때문입니다. 메인 스레드가 stopRequested의 값을 true로 바꾸더라도 그것은 메인 스레드의 캐시 메모리에만 반영됐을뿐이고, backgroundThread가 읽어들인 stopRequested의 값은 여전히 false이기 때문에 프로그램은 종료되지 않습니다. 특히 위의 코드는 JVM이 다음과 같이 최적화할 수도 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 원래 코드&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stopRequested&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 최적화된 코드&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stopRequested&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 OpenJDK 서버의 VM이 실제로 적용하는 끌어올리기(hoisting)라는 최적화 기법입니다. 이렇게 프로그램은 응답 불가 상태가 됩니다. 그럼 이런 가시성의 문제를 해결하려면 어떻게 하면 될까요?&lt;/p&gt;

&lt;h4 id=&quot;synchronized-volatile을-사용하여-가시성의-문제를-해결하자&quot;&gt;synchronized, volatile을 사용하여 가시성의 문제를 해결하자&lt;/h4&gt;

&lt;p&gt;가시성 문제를 해결하는 첫번째 방법은 공유되는 필드를 synchronized 키워드로 동기화하는 것입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StopThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stopRequested&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;requestStop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stopRequested&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;stopRequested&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stopRequested&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;backgroundThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stopRequested&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;backgroundThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;requestStop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stopRequested&lt;/code&gt; 변수를 쓰는 메서드(requestStop)와 읽는 메서드(stopRequested)를 모두 동기화했습니다. 이때 &lt;strong&gt;읽기, 쓰기 메서드를 모두 동기화&lt;/strong&gt;하는 것이 중요합니다. 간혹 쓰기 메서드만 동기화하면 된다고 생각할 수 있지만 그것으로는 충분하지 않습니다. 쓰기만 동기화하여 메인 메모리까지 값을 반영하더라도 읽기를 동기화하지 않으면 여전히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backgroundThread&lt;/code&gt;는 캐싱된 값을 가져올 것이기 때문입니다. 그렇기 때문에 읽기도 동기화를 하여 메인 메모리에서 값을 읽어오게 해야 합니다.
다음은 큰 성능 차이는 없지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;보다 좀 더 빠른 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt; 한정자를 공유되는 변수에 사용해서 가시성 문제를 해결할 수도 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StopThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stopRequested&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;backgroundThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stopRequested&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;backgroundThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stopRequested&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아까와 달리 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stopRequested&lt;/code&gt;변수에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt; 한정자만 붙여서 코드가 간결해졌습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt; 한정자는 &lt;strong&gt;배타적 수행과는 상관없지만 항상 가장 최근에 기록된 값을 읽게 됨을 보장&lt;/strong&gt;합니다. 즉 변수에 대한 쓰기와 읽기 작업이 캐시 메모리가 아닌 메인 메모리에서 이루어지게 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;volatile을-사용할-때-주의할-점&quot;&gt;volatile을 사용할 때 주의할 점&lt;/h4&gt;

&lt;p&gt;앞의 내용을 보면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;를 완벽히 대체할 수 있다고 생각할 수 있지만 그렇지 않습니다. 이미 언급했듯이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt;한정자는 &lt;strong&gt;배타적 수행과는 무관&lt;/strong&gt;합니다. 그래서 배타적 수행이 필요한 상황에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt;만 사용하면 완전히 잘못된 결과를 가져올 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextSerialNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;generateSerialNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextSerialNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 메서드는 멀티스레드 환경에서 매번 고유한 값을 반환하게 하기 위해서 작성되었지만 고유한 값을 반환하지 못합니다. 만약 스레드 A가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generateSerialNumber&lt;/code&gt; 메서드를 호출하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;++&lt;/code&gt;연산자가 수행되기 직전에 스레드 B가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generateSerialNumber&lt;/code&gt; 메서드에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nextSerialNumber&lt;/code&gt; 값을 읽어버리면 스레드 A, B 모두 같은 값을 가지게 됩니다.(안전 실패) 이는 공유 변수의 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt; 한정자로 인해서 증가된 값이 메인 메모리에 바로 저장되는 것과는 별개의 문제입니다. 그렇기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generateSerialNumber&lt;/code&gt; 메서드를 동기화해서 배타적 실행이 되게 해줘야 합니다.
정리하자면, &lt;strong&gt;한 스레드는 값을 쓰기만 하고, 한 스레드는 값을 읽기만 한다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt;을 쓰면 되지만, 두 스레드가 모두 읽기/쓰기에 관여한다면 그땐 반드시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;를 사용해야 합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;동시성-라이브러리를-적극-활용하자&quot;&gt;동시성 라이브러리를 적극 활용하자&lt;/h4&gt;

&lt;p&gt;사실 위에서 살펴본 문제를 이미 해결해둔 라이브러리가 존재합니다. 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.concurrent.atomic&lt;/code&gt;인데요. 이 패키지에는 락 없이도 스레드 안전한 프로그래밍을 지원하는 클래스들이 담겨 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt;을 통한 가시성을 보장하면서도 배타적 실행까지 지원합니다. 대표적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AtomicLong&lt;/code&gt;을 보겠습니다. 이 클래스는 앞서 살펴봤던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generateSerialNumber&lt;/code&gt;를 더 우수한 성능으로 제공합니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AtomicLong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextSerialNum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AtomicLong&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;generateSerialNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextSerialNum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getAndIncrement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;가장-좋은-방법은-가변-데이터를-공유하지-않는-것이다&quot;&gt;가장 좋은 방법은 가변 데이터를 공유하지 않는 것이다&lt;/h4&gt;

&lt;p&gt;위와 같은 문제를 해결하는 가장 좋은 방법은 가능하다면 &lt;strong&gt;가변 데이터는 단일 스레드에서만 사용&lt;/strong&gt;하고 공유하지 않는 것입니다. 이 정책을 한 번 정했다면 그 사실을 문서에도 남겨서 이후 유지보수 과정에서도 정책이 잘 지켜지도록 해야 합니다. 그리고 사용하려는 프레임워크와 라이브러리를 깊게 이해해야 합니다. 외부 코드로 인해서 데이터의 공유 정책이 깨질 수 있기 때문입니다.&lt;/p&gt;

&lt;h4 id=&quot;전체를-동기화하기보단-공유하는-부분만-동기화하자&quot;&gt;전체를 동기화하기보단 공유하는 부분만 동기화하자&lt;/h4&gt;

&lt;p&gt;한 스레드가 데이터를 다 수정하고 다른 스레드에 공유할 때 공유하는 부분만 동기화하는 것이 좋습니다. 그럼 그 객체를 다시 수정할 일이 생기기 전까지 다른 스레드들은 동기화 없이 자유롭게 값을 읽어갈 수 있습니다. 이런 객체를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사실상 불변&lt;/code&gt;이라고 합니다. 그리고 다른 스레드에 이런 객체를 건네는 행위를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안전 발행&lt;/code&gt;이라고 합니다. 안전 발행을 하는 방법은 많습니다. 클래스의 초기화 과정에서 객체를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정적 필드&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile 필드&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final 필드&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;락을 통해 접근하는 필드&lt;/code&gt;에 저장하면 됩니다. 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동시성 컬렉션&lt;/code&gt;에 저장하는 방법도 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-79-과도한-동기화는-피하라&quot;&gt;아이템 79. 과도한 동기화는 피하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;이번 아이템에서는 아이템 78과 대조적으로 너무 과도한 동기화로 인한 성능 저하, 교착상태 등과 같은 부작용에 대해서 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;가시성이 보장되지 않아서 발생한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;응답 불가&lt;/code&gt;와 배타적 실행이 보장되지 않아서 발생한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안전 실패&lt;/code&gt;를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 클라이언트에 양도하면 안 됩니다.&lt;/strong&gt; 예를 들면 동기화 영역 안에서 재정의할 수 있는 메서드는 호출하면 안 되고 클라이언트가 넘겨준 함수 객체를 호출해서도 안 됩니다. 이런 메서드들은 동기화 영역의 입장에서는 외계인과 같기 때문에 무슨 짓을 할지 알 수 없고 통제할 수도 없기에 이런 메서드들 때문에 예외가 발생하거나 교착상태에 빠지거나 데이터가 훼손될 수도 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ObservableSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ForwardingSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ObservableSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SetObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SetObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;observers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SetObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;notifyElementAdded&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SetObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;added&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;added&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;added&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;notifyElementAdded&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;added&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// nofityElementAdded 호출&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 클래스는 집합에 원소가 추가되면 알림을 받을 수 있습니다. 즉 관찰자 패턴입니다. 알림을 받기 위해서 관찰자들은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addObserver&lt;/code&gt;를 통해서 구독을 할 수 있고, 반대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;removeObserver&lt;/code&gt;를 통해 해제할 수도 있습니다. 두 메서드에는 모두 아래의 함수형 인터페이스를 전달합니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@FunctionalInterface&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SetObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ObservableSet에 원소가 추가되면 호출&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;added&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ObservableSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 이상한 시도를 해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 인자로 람다를 전달하면 this로 자신을 참조하지 못하기 때문에 익명클래스를 전달&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SetObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;added&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ObservableSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;removeObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ConcurrentModificationException 유발!&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;added&lt;/code&gt; 메서드에서 원소가 23이 되면 자기 자신을 구독 해제하는 관찰자를 추가했습니다. 우리의 예상으로는 23까지 출력을 하고 종료가 될 것이라고 생각하지만 23까지 출력하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentModificationException&lt;/code&gt;을 던집니다. 왜냐하면 관찰자의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;added&lt;/code&gt;메서드가 호출되는 영역이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;observers&lt;/code&gt;를 순회하는 도중이기 때문입니다. 이는 허용되지 않은 동작이기 때문에 예외가 발생한 겁니다. 그런데 순회를 할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;observers&lt;/code&gt;로 락을 걸고 동기화를 한 상태이고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;added&lt;/code&gt; 메서드가 호출하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;removeObserver&lt;/code&gt; 메서드도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;observers&lt;/code&gt;로 락을 걸어서 둘은 동시에 실행되지 않을 것 같은데 왜 이런 문제가 발생한 걸까요? 그것은 바로 자신이 콜백을 거쳐 되돌아와 수정하는 것까지는 막지 못하기 때문입니다.&lt;/p&gt;

&lt;p&gt;이번에는 구독해지를 실행자 서비스를 이용해 다른 스레드가 수행하는 코드를 작성해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SetObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;added&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ObservableSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newSingleThreadExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;removeObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 스레드가 종료될 때까지 대기&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ExecutionException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AssertionError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;shutDown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드는 교착상태를 유발하는 코드입니다. 백그라운드 스레드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s.removeObserver&lt;/code&gt;를 호출하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;observers&lt;/code&gt;에 대한 락을 획득하려고 하지만 획득하지 못합니다. 이미 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;added&lt;/code&gt;를 호출한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notifyElementAdded&lt;/code&gt; 메서드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;observers&lt;/code&gt;에 대한 락을 획득했기 때문입니다. 그런데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notifyElementAdded&lt;/code&gt; 메서드는 관찰자를 제거하기만을 기다리고 있는 상황이기 때문에 교착상태가 됩니다.&lt;/p&gt;

&lt;p&gt;이처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;added&lt;/code&gt;메서드를 외계인 메서드로 삼아서 다양한 부작용에 대해서 살펴봤습니다. 이런 예외 발생이나 교착상태 증상을 해결하는 방법은 간단합니다. 외계인 메서드 호출을 동기화 블록 바깥으로 옮기면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;notifyElementAdded&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SetObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;snapshot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;snapshot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 복사본을 만들어서 복사본으로 순회&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SetObserver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;snapshot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;observer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;added&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드처럼 복사본을 만들고 그 복사본으로 순회를 하면 됩니다. 사실 이런 역할을 하는 라이브러리도 이미 존재합니다. 바로 자바의 동시성 컬렉션 라이브러리인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CopyOnWriteArrayList&lt;/code&gt;입니다. 이 클래스의 이름이 말해주듯이 내부를 수정하는 작업은 항상 복사본을 만들어서 수행해줍니다. 이 클래스를 사용하면 기존 코드에서 동기화 블록은 모두 제거해도 됩니다.&lt;/p&gt;

&lt;p&gt;지금까지는 올바른 동작에 관해 살펴봤다면 성능 측면에서도 살펴보겠습니다. 멀티코어가 일반화된 오늘날 과도한 동기화를 피하는 것이 어느 때보다 중요해졌습니다. 오늘날 &lt;strong&gt;과도한 동기화가 초래하는 진짜 비용은 락을 얻는 과정에서 발생하는 것이 나리나 경쟁하느라 낭비하는 시간, 즉 병렬로 실행할 기회를 잃고, 모든 코어가 메모리를 일관되게 보기 위한 지연 시간에서 발생&lt;/strong&gt;합니다. 또한 동기화는 VM의 코드 최적화를 제한한다는 점에서도 비용이라고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;만약 가변 클래스를 작성해야 한다면 다음 둘 중 하나를 따릅시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동기화를 전혀 하지 말고 그 클래스를 동시에 사용해야 하는 클라이언트 쪽에서 동기화하도록 하자.&lt;/li&gt;
  &lt;li&gt;동기화를 클래스 내부에서 수행해 스레드 안전한 클래스로 만들자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이때 가능하다면 첫번째 방식을 선택하고 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등하게 개선할 수 있을 때만 두번째 방법을 선택해야 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util(Vector, HashTable 제외)&lt;/code&gt;은 클라이언트가 동기화하도록 했고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.concurrent&lt;/code&gt;는 스스로 동기화를 하는 방식을 취했습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StringBuffer&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Random&lt;/code&gt; 클래스는 거의 항상 단일 스레드에서만 사용되었음에도 불구하고 위의 조언을 지키지 않고 내부적으로 동기화를 수행했습니다. 그래서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StringBuilder&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadLocalRandom&lt;/code&gt;같이 내부적으로 동기화를 지원하지 않는 클래스도 등장한 겁니다. 하지만 반대로 내부적으로 반드시 동기화를 해야만 하는 경우도 있습니다. 대표적으로 앞에서 살펴봤던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generateSerialNumber&lt;/code&gt;메서드 입니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-80-스레드보다는-실행자-테스크-스트림을-애용하라&quot;&gt;아이템 80. 스레드보다는 실행자, 테스크, 스트림을 애용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.concurrent&lt;/code&gt; 패키지는 실행자 프레임워크라는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있습니다. 이를 통해 성능이 뛰어난 작업 큐를 단 한 줄로 생성할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newsingleThreadExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;태스트를 실행자에게 넘기려면 다음과 같이 하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실행자를 종료시키려면 다음과 같이 하면 됩니다. 종료에 실패하면 vm 자체가 종료되지 않을 것입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이외에도 실행자 서비스의 기능은 아래와 같이 다양합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특정 태스크가 완료되기를 기다린다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get&lt;/code&gt; 메서드)&lt;/li&gt;
  &lt;li&gt;태스크 모음 중 아무거나 하나(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;invokeAny&lt;/code&gt; 메서드) 혹은 모든 태스크(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;invokeAll&lt;/code&gt;)가 완료되기를 기다린다.&lt;/li&gt;
  &lt;li&gt;실행자 서비스가 종료하기를 기다린다.(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;awaitTermination&lt;/code&gt; 메서드)&lt;/li&gt;
  &lt;li&gt;완료된 태스크들의 결과를 차례로 받는다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExecutorCompletionService&lt;/code&gt; 이용)&lt;/li&gt;
  &lt;li&gt;태스크를 특정 시간에 혹은 주기적으로 실행하게 한다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ScheduledThreadPoolExecutor&lt;/code&gt; 이용)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;큐를 둘 이상의 스레드가 처리하게 하고 싶다면 다른 정적 팩터리를 이용하여 다른 종류의 실행자 서비스(스레드 풀)를 생성하면 됩니다. 스레드 풀의 스레드 개수는 고정할 수도 있고 유동적으로 늘어나거나 줄어들게 설정할 수도 있습니다. 이때 필요한 실행자 대부분은 java.util.concurrent.Executors의 정적 팩토리들을 이용해서 생성할 수 있을 것입니다. 만약 평범하지 않은 실행자를 원한다면 ThreadPoolExecutor 클래스를 직접 사용해도 됩니다. 이 클래스로 스레드 풀 동작을 결정하는 거의 모든 속성을 설정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;실행자 서비스는 애플리케이션의 특성을 고려하여 잘 선택해야 합니다. 만약 작은 프로그램이나 가벼운 서버라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executors.newCachedThreadPool&lt;/code&gt;이 일반적으로 좋은 선택이 될 것입니다. 하지만 무거운 프로덕션 서버에서 사용하기에는 부적합합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CachedThreadPool&lt;/code&gt;은 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임되어 실행됩니다. 이게 가능한 이유가 가용한 스레드가 없으면 바로 새로 하나를 생성하기 때문입니다. 만약 서버가 무겁다면 CPU 이용률이 100%로 치닫게 될 것이고, 새로운 태스크가 도착할 때마다 스레드를 생성하여 상황이 악화됩니다. 그래서 이럴 때는 스레드 개수가 고정되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executors.newFixedThreadPool&lt;/code&gt;을 선택하거나 완전히 통제할 수 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadPoolExecutor&lt;/code&gt;를 직접 사용하는 편이 훨씬 낫습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.concurrent&lt;/code&gt;가 추가되면서 이제 작업 큐를 손수 만들고 스레드를 직접 다루는 것은 일반적으로 지양해야 합니다. 스레드를 직접 다루면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;작업 단위(task)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수행 메커니즘 역할(ExecutorService)&lt;/code&gt;을 모두 수행하게 됩니다. 이 둘을 분리하여 태스크 수행을 실행자 서비스에 맡기게 되면 원하는 태스크 수행 정책을 선택할 수 있고 변경도 쉽습니다.&lt;/p&gt;

&lt;p&gt;자바 7이 되면서 실행자 프레임워크는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;포크-조인(fork-join)&lt;/code&gt; 태스크도 지원하기 시작했습니다. 이 태스크는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;포크-조인 풀&lt;/code&gt;이라는 특별한 실행자 서비스가 실행해줍니다. 포크-조인 태스크는 작은 하위 태스크로 나뉠 수 있고 포크 조인 풀을 구성하는 스레드들이 이 태스크를 처리하고 먼저 일을 끝낸 스레드가 다른 스레드의 남은 태스크를 가져와서 대신 처리할 수 있습니다. 이렇게 노는 스레드 없이 CPU를 최대한 활용하여 높은 처리량과 낮은 지연시간을 달성할 수 있습니다. 병렬 스트림도 이 포크-조인 풀을 이용해서 구현했습니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-81-wait와-notify보다는-동시성-유틸리티를-애용하라&quot;&gt;아이템 81. wait와 notify보다는 동시성 유틸리티를 애용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;자바 5에서 도입된 고수준의 동시성 유틸리티로 인해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notify&lt;/code&gt;를 사용할 일이 거의 없어졌습니다. 그러니 고수준 동시성 유틸리티를 사용하는 것이 좋습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.concurrent&lt;/code&gt;의 고수준 유틸리티는 세 범주로 나눌 수 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실행자 프레임워크&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동시성 컬렉션&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동기화 장치&lt;/code&gt;입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실행자 프레임워크&lt;/code&gt;는 이미 살펴봤으니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동시성 컬렉션&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동기화 장치&lt;/code&gt;를 살펴보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;동시성-컬렉션&quot;&gt;동시성 컬렉션&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동시성 컬렉션&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Queue&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Map&lt;/code&gt;과 같은 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션입니다. 이 컬렉션은 동기화를 내부에서 구현했습니다. 따라서 동시성을 무력화하는 것은 불가능하며 외부에서 락을 추가로 사용하면 오히려 속도가 느려집니다. 동시성의 무력화가 불가능해서 여러 메서드를 하나로 묶어서 원자적으로 호출하는 것도 불가능하여 자주 사용되는 기본 동작들을 조합하여 원자적으로 실행시켜주는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상태 의존적 수정 메서드&lt;/code&gt;들이 추가되었습니다. 이 메서드들은 아주 유용해서 일반 컬렉션 인터페이스에도 디폴트 메서드로 추가되었습니다. 가장 대표적인 메서드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Map.putIfAbsent(key, value)&lt;/code&gt;입니다. 이 메서드는 인자로 주어진 키에 매핑된 값이 있으면 그냥 그 값을 반환하고, 없다면 인자로 전달된 value로 설정을 하고 null을 반환합니다. 이 메서드 덕분에 스레드 안전한 정규화 맵을 쉽게 구현할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;intern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;putIfAbsent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;을 이용해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String.intern&lt;/code&gt;메서드를 흉내냈습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putIfAbsent&lt;/code&gt;를 호출하기 전에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get&lt;/code&gt;메서드로 1차 검사를 수행하여 필요할 때만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putIfAbsent&lt;/code&gt;가 호출되도록 만든 아주 훌륭한 코드입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동시성 컬렉션&lt;/code&gt;이 나오면서 기존의 동기화한 컬렉션(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Collections.synchronizedMap&lt;/code&gt;)을 사용할 이유가 사라졌습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동시성 컬렉션&lt;/code&gt;이 훨씬 훌륭한 성능을 보입니다.&lt;/p&gt;

&lt;p&gt;한 가지 더 볼만한 컬렉션 인터페이스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlockingQueue&lt;/code&gt;입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Queue&lt;/code&gt;를 확장한 클래스로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;take&lt;/code&gt;메서드는 큐의 첫 원소를 거냅니다. 이때 큐가 비어있으면 새로운 원소가 추가될 때까지 대기하게 됩니다. 이런 특성 덕분에 이 큐는 작업 큐(생산자-소비자 큐)로 쓰기에 적합합니다. 하나 이상의 생산자 스레드가 태스크를 큐에 추가하면 하나 이상의 소비자 스레드가 큐에 있는 작업을 꺼내 처리하는 형태입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadPoolExecutor&lt;/code&gt;를 포함한 대부분의 실행자 서비스 구현체는 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlockingQueue&lt;/code&gt;를 이용하여 구현됐습니다.&lt;/p&gt;

&lt;h4 id=&quot;동기화-장치&quot;&gt;동기화 장치&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동기화 장치&lt;/code&gt;는 스레드가 다른 스레드를 기다릴 수 있게 제어하여 작업을 조율할 수 있습니다. 가장 자주 쓰이는 것으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CountDownLatch&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Semaphore&lt;/code&gt;입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CyclicBarrier&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Exchanger&lt;/code&gt;도 있지만 덜 쓰입니다. 그리고 가장 강력한 장치는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Phaser&lt;/code&gt;입니다. 이 장에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CountDownLatch&lt;/code&gt;만 간단히 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CountDownLatch&lt;/code&gt;는 하나 이상의 스레드가 또 다른 하나 이상의 스레드 작업이 끝날 때까지 기다리게 합니다. 이 클래스의 생성자는 int값을 받으며 이 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;countDown&lt;/code&gt;메서드를 몇번 호출해야 대기 중인 스레드들을 깨우는지 결정합니다. 이 장치를 이용하면 아주 유용한 기능들을 매우 쉽게 구현할 수 있습니다. 어떤 동작들을 동시에 시작해서 모두 완료하기까지의 시간을 재는 프로그램을 구축한다고 해보겠습니다. 이 프로그램은 메서드 하나로 구성되고 이 메서드는 동작들을 실행할 실행자와 동작을 몇 개나 동시에 수행할 수 있는지를 의미하는 동시성 수준(concurrency)을 매개변수로 받습니다. 타이머 스레드가 시계를 시작하기 전에 모든 작업자 스레드는 동작 수행 준비를 마칩니다. 그리고 타이머 스레드가 시간 측정을 시작하면 작업자 스레드들은 일을 시작합니다. 그리고 마지막 작업자 스레드가 동작을 마치면 타이머 스레드는 시계를 멈춥니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Executor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;concurrency&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;CountDownLatch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ready&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CountDownLatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;concurrency&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;CountDownLatch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CountDownLatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;CountDownLatch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CountDownLatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;concurrency&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;concurrnecy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 각각의 태스크가 ready를 카운트다운해서 준비가 완료됐음을 알린다.&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;ready&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;countDown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ready의 카운트가 모두 소진될 때까지(즉 모든 태스크가 준비 완료된 상태) 태스크가 진행되지 못하게 대기&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currenThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;countDown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 태스크가 완료되면 done을 카운트 다운하여 작업이 완료됐음을 알린다.&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;ready&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 각각의 태스크가 모두 카운트다운하여 카운트가 0이 될때까지 대기(0이 되면 모든 태스크가 준비가 완료되었음을 의미)&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startNanos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;system&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 시간 측정 시작&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;countDown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// start.await()로 대기 상태에 있는 태스크들이 실행되도록 카운트다운 처리&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 태스크가 작업을 실행하면서 done의 카운트가 0이 될때까지 대기(0이 되면 모든 태스크의 작업이 완료되었음을 의미)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startNanos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코드에 대한 설명은 주석을 참고해주세요. 그 외에 위 코드에서 살펴볼 것들이 있습니다. 우선 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time&lt;/code&gt; 메서드에 넘겨진 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실행자(executor)&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;concurrency&lt;/code&gt; 매개변수로 지정한 동시성 수준만큼의 스레드를 생성할 수 있는 상태로 세팅이 되어서 전달되어야 합니다. 그렇지 않으면 이 메서드는 스레드 기아 교착상태에 빠져서 결코 끝나지 않습니다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;이 발생하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread.currentThread().interrupt()&lt;/code&gt; 관용구를 사용하여 인터럽트를 되살려 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run&lt;/code&gt; 메서드에서 빠져나오게 합니다. 이렇게 해야 실행자가 인터럽트를 적절히 처리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;마지막으로 시간을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.nanoTime&lt;/code&gt;으로 측정한 것에 주목해야 합니다. 시간 간격을 측정할 때는 항상 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.currentTimeMillis&lt;/code&gt;대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.nanoTime&lt;/code&gt;을 사용합시다. 그게 더 정확하고 정밀하며 시스템의 실시간 시계의 시간 보정에 영향을 받지 않습니다.&lt;/p&gt;

&lt;h4 id=&quot;레거시-코드를-다뤄야-할-때&quot;&gt;레거시 코드를 다뤄야 할 때…&lt;/h4&gt;

&lt;p&gt;새로운 코드는 항상 고수준의 동시성 유틸리티를 사용해야겠지만 불가피하게 레거시 코드를 다룰 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait/notify&lt;/code&gt;를 다루어야 할 때도 있을 것입니다. 그런 상황에 대비하여 이 둘의 사용에서 주의해야 할 내용들을 살펴보겠습니다. 우선 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt;는 자신이 잡고 있던 락을 놓고 대기하며 다른 스레드가 실행되게끔 합니다. 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notify&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt;상태에 있는 다른 스레드가 깨어나서 락을 잡고 실행을 재개하게 합니다. 즉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt;를 호출하여 대기상태에 있던 스레드가 있을 때, 다른 스레드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notify&lt;/code&gt;를 호출하면 깨어나서 락을 잡고 실행을 이어가는 것입니다.&lt;/p&gt;

&lt;p&gt;그럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt;를 사용하는 표준 방식을 살펴보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;synchronizde&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;조건이&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;충족되지&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;않았다&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 락을 놓고, 깨어나면 다시 잡는다.&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 조건이 충족됐을 때의 동작 수행&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt; 메서드는 반드시 객체를 잠근 동기화 영역 안에서 호출해야 합니다. 그리고 &lt;strong&gt;반드시 대기 반복문 관용구를 사용하여 반복문 안에서만 호출합시다.&lt;/strong&gt; 이렇게 하는 이유는 대기로 가기 전에 조건 검사를 하고 조건에 충족하면 바로 작업을 하게 하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;응답 불가&lt;/code&gt;상태에 빠지지 않게 예방하는 것입니다. 그리고 대기 후에 조건 검사를 하여 충족되지 않으면 다시 대기하도록 하는 것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안전 실패&lt;/code&gt;를 막는 조치입니다.&lt;/p&gt;

&lt;p&gt;그런데 조건이 충족되지 않았는데도 스레드가 깨어날 수 있는 상황이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스레드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notify&lt;/code&gt;를 호출한 다음 대기 중이던 스레드가 깨어나는 사이에 다른 스레드가 락을 얻어 그 락이 보호하는 상태를 변경한다.&lt;/li&gt;
  &lt;li&gt;조건이 만족되지 않았음에도 다른 스레드가 실수로 혹은 악의적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notify&lt;/code&gt;를 호출한다. 공개된 객체를 락으로 사용해서 대기하는 클래스는 이런 위험에 노출된다.&lt;/li&gt;
  &lt;li&gt;깨우는 스레드가 대기 중인 스레드들 중 일부만 조건이 충족되어도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notifyAll&lt;/code&gt;을 호출해 모든 스레드를 깨워버린다.&lt;/li&gt;
  &lt;li&gt;대기중인 스레드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notify&lt;/code&gt;없이도 깨어나는 경우가 있다. 이를 허위 각성이라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 이유 때문에 대기 반복문 관용구를 사용해야 합니다.&lt;/p&gt;

&lt;p&gt;그럼 이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notify&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notifyAll&lt;/code&gt; 중에서는 무엇을 선택하느냐도 문제가 되는데 일반적으로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notifyAll&lt;/code&gt;을 사용합시다. 그렇게 해야 깨어나야 하는 모든 스레드가 깨어남을 보장하니 더 정확한 결과를 얻을 것입니다. 비록 깨어나지 말아야 할 스레드가 깨어난다고 할지라도 대기 반복문 관용구를 잘 적용했다면 그런 스레드는 다시 대기 상태로 들어갈 것이니 정확성에는 영향을 미치지 않을 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-82-스레드-안전성-수준을-문서화하라&quot;&gt;아이템 82. 스레드 안전성 수준을 문서화하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;여러 스레드가 동시에 호출하는 메서드의 동작을 문서화하는 것은 클라이언트가 적절한 수준의 동기화를 하기 위한 중요한 정보를 제공하기 때문에 꼭 필요합니다. 그럼 문서화에서 주의해야 할 점이나 알아야 할 점들에 대해서 살펴보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;api-문서에-synchronized-한정자가-보이는-메서드는-스레드-안전하다&quot;&gt;API 문서에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 한정자가 보이는 메서드는 스레드 안전하다?&lt;/h4&gt;

&lt;p&gt;우선 이 말은 두 가지 측면에서 틀렸습니다. 자바독은 기본 옵션으로 생성한 문서에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 한정자를 포함하지 않습니다. 메서드 선언에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 한정자를 선언할지는 구현 이슈이지, api에 속하는 내용은 아니기 때문입니다. 그래서 그 메서드가 스레드 안전하다고 믿을 수 없습니다. 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 유무로 스레드 안전성을 알 수 있다는 주장의 전제는 ‘스레드 안전성은 모 아니면 도’가 되어야 하는데 이 또한 잘못된 내용입니다. 스레드 안전성도 수준이 존재합니다. 그리고 멀테스레드 환경세어 api를 안전하게 사용하려면 클래스가 지원하는 스레드 안전성 수준을 정확히 명시해야 합니다. 다음 목록은 스레드 안전성이 높은 순으로 나열한 것입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;불변&lt;/strong&gt;: 해당 클래스의 인스턴스는 상수와 같아서 외부 동기화도 필요 없습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Long&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BigInteger&lt;/code&gt;가 대표적입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;무조건적 스레드 안전&lt;/strong&gt;: 해당 클래스의 인스턴스는 가변이긴 하지만 내부에서 동기화처리를 하여 외부에서 동기화 없이 사용해도 안전합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AtomicLong&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;이 대표적입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;조건부 스레드 안전&lt;/strong&gt;: 무조건적 스레드 안전과 같지만 일부 메서드는 동시에 사용하기 위해 외부 동기화가 필요합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Collections.synchronized&lt;/code&gt; 래퍼 메서드가 반환한 컬렉션들이 여기에 속합니다. 이 컬렉션들이 반환한 반복자는 외부 동기화가 필요합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;스레드 안전하지 않음&lt;/strong&gt;: 해당 클래스의 인스턴스는 수정될 수 있습니다. 동시에 사용하려면 각각의 메서드 호출을 클라이언트가 선택한 외부 동기화 메커니즘으로 감싸야 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashMap&lt;/code&gt; 같은 기본 컬렉션이 대표적입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;스레드 적대적&lt;/strong&gt;: 해당 클래스는 모든 메서드 호출을 외부에서 동기화로 감싸도 멀티스레드 환경에서 안전하지 않습니다. 이런 클래스는 정적 데이터를 동기화 없이 수정합니다. 이런 클래스는 일반적으로 문제를 고쳐서 재배포하거나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deprecated API&lt;/code&gt;로 지정합니다. 앞서 살펴본 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generateSerialNumber&lt;/code&gt; 메서드에서 내부 동기화를 하지 않으면 스레드 적대적이게 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;문서화시-주의할-점&quot;&gt;문서화시 주의할 점&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;조건부 스레드 안전&lt;/code&gt; 클래스는 주의해서 문서화해야 합니다. 어떤 순서로 호출할 때 외부 동기화가 필요한지, 그 순서로 호출하려면 어떤 락 혹은 드물게 락들을 얻어야 하는지 알려줘야 합니다. 보통 인스턴스 자체를 락으로 얻지만 예외도 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Collections.synchronizedMap&lt;/code&gt;의 문서에는 다음과 같이 써 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;synchronizedMap이&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환한&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;맵의&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;컬렉션&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;뷰를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;순회하려면&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반드시&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;그&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;맵을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;락으로&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;사용해&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;수동으로&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;동기화하라&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;synchronizedMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;());&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;keySet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 동기화 블록 밖에 있어도 된다.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s가 아닌 m으로 동기화해야 함&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;이대로&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;따르지&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;않으면&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;동작을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;예측할&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;수&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;없다&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;추가적으로 클래스의 스레드 안전성은 보통 클래스의 문서화 주석에 작성하지만, 독특한 특성의 메서드라면 해당 메서드의 주석에 기재합니다. 열거 타입은 굳이 불변이라고 스지 않아도 되고 반환 타입만으로는 명확히 알 수 없는 정적 팩토리라면 자신이 반환하는 객체의 스레드 안전성을 문서화해야 합니다.&lt;/p&gt;

&lt;p&gt;클래스 외부에서 사용할 수 있는 락을 제공하면 클라이언트에서 일련의 메서드 호출을 원자적으로 할 수 있습니다. 대신 내부에서 처리하는 고성능 동시성 제어 메커니즘과 혼용할 수 없게 됩니다. 그래서 ConcurrentHashMap 같은 동시성 컬렉션과 함께 사용하지 못합니다. 또한 공개된 락을 오래 쥐고 놓지 않는 서비스 거부 공격을 수행할 수도 있습니다. 이런 공격을 막으려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;synchronized&lt;/code&gt; 메서드 대신 비공개 락 객체를 사용하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;클라이언트 바깥에서는 락 객체를 볼 수 없으니 동기화에 관여할 수 없습니다. 그리고 이런 비공개 락은 무조건적 스레드 안전 클래스에서만 사용할 수 있습니다. 조건부 스레드 안전 클래스에서는 호출 순서에 필요한 락이 무엇인지 공개해야 하기 때문입니다. 특히 이런 락 객체는 상속용으로 설계한 클래스에서 활용하기 좋습니다. 상속용 클래스에서 자신의 인스턴스를 락으로 사용하면 하위 클래스는 아주 쉽게 기반 클래스의 동작을 방해할 수 있기 때문입니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-83-지연-초기화는-신중히-사용하라&quot;&gt;아이템 83. 지연 초기화는 신중히 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;지연 초기화를 하면 값이 실제로 쓰이는 순간까지 초기화를 미룰 수 있어서 주로 최적화 용도로 쓰이지만 초기화 때 발생하는 위험한 순환 문제를 해결하는 효과도 있습니다. 하지만 지연 초기화는 꼭 필요할 때까지는 하지 맙시다. 지연 초기화는 클래스나 인스턴스 생성 시의 초기화 비용은 줄지만 최초에 그 초기화가 이루어지는 필드에 접근하는 비용은 커집니다. 그래서 상황에 따라 오히려 성능을 더 악화시킬 수도 있습니다. &lt;strong&gt;지연 초기화가 명백하게 좋은 경우는 해당 클래스의 인스턴스 중 그 필드를 사용하는 인스턴스의 비율은 낮은데, 그 필드를 초기화하는 비용은 큰 경우입니다.&lt;/strong&gt; 하지만 이마저도 정말 그러한지 확인할 수 있는 유일한 방법은 지연 초기화 적용 전후의 성능을 비교해보는 것입니다.&lt;/p&gt;

&lt;p&gt;멀티스레드 환경으로 가면 지연 초기화를 하기 어려워집니다. 지연 초기화를 적용하는 필드를 둘 이상의 스레드가 공유하면 무조건 동기화해야 합니다. 가장 좋은 건 일반적인 초기화를 적용하는 것이겠지만 멀티스레드 환경에서 지연초기화를 하는 방법들을 살펴보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FieldType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FieldType&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getField&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computeFieldValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 성능 때문에 &lt;strong&gt;정적 필드&lt;/strong&gt;를 지연 초기화해야 한다면 &lt;strong&gt;지연 초기화 홀더 클래스 관용구&lt;/strong&gt;를 사용하는 것입니다. 클래스는 클래스가 처음 쓰일 때 비로소 초기화된다는 특성을 이용한 관용구입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FieldHolder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FieldType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computeFieldValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FieldType&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getField&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FieldHolder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;field&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getField&lt;/code&gt;메서드가 처음 호출되는 순간 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FieldHolder.field&lt;/code&gt;가 처음 읽히면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FieldHolder&lt;/code&gt;클래스 초기화를 촉발하게 됩니다. 이 관용구는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getField&lt;/code&gt;메서드가 필드에 접근할 때 동기화를 전혀 하지 않아서 성능 걱정을 할 필요가 없습니다. 일반적인 VM은 클래스를 초기화할 때만 필드 접근을 동기화할 것입니다.&lt;/p&gt;

&lt;p&gt;성능 때문에 &lt;strong&gt;비정적 인스턴스 필드&lt;/strong&gt;를 지연 초기화를 해야 한다면 &lt;strong&gt;이중 검사 관용구&lt;/strong&gt;를 사용합시다. 이 방식은 초기화된 필드에 접근할 때 동기화 비용을 없애줍니다. 이름처럼 필드의 값을 두 번 검사하는데 처음에는 동기화 없이 검사를 하고 다음에는 동기화하여 검사합니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FieldType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FieldType&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getField&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;FieldType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 첫 번째 검사 (동기화하지 않음)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 두 번째 검사 (동기화)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computeFieldValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;field&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이때 주목할 점은 필드를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt; 한정자로 선언했다는 점과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getField&lt;/code&gt;메서드에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;result&lt;/code&gt;라는 지역변수를 사용했다는 것입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;volatile&lt;/code&gt;을 쓴 이유는 두번째 검사에서 먼저 진입한 스레드가 필드를 초기화하더라도 그것이 다른 스레드에게는 보이지 않아서 여전히 필드를 null로 인식하여 초기화하는 가시성 문제를 막기 위해서입니다. 그리고 지역변수를 별도로 사용한 이유는 그 필드를 딱 한 번만 읽도록 보장하여 성능을 향상시키기 위함입니다. 이는 저수준 동시성 프로그래밍에서 표준적으로 적용되는 우아한 방법입니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-84-프로그램의-동작을-스레드-스케줄러에-기대지-말라&quot;&gt;아이템 84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;멀티 스레드 프로그램을 작성할 때 운영체제의 스레드 스케줄러에 의해서 실행이 좌지우지되게 하면 안 됩니다. 그렇게 해야 여러 플랫폼에 이식하기 좋습니다. 그런 이식성 좋은 프로그램을 작성하는 가장 좋은 방법은 &lt;strong&gt;실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것입니다.&lt;/strong&gt; 그래야 스레드 스케줄러의 기민이 줄어들고 스케줄링 정책이 아주 상이한 시스템에서도 동작이 크게 달라지지 않습니다. 핵심은 실행 가능한 스레드의 수를 적게 유지하는 것입니다. 그러기 위해서는 각 스레드가 작업을 완료한 후에는 다음 일거리가 생길 때까지 대기하도록 하는 것입니다. &lt;strong&gt;스레드는 당장 처리해야 할 작업이 없으면 실행돼서는 안 됩니다.&lt;/strong&gt; 실행자 프레임워크를 예로 들면, 스레드 풀 크기를 적절히 설정하고 작업은 짧게 유지하면 됩니다. 이때 너무 짧으면 작업을 분배하는 부하가 너무 커질 수 있으니 주의합시다.&lt;/p&gt;

&lt;p&gt;그리고 스레드가 절대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;busy waiting&lt;/code&gt; 상태가 되면 안 됩니다. 즉 공유 객체의 상태가 바뀔 때까지 쉬지 않고 검사해서는 안 된다는 의미입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;busy waiting&lt;/code&gt;은 스레드 스케줄러의 변덕에 취약하고 프로세서에 부하를 많이 가해서 다른 유용한 작업이 실행될 기회를 박탈합니다. 스레드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bounded waiting&lt;/code&gt; 상태가 유지되도록 합시다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><category term="자바" /><summary type="html">조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.</summary></entry><entry><title type="html">이펙티브자바 - 10장. 예외</title><link href="https://anstn1993.github.io/2021/08/04/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-10%EC%9E%A5.html" rel="alternate" type="text/html" title="이펙티브자바 - 10장. 예외" /><published>2021-08-04T00:00:00+09:00</published><updated>2021-08-04T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/08/04/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-10%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/08/04/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-10%EC%9E%A5.html">&lt;p&gt;조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.&lt;/p&gt;

&lt;h1 id=&quot;10장-예외&quot;&gt;10장. 예외&lt;/h1&gt;

&lt;h2 id=&quot;아이템-69-예외는-진짜-예외-상황에만-사용하라&quot;&gt;아이템 69. 예외는 진짜 예외 상황에만 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;가끔 예외를 진짜 예외 상황이 아닌데 사용하는 경우가 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;climb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArrayIndexOutOfBoundsException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드는 배열의 범위를 초과하면 발생하는 예외를 잡아서 반복을 종료시킵니다. 향상된 반복문을 이용하지 않고 위와 같이 작성을 하면 성능이 더 좋다고 생각해서 작성한 것이지만 실상은 그 반대입니다. 하지만 이보다 더 심각한 문제가 있습니다. 의도치 않은 예외의 발생으로 인해서 진짜 문제가 무엇인지 알지 못하고 넘어갈 수 있다는 것입니다. 예를 들면 반복문 몸체 안에서 호출되는 메서드 안에서 배열을 순회하다 ArrayIndexOutOfBoundsException를 던지게 되면 위의 코드로는 예외가 발생했는지조차 알 수 없습니다. 만약 표준 관용구를 사용해서 반복을 했다면 예외를 잡지 않고 스택 추적 정보를 출력하면서 해당 스레드가 종료되어 문제를 인지했을 것입니다. 이처럼 &lt;strong&gt;예외는 절대로 일상적인 제어 흐름용으로 사용하면 안 됩니다.&lt;/strong&gt; 반드시 예외 상황에서만 써야 합니다.&lt;/p&gt;

&lt;p&gt;이런 원칙은 API 설계에도 그대로 적용됩니다. 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 합니다. 만약 특정 상태에서만 호출 가능한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상태 의존적 메서드&lt;/code&gt;를 제공하는 클래스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상태 검사 메서드&lt;/code&gt;도 함께 제공해야 합니다. Iterator의 next(상태 의존적 메서드), hasNext(상태 검사 메서드)가 대표적입니다. for-each 관용구도 내부적으로 hasNext를 사용합니다. 상태 검사 메서드의 대안도 존재합니다. 상태가 올바르지 않을 때는 빈 옵셔널이나 null 같은 특수한 값을 반환하는 것입니다. 다음은 상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용합니다. 상태 검사 메서드 호출과 상태 의존적 메서드 호출 사이에 상태가 변경될 수 있기 때문입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;성능이 중요한 상황에서 상태 검사 메서드와 상태 의존적 메서드의 일부 로직이 중복된다면 옵셔널이나 특정 값을 선택합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;나머지 경우에는 상태 검사 메서드 방식이 조금 더 낫습니다. 가독성이 조금 더 좋고, 잘못 사용했을 때 발견하기가 쉽습니다. 왜냐하면 상태 검사 메서드 호출을 하지 않고 상태 의존적 메서드를 호출하면 예외를 던질 것이기 때문입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;아이템-70-복구할-수-있는-상황에는-검사-예외를-프로그래밍-오류에는-런타임-예외를-사용하라&quot;&gt;아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;자바는 문제 상황을 알리는 타입(throwable)으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;검사 예외&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;런타임 예외&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;에러&lt;/code&gt;를 제공합니다. 이 중 어떤 걸 사용해야 하는지 헷갈린다면 다음의 좋은 지침들을 참고하면 좋을 것 같습니다.&lt;/p&gt;

&lt;h4 id=&quot;호출하는-쪽에서-복구하리라-여겨지는-상황이라면-검사-예외를-사용하라&quot;&gt;호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.&lt;/h4&gt;

&lt;p&gt;검사 예외는 컴파일 레벨에서 예외 전파의 가능성을 알 수 있기 때문에 try/catch로 잡거나 바깥으로 전파하도록 강제하게 됩니다. 따라서 검사 예외들을 사용한 API는 클라이언트에게 해당 예외들이 발생할 수 있음을 알려주게 됩니다. 물론 클라이언트가 예외를 잡기만 하고 아무 것도 하지 않고 넘길 수도 있지만 별로 좋은 생각은 아닙니다.&lt;/p&gt;

&lt;p&gt;비검사 예외는 검사 예외를 제외한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;런타임 예외&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;에러&lt;/code&gt;에 해당합니다. 이 둘은 프로그램에서 잡을 필요가 없거나 통상적으로 잡지 말아야 하는 예외입니다. 비검사 예외를 던졌다는 건 복구가 불가능하거나 더 실행해도 실이 많은 경우를 의미합니다. 이런 throwable이 던져지면 스레드는 그냥 적절한 오류 메시지를 내뱉으며 중단됩니다.&lt;/p&gt;

&lt;p&gt;그리고 검사 예외가 발생한다면 복구의 가능성이 있다는 것이기 때문에 반드시 복구에 필요한 정보를 알려주는 접근자 메서드를 제공합시다.&lt;/p&gt;

&lt;h4 id=&quot;프로그래밍-오류를-나타낼-때는-런타임-예외를-사용하자&quot;&gt;프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.&lt;/h4&gt;

&lt;p&gt;런타임 예외의 대부분은 메서드가 정상적으로 실행되기 위한 전제조건을 만족하지 못할 때 발생합니다. 그런데 간혹 어떤 오류가 복구할 수 있는 상황인지, 프로그래밍 오류인지 구분하기 힘든 경우가 있습니다. 자원 부족 문제가 진짜 자원 부족의 문제일 수도 있지만, 말도 안 되게 큰 범위의 배열을 할당해서 생긴 프로그래밍적인 문제일 수 있습니다. 이때 어떤 예외를 사용할 것인지는 설계자의 판단에 달여있습니다. 만약 일시적으로 트래픽이 몰려서 자원 부족이 발생했고, 시간이 지나면 회복 가능하다고 판단이 되면 검사 예외를, 그렇지 않다면 런타임 예외를 사용하는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;에러는 보통 JVM의 자원 부족, 불변식 깨짐 등으로 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용합니다. 즉 에러는 코드 레벨을 넘어 시스템 레벨에서 발생하는 문제인 경우가 많아서 그것을 코드레벨에서 잡아서 처리하는 것이 무의미합니다. 일반적인 규약상으로 Error의 하위 클래스를 만드는 것은 자제해야 합니다. &lt;strong&gt;직접 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 합니다.&lt;/strong&gt; 또한 AssertionError를 제외한 Error를 throw문으로 직접 던지는 일도 없어야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-71-필요-없는-검사-예외-사용은-피하라&quot;&gt;아이템 71. 필요 없는 검사 예외 사용은 피하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;검사 예외는 발생한 문제를 프로그래머가 처리하여 안정성을 높이게끔 해주기 때문에 API의 질을 높일 수 있습니다. 하지만 모든 경우에 좋은 건 아닙니다. 일단 검사 예외를 던질 수 있는 메서드는 호출쪽에서 try/catch 블록을 두어 처리하거나 더 바깥으로 전파를 하는 처리를 해줘야만 하고 특히 자바 8부터 추가된 스트림 안에서는 검사 예외를 던지는 메서드를 사용할 수 없어서 문제가 더 많아졌습니다. 그래서 만약 검사 예외를 최대한 지양해야만 하는 상황이라면 &lt;strong&gt;적절한 결과 타입을 담은 옵셔널을 반환&lt;/strong&gt;하는 것을 고려해봐야 합니다. 대신 이 방법은 예외의 원인에 대한 구체적인 정보를 담을 수 없다는 단점이 있습니다. 또 다른 방법은 &lt;strong&gt;검사 예외를 던지는 메서드를 2개로 쪼개서 비검사 예외로 바꾸는 것&lt;/strong&gt;입니다. 이때 첫번째 메서드는 예외가 던져질지 여부를 boolean 값으로 변환합니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 리팩토링 전&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TheCheckedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 예외 상황에 대처&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 리팩토링 후&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;actionPermitted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 예외 상황에 대처&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 방식을 모든 상황에 적용할 수는 없고 딱히 아름답지도 않지만 스트림에서 사용할 수 있고 try/catch 블록을 사용하지 않아서 더 유연합니다. 하지만 이 방식에서 actionPermitted 메서드와 action 메서드가 결국 상태 검사 메서드, 상태 의존 메서드가 되기 때문에 외부 요인에 의해 상태가 변할 수 있거나 여러 스레드가 동시 접근할 수 있는 상황에서는 사용하면 안 됩니다. 마찬가지로 두 메서드 간의 중복 로직이 존재하면 성능상 손해이니 적용하는 것이 적절하지 않을 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-72-표준-예외를-사용하라&quot;&gt;아이템 72. 표준 예외를 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;자바 라이브러리는 이미 API에서 사용하기 좋은 충분한 수의 표준 예외를 제공합니다. 그러니까 표준 예외를 재사용하는 것이 좋습니다. 표준 예외를 사용한 API는 다른 사람들이 익히고 사용하기 쉽습니다. 그리고 예외 클래스의 수가 적을수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸립니다. 다음은 주로 사용되는 표준 예외들 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;IllegalArgumentException: 메서드 인자로 부적절한 값을 넘길 때 던지는 예외&lt;/li&gt;
  &lt;li&gt;IllegalStateException: 대상 객체의 상태가 호출된 메서드를 수행하기에 적합하지 않을 때 주로 던집니다. 가령 초기화되지 않은 객체를 사용하려 할 때 던질 수 있습니다.&lt;/li&gt;
  &lt;li&gt;NullPointerException: null을 허용하지 않는 메서드에 null을 전달할 때 던지는 예외&lt;/li&gt;
  &lt;li&gt;IndexOutOfBoundsException: 어떤 시퀀스의 허용 범위는 넘는 값을 건낼 때 던지는 예외&lt;/li&gt;
  &lt;li&gt;ConcurrentModificationException: 단일 스레드에서만 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려고 할 때 던지는 예외&lt;/li&gt;
  &lt;li&gt;UnsupportedOperationException: 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때 던집니다. 가장 대표적으로 사용되는 경우가 구현하려는 인터페이스의 메서드 일부를 구현할 수 없을 때입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이때 Exception, RuntimeException, Throwable, Error는 절대 재사용하지 맙시다. 이 클래스들은 그냥 추상 클래스라고 생각하는 게 좋습니다. 왜냐하면 여러 성격의 예외들을 포괄하는 클래스라서 안정적으로 테스트할 수 없습니다.&lt;/p&gt;

&lt;p&gt;그리고 더 많은 정보 제공을 원해서 예외를 확장하고 싶다면 해도 좋지만 예외는 직렬화할 수 있다는 사실을 기억해야 합니다. 직렬화는 부담이 많이 따르기 때문에 예외 확장은 그렇게 바람직하진 않습니다.&lt;/p&gt;

&lt;p&gt;그런데 앞서 살펴본 예외들 중 쓰임이 상호 배타적이지 않아서 예외를 확정하기 어려울 때도 있습니다. 예를 들어 카드 덱을 표현하는 객체가 있고 인수로 건넨 수만큼 카드를 뽑아 나눠주는 메서드를 제공할 때 덱에 남아 있는 카드 수보다 큰 값을 전달받으면 어떤 예외를 던져야 할까요? 관점에 따라 달라집니다. 인수의 값이 너무 크다고 보면 IllegalArgumentException이겠지만, 덱에 남은 카드의 수가 너무 적다고 본다면 IllegalStateException이 될 것입니다. 이럴 때 일반적으로는 &lt;strong&gt;인수 값이 무엇이었든 어차피 실패했을 거라면 IllegalStateException을, 그렇지 않으면 IllegalArgumentException을&lt;/strong&gt; 던집니다. 즉 이 규칙을 따르면 위의 예에서는 IllegalArgumentException을 던져야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-73-추상화-수준에-맞는-예외를-던지라&quot;&gt;아이템 73. 추상화 수준에 맞는 예외를 던지라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;메서드가 저수준 예외를 그냥 바깥으로 전파하면 수행하려는 일과 관련 없는 예외일 가능성이 있습니다. 이는 프로그래머를 당황하게 하는 것을 넘어 내부 구현을 노출해서 상위 레벨 API를 오염시킵니다. 그리고 다음 릴리즈에서 구현 방식을 바꾸면 다른 예외가 튀어나와서 기존 클라이언트 프로그램을 깨지게 할 수도 있습니다. 이런 문제를 피하기 위해서 &lt;strong&gt;상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔서 던져야 합니다.&lt;/strong&gt; 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;예외 번역&lt;/code&gt;이라고 합니다. AbstractSequentialList의 List 인터페이스의 골격 구현을 예로 살펴보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* 이 리스트 안의 지정한 위치즤 원소를 반환한다.
* @throw IndexOutOfBoundsException index가 범위 밖이라면,
* 즉, ({@code index &amp;lt; 0 || index &amp;gt;= size()}) 이면 발생한다.
*/&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;ListIterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listIterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NoSuchElementException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IndexOutOfBoundsException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;인덱스: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;저수준의 NoSuchElementException을 추상화 레벨에 맞게 IndexOutOfBoundsException으로 바꿔서 던지고 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 만약 저수준 예외가 디버깅에 도움이 된다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;예외 연쇄&lt;/code&gt;를 사용하는 게 좋습니다. 예외 연쇄란 문제의 근본 원인(cause)인 저수준 예외를 고수준 예외에 실어 보내는 방식입니다. 그럼 별도의 접근자 메서드를 통해(getCause) 언제든 저수준 예외를 꺼낼 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LowerLevelException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;HigherLevelException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 고수준 예외에 저수준 예외를 전달&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;고수준 예외의 생성자는 예외 연쇄용으로 설계된 상위 클래스의 생성자에 원인을 건네서 최종적으로 Throwable(Throwable) 생성자까지 전달이 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HigherLeverException&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;HigherLeverException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;대부분의 표준 예외는 예외 연쇄용 생성자를 갖추고 있고 그렇지 않더라도 Throwable의 initCause 메서드를 통해 원인을 지정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 예외 번역보다 더 좋은 건 저수준 메서드가 반드시 성공하도록 해서 예외가 바깥으로 전파되지 않도록 하는 것입니다. 물론 메서드로 인자를 전달하기 전에 미리 검사해서 이 목적을 달성할 수도 있습니다. 또 다른 차선책으로는 상위 계층에서 예외를 조용히 처리하여 문제를 API 호출자까지 전파하지 않는 것입니다. 대신 예외가 발생했을 때 java.util.logging과 같은 적절한 로깅을 통해 기록은 해두는 겁니다. 그럼 클라이언트 코드에 문제를 전파하지 않으면서 로그 분석을 통해 사후 조치가 가능해집니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-74-메서드가-던지는-모든-예외를-문서화하라&quot;&gt;아이템 74. 메서드가 던지는 모든 예외를 문서화하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;메서드가 던지는 예외는 그 메서드를 올바로 사용하기 위해 꼭 알아야 하는 중요한 정보입니다. 그래서 이에 대한 문서화를 하는 것이 중요합니다. &lt;strong&gt;검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용해서 문서화합시다.&lt;/strong&gt; 이때 예외 클래스를 공통 상위 클래스로 지정하면 안 됩니다. 메서드 사용자에게 의미있는 정보를 주지 못하고 같은 같은 맥락에서 발생할 여지가 있는 다른 예외까지 삼키게 될 수 있기 때문입니다. 예외적으로 jvm만 호출하는 main메서드에서는 Exception을 던지도록 선언해도 됩니다.&lt;/p&gt;

&lt;p&gt;비검사 예외를 문서화하는 것도 좋습니다. 자신이 일으킬 수 있는 프로그래밍 오류들이 무엇인지 알려주면 프로그래머들은 자연스럽게 해당 오류가 발생하지 않도록 코딩할 것입니다. 특히 비검사 예외의 문서화는 인터페이스 메서드에서 중요합니다. 이 비검사 예외 조건이 인터페이스의 일반 규약에 속하게 되어서 그 인터페이스의 구현체들이 일관되게 동작하도록 해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;검사 예외, 비검사 예외 모두 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 않는 것이 좋습니다.&lt;/strong&gt; 검사냐, 비검사냐에 따라 API 사용자가 해야 할 일이 달라지기 때문에 확실히 구분해주는 것이 좋습니다. 이를 위해 자바독 유틸리티는 메서드 선언의 throws 절에 등장하고 @throws 태그에도 명시한 예외와 @throws 태그에만 명시한 예외를 시각적으로 구분해줍니다.&lt;/p&gt;

&lt;p&gt;만약 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 클래스 설명에 추가해도 됩니다. NullPointerException이 가장 대표적입니다. 이럴 땐 클래스의 문서화 주석에 “이 클래스의 모든 메서드는 인수로 null이 넘어오면 NullPointerException을 던진다”라고 적어도 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-75-예외의-상세-메시지에-실패-관련-정보를-담으라&quot;&gt;아이템 75. 예외의 상세 메시지에 실패 관련 정보를 담으라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;예외로 인해서 프로그램이 실패하면 자바는 그 예외의 스택 추적(stack trace) 정보를 자동으로 출력합니다. 이 스택 추적은 예외 객체의 toString 메서드를 호출해서 얻는 문자열로, 보통 예외의 클래스 이름 뒤에 상세 메시지가 붙는 형태 입니다. 이 toString에서 실패 원인에 관한 정보를 가능한 많이 담아서 반환해줘야 합니다. 사후 분석에서 사용할 수 있는 거의 유일한 정보이기 때문입니다. &lt;strong&gt;실패 순간을 정확히 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메시지에 담아야&lt;/strong&gt; 합니다. 그렇다고 메시지가 장황하면 안 됩니다. 문제를 분석할 때는 결국 소스코드도 함께 살펴볼 것이기 때문에 예외가 발생한 파일 이름과 줄번호, 그리고 스택에서 호출한 다른 메서드들의 파일 이름과 줄번호를 기록하면 됩니다.&lt;/p&gt;

&lt;p&gt;그리고 예외에서 실패와 관련된 정보를 얻을 수 있는 접근자 메서드를 적절하게 제공하는 것이 좋습니다. 특히 검사 예외에서는 포착한 실패 정보를 통해 예외 상황을 복구하는 데 유용하게 사용할 수 있기 때문에 더더욱 필요합니다. 하지만 ‘toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공하자’는 일반 원칙에 비추어 봤을 때 비검사 예외라도 접근자 메서드를 제공하는 것을 권합니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-76-가능한-한-실패-원자적으로-만들라&quot;&gt;아이템 76. 가능한 한 실패 원자적으로 만들라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;실패 원자적이라는 것은 &lt;strong&gt;호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지&lt;/strong&gt;하는 것을 의미합니다. 메서드를 실패 원자적으로 만드는 가장 간단한 방법은 불변 객체로 만드는 것입니다. 불변 객체는 태생적으로 속성이 변할 수 없기 때문입니다. 하지만 가변 객체의 메서드를 실패 원자적으로 만들어야 할 때도 있습니다. 이때는 작업 수행에 앞서 매개변수의 유효성을 검사하는 것입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;EmptyStackException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 다 쓴 객체 참조 해제&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스택의 pop 메서드 입니다. 작업 수행 전에 size의 유효성을 체크하여 적절하지 않으면 내부 상태를 바꾸지 못하게 막았습니다. 사실 이런 유효성 검사를 하지 않더라도 size가 0이라면 예외를 던지지만 ArrayIndexOutOfBounds 예외가 던져질 것이고 이는 스택의 추상화 수준에 어울리지 않는 저수준 예외가 되기 때문에 어울리지 않습니다.&lt;/p&gt;

&lt;p&gt;비슷한 방법으로 실패할 가능성이 있는 모든 코드를, 객체의 상태를 바꾸는 코드보다 앞에 배치할 수도 있습니다. 이는 계산을 수행해보기 전에는 인수의 유효성 검사가 어려울 때 앞의 방식과 더해서 쓸 수 있는 방법입니다.&lt;/p&gt;

&lt;p&gt;또 다른 방법도 있습니다. 작업 도중에 발생하는 실패를 가로채서 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법입니다. 주로 디스크 기반의 내구성을 보장해야 하는 자료구조에 쓰이는데 자주 사용되는 방법은 아닙니다.&lt;/p&gt;

&lt;p&gt;하지만 실패 원자성을 항상 보장할 수는 없습니다. 대표적으로 다음의 경우가 그렇습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;두 스레드가 동기화 없이 같은 객체를 동시에 수정하는 경우: 이 경우에는 ConcurrentModificationException을 잡아낸다고 해도 객체의 일관성이 깨졌을 수 있어서 여전히 쓸 수 있는 상태라고 가정할 수 없습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Error가 발생했을 경우: Error는 프로그래밍 레벨에서는 복구할 수 없기 때문에 AssertionError에 대해서는 실패 원자적으로 만들려는 시도조차 필요 없습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만약 메서드 명세에 기술한 예외라면 예외가 발생하더라도 객체의 상태는 메서드 호출 전과 똑같이 유지되어야 한다는 것이 기본 규칙입니다. 이 규칙을 지키지 않는다면 그 사실도 api 설명에 명시해야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-77-예외를-무시하지-말라&quot;&gt;아이템 77. 예외를 무시하지 말라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;api 설계자들이 메서드 선언에 예외를 명시하는 이유는 그 메서드를 사용할 때 적절한 조치를 취하라고 신호를 보내는 것입니다. 그럼에도 불구하고 예외를 무시하는 경우가 아주 많습니다. catch 블록을 그냥 비워버려서 무시하기 아주 좋기 때문입니다. &lt;strong&gt;catch 블록을 비워버리면 예외가 존재할 이유가 사라지게 됩니다.&lt;/strong&gt; 물론 예외를 무시해야 하는 케이스도 있습니다. FileInputStream을 닫을 때가 대표적입니다. FileInputStream은 파일을 읽어들일 뿐, 파일의 상태를 변경하지 않으니 예외가 발생해도 복구할 것이 없으며, 스트림을 닫는다는 건 필요한 정보는 다 읽었다는 뜻이니 남은 작업을 중단할 이유도 없습니다. 그래도 같은 예외가 자주 발생하면 조사 차원에서 파일을 닫지 못했다는 사실을 로그로 남기는 것 정도는 좋은 생각입니다. 어찌 되었든 예외를 무시해야만 한다면 catch 블록 안에 그렇게 결정을 한 이유를 남겨야 하고, 예외 변수의 이름도 ignored로 바꾸도록 합시다.&lt;/p&gt;

&lt;p&gt;이 내용은 검사, 비검사 예외 모두에 적용됩니다. 검사 예외라면 catch 블록에서 문제의 원인을 적절히 해결하고 비검사 예외라도 그걸 잡아서 빈 catch 블록으로 무시해선 안 됩니다. 차라리 바깥으로 전파되게만 놔두더라도 최소한 디버깅 정보를 남기면서 프로그램이 중단되게 할 수 있습니다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><category term="자바" /><summary type="html">조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.</summary></entry><entry><title type="html">이펙티브자바 - 9장. 일반적인 프로그래밍 원칙</title><link href="https://anstn1993.github.io/2021/07/28/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-9%EC%9E%A5.html" rel="alternate" type="text/html" title="이펙티브자바 - 9장. 일반적인 프로그래밍 원칙" /><published>2021-07-28T00:00:00+09:00</published><updated>2021-07-28T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/07/28/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-9%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/07/28/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-9%EC%9E%A5.html">&lt;p&gt;조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.&lt;/p&gt;

&lt;h1 id=&quot;9장-일반적인-프로그래밍-원칙&quot;&gt;9장. 일반적인 프로그래밍 원칙&lt;/h1&gt;

&lt;p&gt;이 장에서는 자바로 개발할 때 지켜야 하는 여러 원칙들에 대해서 살펴보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-57-지역변수의-범위를-최소화하라&quot;&gt;아이템 57. 지역변수의 범위를 최소화하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;지역변수의 유효 범위를 최소한으로 줄이는 것은 가독성, 유지보수성, 오류 방지 측면에서 중요합니다. 지역변수의 범위를 줄이기 위한 기법들을 살펴보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;가장 처음 쓰일 때 선언하라.
C언어처럼 전방전언을 하게 되면 실제 그 변수가 사용되는 블록이 끝나도 살아있게 되기 때문에 의도한 범위 앞, 뒤에서 그 변수를 사용해서 원치 않는 결과를 초래할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;거의 모든 지역변수는 선언과 동시에 초기화해야 한다.
try-catch문과 같이 try문 바깥에서 변수를 참조해야 하는 경우를 제외하고는 거의 모든 경우에 선언과 초기화를 함께 해주는 것이 좋습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;반복 변수 값을 반복문이 종료된 뒤에도 써야 하는 상황이 아니면 while문보다는 for문을 사용하라.
for, for-each 모두 반복 변수의 범위가 반복문의 몸체와 반복문 블록 안으로 제한되기 때문에 범위를 제한하기에 좋습니다. 특히 프로그램의 오류를 컴파일 타임에 잡아내기에도 훨씬 좋습니다.&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 앞에서 사용한 i를 다시 사용! 하지만 컴파일은 잘 됨&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;두번째 while문에서는 i2 반복자를 사용해야 했지만 i를 사용했습니다. 이런 실수를 for문에서는 컴파일 타임에 잡아내게 됩니다.&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// i를 찾을 수 없나는 컴파일 오류 발생&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;심지어 for문을 사용하면 for문을 사용할 때마다 반복 변수의 이름을 똑같이 사용할 수 있다는 장점도 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메서드를 작게 유지하고 한 가지 기능에 집중하라.
한 메서드에 여러 기능이 들어오면 한 기능과 관련된 지역변수에 다른 기능을 수행하는 쪽에서 접근할 수 있게 되기 때문에 메서드를 기능별로 쪼개야 합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;아이템-58-전통적인-for-문보다는-for-each-문을-사용하라&quot;&gt;아이템 58. 전통적인 for 문보다는 for-each 문을 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;for와 for-each(향상된 반복문) 중에서는 for-each를 사용하는 것이 for를 사용해야만 하는 경우를 제외하고는 더 좋습니다. 반복문에서 원소를 담고 있는 컬렉션이나 배열을 순회할 때 대부분 우리의 관심사는 원소이지 인덱스가 아닙니다. 그런데 for를 사용하면 원소 참조를 위해 반복 변수를 어쩔 수 없이 사용해야 하는 경우가 생기고 이는 잘못된 변수를 사용할 가능성이 높아짐을 의미합니다. 그리고 for-each를 사용했을 때 더 큰 장점은 배열이든 컬렉션이든 원소를 참조하는 방법이 동일하다는 점입니다. 즉 어떤 컨테이너를 다루는지 신경쓸 필요가 없습니다. 반면 for의 경우 배열과 컬렉션의 참조 방법이 달라지게 됩니다. for-each문은 컬렉션, 배열과 더불어 Iterable 인터페이스를 구현한 객체라면 모두 순회가 가능합니다.&lt;/p&gt;

&lt;p&gt;하지만 for문을 사용할 수 밖에 없는 경우 3가지가 있습니다. 아래의 3가지 경우를 제외하고는 for-each를 사용하도록 합시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;파괴적인 필터링
컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove 메서드를 사용해야 합니다. 그런데 자바 8부터는 Collection의 removeIf 메서드를 사용해서 인자로 전달된 Predicate 함수 객체의 조건에 부합하는 원소는 모두 제거해주기 때문에 굳이 순회하면서 제거하지 않아도 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;변형
배열, 리스트 등을 순회하면서 원소의 값 일부나 전체를 수정해야 하면 반복자나 인덱스를 사용해야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;병렬 반복
여러 컬렉션을 병렬로 순회해야 하면 각각의 반복자, 인덱스 변수를 사용해서 제어할 수밖에 없습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;아이템-59-라이브러리를-익히고-사용하라&quot;&gt;아이템 59. 라이브러리를 익히고 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;라이브러리를 적극적으로 활용하면 그 코드를 작성한 전문가의 지식과 이를 앞서 사용한 다른 프로그래머들의 경험을 활용하여 개발 시간과 시행착오를 줄일 수 있습니다. 대부분의 프로그래머들은 애플리케이션 기능 개발에 집중하고 싶어하지, 하부 공사에 시간을 많이 쓰고 싶어하지 않습니다. 그리고 라이브러리를 사용하면 자신이 따로 유지보수를 하지 않아도 성능이 지속적으로 개선된다는 점입니다. 특히 사용자가 많을수록 라이브러리 제작자들이 더 나은 방법을 꾸준히 모색할 것입니다. 또 다른 이점으로는 시간이 지날수록 기능이 점점 많아진다는 점입니다. 마지막으로 라이브러리를 쓰면 해당 코드는 많은 사람들에게 익숙한 코드가 되어 다른 개발자들이 읽기 좋고, 유지보수하기 좋고, 재활용하기 쉬운 코드가 됩니다.&lt;/p&gt;

&lt;p&gt;이런 장점들에도 불구하고 많은 프로그래머들은 이미 라이브러리로 있는 기능을 직접 구현해서 씁니다. 해당 라이브러리의 존재를 모르기 때문인 경우가 대부분일 것입니다. 자바는 메이저 릴리스마다 수많은 라이브러리들이 추가되고 웹 페이지에 그 내용을 공시합니다. 새로운 메이저 버전이 나오면 읽어보는 것이 좋습니다.(ex. java8-feat, java9-feat)&lt;/p&gt;

&lt;p&gt;대표적으로 자바 9에서 InputStream에 추가된 transferTo 메서드를 살펴보겠습니다. 이 메서드는 지정한 URL로 요청을 보내 응답 본문을 쉽게 가져올 수 있는 메서드 입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InputStream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;openStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;transferTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자바 9 이전에는 위와 동일한 역할을 하는 코드를 작성하기가 까다롭고 길었지만 자바 9에서는 단 한줄이면 해결됩니다. 이처럼 라이브러리가 가져다주는 이점이 크기 때문에 자바 프로그래머라면 다음의 라이브러리들에 익숙해져야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java.lang, java.util, java.io와 그 하위 패키지들&lt;/li&gt;
  &lt;li&gt;자바 7부터는 Random보단 ThreadLocalRandom(포크-조인 풀이나 병렬 스트림에서는 SplittableRandom)&lt;/li&gt;
  &lt;li&gt;컬렉션 프레임워크와 스트림 라이브러리&lt;/li&gt;
  &lt;li&gt;java.util.concurrent의 동시성 기능&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;아이템-60-정확한-답이-필요하다면-float과-double은-피하라&quot;&gt;아이템 60. 정확한 답이 필요하다면 float과 double은 피하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;float과 double 타입은 이진 부동 소수점 연산에 쓰이고, 넓은 범위의 수를 정밀한 ‘근사치’로 계산하게 설계되었기 때문에 &lt;strong&gt;정확한 계산 결과가 필요할 때는 쓰면 안 됩니다.&lt;/strong&gt; 1.03달러 중에 42센트를 썼을 때 남는 돈을 구하는 어설픈 코드를 작성해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.03&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.42&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 정확한 값인 0.61을 출력하지 않고 0.6100000000000001을 출력합니다. &lt;strong&gt;정확한 값을 구해야 하는, 특히 금융 계산에서는 BigDecimal, int, long을 사용&lt;/strong&gt;해야 합니다. 이때 BigDecimal은 두 가지 단점이 있습니다. 기본 타입보다 쓰기 불편하고, 훨씬 느립니다. 대신 반올림을 수행해야 하는 계산에서는 BigDecimal이 여덟 가지 반올림 모드를 제공하기 때문에 완벽히 제어가 가능하다는 장점도 있습니다. int, long의 경우 훨씬 빠르지만 값의 크기가 제한되고 소수점을 직접 관리해야 하기 때문에 계산의 요구사항에 따라 적절한 타입을 선택하면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-61-박싱된-기본-타입보다는-기본-타입을-사용하라&quot;&gt;아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;기본 타입과 그에 대응되는 박싱 타입은 오토 박싱과 오토 언박싱 덕분에 크게 구분하지 않고 사용하는 경우가 많은데 이 둘의 차이는 잘 알고 사용해야 합니다. 둘의 차이는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;박싱된 기본 타입은 식별성이라는 속성을 가지기 때문에 두 인스턴스가 감싸고 있는 값이 같아도 다르다고 식별될 수 있다.
이와 관련된 문제를 살펴보겠습니다. Integer 값을 오름차순으로 정렬하는 비교자를 만들어보겠습니다.
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Comparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;naturalOrder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;Integer 자체가 순서를 가지기 때문에 비교자를 만들 필요는 없지만 결함을 보여주기 위해 작성되었습니다. 얼핏 봤을 때는 문제가 없어보입니다. 하지만 naturalOrder.compare(new Integer(42), new Integer(42))를 호출하면 값이 42라서 0을 출력할 것 같지만 1을 출력합니다. 왜냐하면 부등호 연산에서는 오토 언박싱을 통해 값을 비교하지만 &lt;strong&gt;== 연산에서는 인스턴스 비교&lt;/strong&gt;가 이루어지기 때문입니다. 즉 두 인스턴스의 비교 결과 false가 되어 1이 반환되는 것입니다. 문제를 해결하려면 기본타입 변수를 생성해서 그 변수로 비교를 하면 됩니다.&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Comparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;naturalOrder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iBoxed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jBoxed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iBoxed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jBoxed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기본 타입의 값은 언제나 유효하지만 박싱된 기본 타입은 null을 가질 수 있다.
다음의 간단한 프로그램을 보겠습니다.&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Unbelievable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;믿을 수 없군!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;이 프로그램은 잘 모르고 보면 ‘믿을 수 없군!’이 출력될 것 같지만 NullPointerException을 던지게 됩니다. 기본 타입은 값을 정의하지 않더라도 기본 값으로 0이 들어가지만 참조 타입의 기본 값은 null이기 때문입니다. 해법은 간단하게 Integer 대신 int를 사용하는 것입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 타입이 시간과 메모리 사용면에서 더 효율적이다.
다음의 간단한 프로그램을 보겠습니다.
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MAX_VALUE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;이 프로그램은 sum을 박싱 타입으로 선언해서 느려졌습니다. 이때 i를 sum에 더하는 연산에서 언박싱과 박싱이 반복해서 일어나기 때문에 성능이 체감될 정도로 느려집니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;박싱된 타입을 써야 하는 경우도 분명히 존재합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;컬렉션의 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로 박싱된 타입을 쓴다. 가령, 컬렉션의 원소, 키, 값으로 쓴다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리플렉션을 통해 메서드를 호출할 때 박싱된 타입을 쓴다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;아이템-62-다른-타입이-적절하다면-문자열-사용을-피하라&quot;&gt;아이템 62. 다른 타입이 적절하다면 문자열 사용을 피하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;자바는 문자열을 잘 지원해주는 언어 중 하나인데 이런 이유 때문에 원래 의도에서 벗어난 용도로 사용되는 경우가 많습니다. 문자열을 쓰지 않아야 하는 사례들을 살펴보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;문자열은 다른 값 타입을 대신하기에 적합하지 않다.
입력받을 데이터가 문자열이 아니라면 그 데이터의 실제 타입을 사용하는 게 좋습니다. 데이터가 숫자라면 int, float, BigInteger 등 적당한 수치 타입으로 변환해야 합니다. 또는 ‘예/아니오’ 질문의 답이라면 적절한 열거 타입이나 boolean을 써야 합니다. 그리고 그 어떠한 타입으로도 표현하기 힘들다면 새로 클래스를 하나 작성해야 합니다.&lt;/li&gt;
  &lt;li&gt;문자열은 열거 타입을 대신하기에 적합하지 않다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;문자열은 혼합 타입을 대신하기에 적합하지 않다.
여러 요소가 혼합된 데이터를 특정 문자를 구분자로 삼아서 하나의 문자열로 표현하는 경우가 있습니다. 이 방식은 문제가 많습니다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;구분자가 요소에 문자로 포함되어있기라도 하면 그 문자도 의도치 않게 구분자 역할을 하면서 데이터가 깨진다.&lt;/li&gt;
      &lt;li&gt;개별 요소에 접근하기 위해서는 문자열을 파싱해야 한다. 이는 느리고, 귀찮고, 오류 가능성도 큰 방식이다.&lt;/li&gt;
      &lt;li&gt;equals, toString, compareTo 메서드를 제공할 수 없고, String의 메서드에만 의존할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;이런 문제를 겪지 않기 위해 차라리 전용 클래스를 만드는 게 낫습니다. 이런 클래스는 보통 private 정적 멤버 클래스로 선언합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;문자열을 권한을 표현하기에 적합하지 않다.
자바 2 전에는 스레드 지역변수 기능을 프로그래머가 직접 설계해야 했는데 여러 방법을 모색하다가 다다른 하나의 설계가 클라이언트가 제공한 문자열 키로 스레드별 지역변수를 식별하는 것이었습니다.&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadLocal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ThreadLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 객체 생성 불가&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 현 스레드의 값을 키로 구분해서 저장&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// (키가 가리키는) 현 스레드의 값을 반환&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;우선 이 방식의 문제는 문자열 키가 전역 이름공간에서 공유된다는 것입니다. 즉, 클라이언트가 제공하는 키의 충돌이 발생할 여지가 있다는 것입니다. 그럼 두 클라이언트 모두 제대로 기능하지 못할 것입니다. 이는 보안도 취약함을 의미합니다. 악의적인 클라이언트가 의도적으로 같은 키를 이용해서 다른 클라이언트의 값을 가져올 수도 있습니다.&lt;/p&gt;

    &lt;p&gt;해결책은 문자열 대신 위조할 수 없는 키를 사용하면 됩니다. 이 키를 권한(capacity)라고 합니다.&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadLocal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ThreadLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 객체 생성 불가&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (권한)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;//위조 불가능한 고유 키를 생성한다.ㅣ&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 현 스레드의 값을 키로 구분해서 저장&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// (키가 가리키는) 현 스레드의 값을 반환&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Key&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;이제 key는 더 이상 스레드 지역변수를 구분하기 위한 키가 아니라 그 자체가 스레드 지역분수가 되고 set, get은 정적 메서드일 이유가 없습니다. 그럼 사실 톱레벨 클래스인 ThreadLocal은 딱히 하는 일이 없어지기 때문에 중첩 클래스인 Key를 ThreadLocal로 바꾸면 됩니다. 그리고 덧붙여 매개변수화 타입을 적용해서 get을 할 때 형변환을 하지 않게 만듭니다.&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ThreadLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ThreadLocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;아이템-63-문자열-연결은-느리니-주의하라&quot;&gt;아이템 63. 문자열 연결은 느리니 주의하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;문자열은 불변이기 때문에 문자열들을 연결하면 새로운 공간에 초기화를 하게 되기 때문에 성능 저하가 발생합니다. 자바 6 이후에는 문자열 연결 성능을 많이 개선했지만 그럼에도 불구하고 StringBuffer, StringBuilder가 훨씬 빠릅니다. 한 가지 더 기억할 점은 StringBuffer, StringBuilder를 초기화할 때 다중정의된 생성자를 통해 결과 문자열을 담기에 충분한 길이로 초기화하면 더 빠르다는 점입니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-64-객체는-인터페이스를-사용해-참조하라&quot;&gt;아이템 64. 객체는 인터페이스를 사용해 참조하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;어떤 타입이든 적합한 인터페이스만 있다면 매개변수뿐만 아니라 반환값, 변수, 필드를 전부 인터페이스로 선언하는 것이 좋습니다. 객체를 구상 클래스로 선언하는 상황은 ‘생성자’로 객체를 생성할 때뿐입니다. &lt;strong&gt;인터페이스를 타입으로 사용하면 프로그램이 훨씬 유연해집니다.&lt;/strong&gt; 구상 클래스 교체를 해야 하더라도 그냥 하면 됩니다. 그리고 다른 코드는 전혀 손댈 필요가 없습니다. 다른 코드는 인터페이스 타입만 알지 기존 구상 클래스 타입이 무엇인지는 모르기 때문입니다.&lt;/p&gt;

&lt;p&gt;주의할 점이 하나 있습니다. 기존 클래스가 인터페이스의 일반 규약 외에 특별한 기능을 제공하며, 주변 코드가 이 기능에 의존해서 동작하면 새롭게 교체될 클래스도 반드시 같은 기능을 제공해야 합니다. LinkedHashSet이 따르는 순서 정책을 가정하고 동작하는 코드가 있는데 이때 HashSet으로 바꿔버리면 반복자의 순회 순서 보장이 안 되기 때문에 문제가 생길 수 있습니다.&lt;/p&gt;

&lt;p&gt;만약 적합한 인터페이스가 없으면 당연히 구상 클래스로 선언을 해야 합니다. String, BigInteger 같은 값 클래스가 대표적입니다. 이런 값 클래스를 여러 가지로 구현할 수 있다고 생각하고 설계하는 경우는 거의 없기에 final 클래스인 경우가 많고 상응하는 인터페이스가 존재하는 경우가 거의 없습니다. 또한 클래스 기반으로 작성된 프레임워크가 제공하는 객체들을 사용해야 하는 경우에도 적합한 인터페이스가 없을 것이기 때문에 구상 클래스를 사용해야 합니다. 하지만 이런 경우라고 해도 특정 구현 클래스를 사용하는 것보단 가장 상위(기반) 클래스(보통은 추상 클래스)를 사용해서 참조해야 합니다. 마지막으로 인터페이스에는 없는 메서드를 제공하는 클래스의 메서드를 사용해야 한다면 어쩔 수 없이 그 클래스로 참조를 해야 합니다. 예를 들어 PriorityQueue 클래스는 Queue 인터페이스에는 없는 comparator 메서드를 제공하는데 이 기능을 이용하려면 PriorityQueue로 참조할 수밖에 없습니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-65-리플렉션보다는-인터페이스를-사용하라&quot;&gt;아이템 65. 리플렉션보다는 인터페이스를 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;리플렉션 기능을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있습니다. Class 객체를 통해서 생성자, 메서드, 필드에 해당하는 Constructor, Method, Field 인스턴스를 가져올 수 있고, 그 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 등을 가져올 수 있습니다. 뿐만 아니라 Constructor, Method, Field를 이용해서 각각에 연결된 실제 생성자, 메서드, 필드를 조작할 수도 있습니다. 예를 들면 Method.invoke는 어떤 클래스의 어떤 객체가 가진 어떤 메서드라도 호출할 수 있습니다. 이런 &lt;strong&gt;리플렉션을 이용하면 컴파일 당시에 존재하지 않았던 클래스도 이용할 수 있습니다.&lt;/strong&gt; 하지만 단점이 많습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;컴파일타임의 타입 검사가 주는 이점을 하나도 누릴 수 없다.
앞서 컴파일 당시에 없던 클래스도 사용할 수 있다고 했지만 이는 역으로 말하면 잘못해서 존재하지 않거나 접근할 수 없는 메서드를 호출하려고 시도하면 런타임 오류가 발생할 수 있음을 의미합니다.&lt;/li&gt;
  &lt;li&gt;리플렉션을 이용하면 코드가 지저분하고 장황해진다.&lt;/li&gt;
  &lt;li&gt;성능이 떨어진다.
리플렉션을 통한 메서드 호출은 일반 메서드 호출보다 훨씬 느립니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이처럼 리플렉션은 단점이 명확해서 아주 제한된 형태로만 사용해야 단점은 피하고 이점만 취할 수 있습니다. 컴파일타임에 이용할 수 없는 클래스를 사용해야만 하는 프로그램은 비록 컴파일타임이라도 적절한 인터페이스나 상위 클래스를 이용할 수는 있을 것입니다. 이런 경우라면 &lt;strong&gt;리플렉션은 인스턴스 생성에만 쓰고 이 인스턴스는 인터페이스나 상위 클래스로 참조해서 사용&lt;/strong&gt;합니다.&lt;/p&gt;

&lt;p&gt;리플렉션을 이용한 프로그램 하나를 작성해보겠습니다. 이 프로그램은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&amp;lt;String&amp;gt;&lt;/code&gt; 인터페이스의 인스턴스를 생성하는데 구체 타입은 명령줄의 첫 번째 인수로 지정됩니다. 그리고 생성된 집합에 두 번째 이후의 인수들을 추가해서 화면에 출력합니다. 첫 번째 인수로 입력한 구체 타입이 무엇이냐에 따라 원소들의 출력 순서가 달라질 것입니다. 가령 java.util.HashSet이면 무작위, java.util.TreeSet을 지정하면 알파벳 순서로 출력될 것입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 클래스 이름을 Class 객체로 변환&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;)&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 비검사 형변환&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;클래스를 찾을 수 없습니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 생성자를 얻는다.&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Constructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getDeclaredConstructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NoSuchMethodException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;매개변수 없는 생성자를 찾을 수 없습니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 집합의 인스턴스를 만든다.&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cons&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;IllegalAccessException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;생성자에 접근할 수 없습니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InstantiationException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;클래스를 인스턴스화할 수 없습니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InvocationTargetException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;생성자가 예외를 던졌습니다: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ClassCastException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Set을 구현하지 않은 클래스입니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 생성한 집합을 사용한다.&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;subList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fatalError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;단점을 언급하기에 앞서 이 프로그램에 대해 평하자면, 이 프로그램은 간단하지만 강력합니다. 손쉽게 제네릭 집합 구현에 대한 테스터로 사용할 수 있습니다. Set 구현체를 공격적으로 조작해가며 Set 규약을 잘 지키는지 검사해볼 수 있습니다. 혹은 제네릭 집합 성능 분석 도구로 활용할 수도 있습니다. 대부분의 경우 리플렉션 기능은 이 정도면 충분합니다.&lt;/p&gt;

&lt;p&gt;하지만 단점 두 가지가 나타납니다. 하나는 런타임에 여섯 가지나 되는 예외를 던질 수 있다는 점입니다. 이 모든 예외들은 리플렉션 없이 인스턴스를 생성했다면 컴파일타임에 모두 잡아낼 수 있는 예외들입니다. 다른 하나는 클래스 이름만으로 인스턴스 단 하나를 생성하기 위한 코드가 25줄이나 된다는 점입니다. 즉 너무 장황합니다.(참고로 자바 7부터는 리플렉션 예외를 각각 잡는 대신 모든 리플렉션 예외의 상위 클래스인 ReflectiveOperationException을 제공해줘서 코드 길이를 줄일 수 있긴 합니다.) 우선 객체가 만들어지면 그 후의 코드는 일반적인 코드와 똑같습니다.&lt;/p&gt;

&lt;p&gt;정리하자면 리플렉션은 런타임에 존재하지 않을 수도 있는 다른 클래스, 메서드, 필드와의 의존성 관리가 필요할 때 적합할 것입니다. 하지만 그런 경우가 아니라면 사용하지 않는 것이 좋습니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-66-네이티브-메서드는-신중히-사용하라&quot;&gt;아이템 66. 네이티브 메서드는 신중히 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;자바 네이티브 인터페이스(Java Native Interface, JNI)는 자바 프로그램에서 네이티브 메서드를 호출하는 기술입니다. C, C++ 같은 네이티브 프로그래밍 언어로 작성한 메서드를 네이티브 메서드라고 합니다. 이 메서드는 주요 쓰임은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;레지스트리 같은 플랫폼 특화 기능을 사용하는 경우&lt;/li&gt;
  &lt;li&gt;네이티브 코드로 작성된 라이브러리를 사용하는 경우&lt;/li&gt;
  &lt;li&gt;성능 개선을 목적으로 성능에 결정적 영향을 주는 영역만 따로 네이티브 언어로 작성하는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;플랫폼 특화 기능을 이용하려면 네이티브 메서드를 사용해야 하지만 시간이 지나면서 자바가 os 같은 하부 플랫폼의 기능들을 점점 흡수하고 있어서 네이티브 메서드의 필요성이 점점 줄어들고 있습니다. 대표적인 예가 자바 9에서 추가된 process api 입니다. 해당 api로 os 프로세스에 접근할 수 있게 되었습니다. 그러니까 &lt;strong&gt;적절한 자바 라이브러리가 없는 경우에만 네이티브 메서드를 사용하면 됩니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;성능 개선을 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않습니다.&lt;/strong&gt; JVM은 시간이 지날수록 엄청난 발전을 이룩해서 대부분의 작업에서 다른 플랫폼에 견줄만한 성능을 보입니다.&lt;/p&gt;

&lt;p&gt;네이티브 메서드 사용을 권장하지 않는 이유는 심각한 단점 때문입니다. 네이티브 메서드를 사용하게 되면 해당 애플리케이션의 메모리 훼손 오류가 발생할 수 있습니다. 또한 자바와 달리 네이티브 언어는 플랫폼에 의존적이기 때문에 이식성이 낮습니다. 디버깅도 어렵고 가비지 컬렉터가 네이티브 메모리는 자동 회수하지 못하며 추적조차 할 수 없습니다. 그리고 자바 코드와 네이티브 코드의 경계를 넘나들 때마다 비용도 추가되고 둘을 이어주는 접착 코드까지 필요한데 귀찮고 가독성도 떨어집니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-67-최적화는-신중히-하라&quot;&gt;아이템 67. 최적화는 신중히 하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;최적화는 보통 좋은 결과보다는 해로운 결과로 이어지기 쉽고, 빠르지도 않고 제대로 동작하지도 않으면서 수정하기 어려운 소프트웨어를 탄생시킬 가능성이 높기 때문에 정말로 명백하고 확실한 해법을 찾지 않는 이상 하지 않는 것이 좋습니다. 그러니 빠른 프로그램을 작성하려고 안달하지 않아도 됩니다. 성능을 개선하겠다는 핑계로 견고한 구조를 파괴하면 안 됩니다. 최적화와 관련하여 지켜야 할 것들을 살펴보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;빠른 프로그램보단 좋은 프로그램을 작성하는 것이 더 중요하다.&lt;/strong&gt;
좋은 프로그램이라면 아키텍처가 훌륭할 것이고 그 자체로 최적화하기 좋은 구조가 될 것입니다. 캡슐화가 잘 지켜져서 개별 구성요소들을 독립적으로 개선할 수 있기 때문입니다. &lt;strong&gt;구현상의 문제는 나중에 최적화로 해결할 수 있지만 구조의 결함이 성능을 제한하는 상황에서는 시스템 전체를 다시 작성해야만 한다&lt;/strong&gt;는 것을 명심해야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;성능을 제한하는 설계를 피하라.&lt;/strong&gt;
애플리케이션이 완성된 후 가장 변경하기 어려운 요소가 컴포넌트끼리, 혹은 외부 시스템과의 소통 방식입니다. 이런 설계 요소들은 완성 후에는 변경하기 어렵거나 불가능할 수 있으니 신중해야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;API를 설계할 때 성능에 주는 영향을 고려하라.&lt;/strong&gt;
public 타입을 가변으로 만들어서 불필요한 방어적 복사를 유발하는 것은 바람직하지 않으니 가능하다면 불변으로 만드는 것이 좋습니다. 그리고 컴포지션으로 해결할 수 있는 문제를 상속 방식으로 설계하는 public 클래스는 영원히 상위 클래스에 종속되고 성능의 제약까지도 물려받게 됩니다. 또한 인터페이스가 있는데 굳이 구상 클래스 타입을 사용하는 것 역시 좋지 않습니다. 나중에 더 빠른 구현체가 나오더라도 이용하지 못하게 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;최적화 시도 전후로 성능을 측정하라.&lt;/strong&gt;
대부분 최적화를 한 후 성능 비교를 해보면 눈에 띄게 좋아지지 않았거나, 더 나빠지는 경우가 많을 것입니다. 주요 원인은 작성된 코드의 어떤 구간에서 시간이 많이 소요되는지 추측하기 어려운 것에 있습니다. 일반적으로 90%의 시간을 단 10%의 코드에서 사용합니다.
프로파일링 도구를 사용하면 개별 메서드의 소비 시간과 호출 횟수 같은 런타임 정보를 제공해서 어디에 집중해야 할지 알려주기 때문에 유용하게 사용할 수 있습니다. jmh라는 것도 있습니다. 이는 프로파일러는 아니지만 자바 코드의 상세한 성능을 알기 쉽게 보여주는 마이크로 벤치마킹 프레임워크 입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;아이템-68-일반적으로-통용되는-명명-규칙을-따르라&quot;&gt;아이템 68. 일반적으로 통용되는 명명 규칙을 따르라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;자바의 명명 규칙은 크게 철자와 문법, 두 범주로 나뉩니다. 이 규칙을 지키지 않은 api는 사용하기 어렵고 유지보수하기 어렵습니다. 또한 다른 프로그래머들이 읽기 어렵고 다른 뜻으로 오해할 수 있어서 오류까지 발생할 수 있으니 꼭 지킵시다.&lt;/p&gt;

&lt;h3 id=&quot;철자-규칙&quot;&gt;철자 규칙&lt;/h3&gt;

&lt;h4 id=&quot;패키지&quot;&gt;패키지&lt;/h4&gt;

&lt;p&gt;패지지, 모듈의 이름은 각 요소를 점으로 구분해서 계층적으로 짓습니다. 각 요소의 이름은 소문자 알파벳이나 드물게 숫자로 이루어집니다. 만약 외부로 나가야 될 패키지라면 개발한 조직의 인터넷 도메인 이름을 역순으로 사용하면 됩니다.(ex. com.google…) 예외적으로 자바 표준 라이브러리와 선택적 패키지들은 각각 java와 javax로 시작합니다. 그 뒤에 붙는 나머지 이름은 해당 패키지를 설명하는 하나 이상의 요소로 이루어집니다. 각 요소는 일반적으로 8자 이하의 짧은 단어가 좋습니다. 보통 약어나 한 단어로 이루어집니다. 혹은 각 단어의 첫 글자만 따서 써도 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;클래스열거-타입-포함와-인터페이스애너테이션-포함&quot;&gt;클래스(열거 타입 포함)와 인터페이스(애너테이션 포함)&lt;/h4&gt;

&lt;p&gt;클래스와 인터페이스의 이름은 하나 이상의 단어로 이루어지며 각 단어는 대문자로 시작합니다. 이때 단어들의 첫 글자만 딴 약자나 max, min 처럼 아주 널리 통용되는 줄임말을 제외하고는 단어를 줄여쓰지 않아야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;메서드와-필드&quot;&gt;메서드와 필드&lt;/h4&gt;

&lt;p&gt;첫 글자를 소문자로 쓴다는 점만 빼면 클래스 명명 규칙과 같습니다. 이때 첫 단어가 약자라면 단어 전체가 소문자여야 합니다. 단 ‘상수 필드’는 구성 단어 모두 대문자로 쓰며 단어 사이는 밑줄로 구분합니다. 이름에 밑줄을 사용하는 건 상수 필드가 유일합니다.&lt;/p&gt;

&lt;p&gt;지역 변수도 비슷한 규칙이 적용되는데 차이는 약어를 써도 된다는 점입니다. 지역변수는 약어를 써도 그 변수가 사용되는 문맥에서 의미를 쉽게 유추할 수 있기 때문입니다. 입력 매개변수도 지역변수의 하나이지만 메서드 설명 문서에까지 등장하는 만큼 일반 지역변수보다는 신경써야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;타입변수&quot;&gt;타입변수&lt;/h4&gt;

&lt;p&gt;타입 매개변수 이름은 보통 한 문자로 표현합니다. 대부분 다음의 다섯 가지 중 하나입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;T: 타입&lt;/li&gt;
  &lt;li&gt;E: 컬렉션 원소의 타입&lt;/li&gt;
  &lt;li&gt;K, V: 맴의 키와 값의 타입&lt;/li&gt;
  &lt;li&gt;X: 예외 타입&lt;/li&gt;
  &lt;li&gt;R: 메서드의 반환 타입&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 외의 임의 타입의 시퀀스는 T, U, V 혹은 T1, T2, T3를 사용합니다.&lt;/p&gt;

&lt;h3 id=&quot;문법-규칙&quot;&gt;문법 규칙&lt;/h3&gt;

&lt;h4 id=&quot;클래스&quot;&gt;클래스&lt;/h4&gt;

&lt;p&gt;객체를 생성할 수 있는 객체의 이름은 보통 단수 명사나 명사구를 사용합니다. 객체를 생성할 수 없는 클래스의 이름은 보통 복수형 명사로 짓습니다.(Collectors, Collections 등)&lt;/p&gt;

&lt;h4 id=&quot;인터페이스&quot;&gt;인터페이스&lt;/h4&gt;

&lt;p&gt;클래스와 똑같이 짓거나(Collection, Comparator 등) able, ible로 끝나는 형용사로 짓습니다.(Runnable, Iterable, Accessible 등)&lt;/p&gt;

&lt;h4 id=&quot;애너테이션&quot;&gt;애너테이션&lt;/h4&gt;

&lt;p&gt;워낙 다양하게 활용되어서 지배적인 규칙 없이 명사, 동사, 전치사, 형용사가 두루 쓰입니다.(BindingAnnotation, Inject, ImplementedBy, Singleton 등)&lt;/p&gt;

&lt;h4 id=&quot;메서드&quot;&gt;메서드&lt;/h4&gt;

&lt;p&gt;목적어를 포함한 동사나 동사구로 짓습니다. boolean 값을 반환하는 메서드는 보통 is나 드물게 has로 시작하고 명사나 명사구, 형용사로 기능하는 아무 단어나 구로 끝나게 짓습니다.(isDigit, isProbablePrime, isEmpty, isEnabled, hasSiblings 등) 반환 타입이 boolean이 아니거나 해당 인스턴스의 속성을 반환하는 메서드의 이름은 보통 명사, 명사구, 혹은 get으로 시작하는 동사구로 짓습니다.(size, hashCode, getTime 등) get으로 시작하는 형태는 주로 자바빈즈 명세에 뿌리를 두고 있습니다. 자바빈즈는 재사용을 위한 컴포넌트 아키텍처의 초기 버전인데 최근 도구들 중에서도 이 규칙을 따르는 경우가 많아서 이런 도구의 규칙에 종속되는 경우라면 이 규칙을 따라야 합니다.&lt;/p&gt;

&lt;p&gt;이외에 특별한 메서드 이름이 몇 가지 있습니다. 객체의 타입을 바꿔서 반환하는 인스턴스 메서드의 이름은 보통 toType 형태로 짓습니다.(toString, toArray 등) 객체의 내용을 다른 뷰로 보여주는 메서드의 이름은 asType 형태로 짓습니다.(asList 등) 객체의 값을 기본 타입 값으로 반환하는 메서드의 이름은 보통 typeValue 형태로 짓습니다.(intValue 등) 마지막으로 정적 팩토리의 이름은 다양하지만 from, of, valueOf, instance, getinstance, newInstance, getType, newType을 흔히 사용합니다.&lt;/p&gt;

&lt;h4 id=&quot;필드&quot;&gt;필드&lt;/h4&gt;

&lt;p&gt;필드 이름은 api 설계를 잘 했으면 직접 노출될 일이 거의 없어서 덜 중요합니다. boolean 타입의 필드 이름은 보통 boolean 접근자 메서드에서 앞 단어를 뺀 형태입니다.(initialized, composite 등) 다른 타입의 필드라면 명사나 명사구를 사용합니다.(height, digits, bodyStyle 등) 지역변수 이름도 필드와 비슷하게 지으면 되지만 좀 더 느슨합니다.&lt;/p&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><category term="자바" /><summary type="html">조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.</summary></entry><entry><title type="html">이펙티브자바 - 8장. 메서드</title><link href="https://anstn1993.github.io/2021/07/21/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-8%EC%9E%A5.html" rel="alternate" type="text/html" title="이펙티브자바 - 8장. 메서드" /><published>2021-07-21T00:00:00+09:00</published><updated>2021-07-21T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/07/21/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-8%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/07/21/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-8%EC%9E%A5.html">&lt;p&gt;조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.&lt;/p&gt;

&lt;h1 id=&quot;8장-메서드&quot;&gt;8장. 메서드&lt;/h1&gt;

&lt;p&gt;이 장에서는 메서드의 배개변수와 반환값을 어떻게 처리하고, 시그니처는 어떻게 설계하는지, 문서화는 어떻게 해야 하는지에 대해서 살펴봅니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-49-매개변수가-유효한지-검사하라&quot;&gt;아이템 49. 매개변수가 유효한지 검사하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;메서드와 생성자는 매개변수의 값이 특정 조건을 만족해야 하는 경우가 많습니다. 가령 인덱스는 음수이면 안 되고 객체 참조는 null이면 안 됩니다. 이런 제약은 반드시 문서화하여 클라이언트에게 공지해야 하고 메서드 몸체가 시작되기 전에 검사를 먼저해야 합니다. &lt;strong&gt;오류는 가능한 한 빨리 잡아야&lt;/strong&gt;하기 때문입니다. 검사를 통해서 잘못된 값이 넘어오면 바로 예외를 던집시다. 검사를 빨리 하지 않으면 다음과 같은 문제가 생깁니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메서드가 수행되는 중간에 모호한 예외가 발생하면서 실패할 수 있다.&lt;/li&gt;
  &lt;li&gt;메서드가 잘 수행되지만 잘못된 결과를 반환할 수 있다.&lt;/li&gt;
  &lt;li&gt;메서드가 잘 수행되지만 객체를 이상한 상태로 만들어서 미래의 알 수 없는 시점에 이 메서드와 무관한 오류를 낼 수 있다.(실패 원자성을 어기는 결과)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그럼 매개변수의 유효성 검사를 하는 몇 가지 방법을 살펴보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;public과-protected-메서드는-매개변수-값이-잘못됐을-때-던지는-예외를-문서화해야-한다&quot;&gt;public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다.&lt;/h4&gt;

&lt;p&gt;아이템 76에서 더 자세히 살펴보겠지만 @throws 자바독 태그를 이용해서 쉽게 작성할 수 있습니다. 일반적으로 IllegalArgumentException, NullPointerException, IndexOutOfBoundsException이 될 것입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* (현재 값 mod m) 값을 반환한다. 이 메서드는 항상 음이 아닌 BigInteger를 반환한다는 * 점에서 remainder 메서드와 다르다.
*
* @param m 계수 (양수여야 한다.)
* @return 현재 값 mod m
* @throws ArithmeticException m이 0보다 작거나 같으면 발생한다.
*/&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BigInteger&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BigInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;signum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ArithmeticException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;계수(m)은 양수여야 합니다. &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고로 m이 null이면 signum메서드가 호출될 때 NullPointerException이 발생하지만 문서화하지 않은 이유는 이미 BigInteger 클래스 수준에서 기술이 되어있기 때문입니다.&lt;/p&gt;

&lt;h4 id=&quot;null-검사는-javautilobjectsrequirenonnull-메서드를-활용하자&quot;&gt;null 검사는 java.util.Objects.requireNonNull 메서드를 활용하자!&lt;/h4&gt;

&lt;p&gt;자바 7에서 추가된 requireNonNull 메서드를 사용하면 명시적인 null 체크를 하지 않아도 됩니다. 메서드에 전달된 인자 값의 null체크를 해서 null이면 NullPointerException을 던지고 null이 아니면 인자를 그대로 반환해줍니다. 물론 반환값이 필요없는 경우에도 검사용도로 사용해도 무방합니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;strategy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;requireNonNull&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strategy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;전략&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 예외 메세지 설정도 가능합니다.&lt;/p&gt;

&lt;p&gt;자바 9에서는 Objects에 범위 검사 기능도 추가되었습니다. checkFromIndexSize, checkFromToIndex, checkIndex라는 메서드들로 리스트와 배열 전용으로 설계됐고, 예외 메세지를 지정할 수 없고, 닫힌 범위는 다루지 못 한다는 점에서 제약이 있지만 이 제약이 크게 문제되지 않는 상황에선 유용합니다.&lt;/p&gt;

&lt;h4 id=&quot;public이-아닌-메서드라면-단언문assert를-이용해-매개변수-유효성-검증이-가능하다&quot;&gt;public이 아닌 메서드라면 단언문(assert)를 이용해 매개변수 유효성 검증이 가능하다.&lt;/h4&gt;

&lt;p&gt;외부에 공개되지 않는 메서드라면(public이 아니라면) 메서드 호출에 대한 통제가 충분히 가능하기 때문에 유효한 값만 전달할 수 있기에 이럴 때는 단언문으로도 충분합니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;단언문은 자신이 단언한 조건이 무조건 참이라고 선언하는 것으로 몇 가지 면에서 일반적인 유효성 검사와 다릅니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실패하면 AssertionError를 던진다.&lt;/li&gt;
  &lt;li&gt;런타임에 아무런 효과도, 성능 저하도 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;메서드가-직접-사용하지는-않지만-나중에-사용하기-위해-저장하는-매개변수는-더-신경써서-검사해야-한다&quot;&gt;메서드가 직접 사용하지는 않지만 나중에 사용하기 위해 저장하는 매개변수는 더 신경써서 검사해야 한다.&lt;/h4&gt;

&lt;p&gt;매개변수로 int 배열을 받아서 리스트에 추가한 후 리스트를 반환하는 메서드가 있으면 그 메서드는 int 배열의 null 체크를 확실하게 수행해야 합니다. 그러지 않으면 리스트가 반환된 후 그 리스트를 참조하는 다른 메서드에서 비로소 NullPointerException이 발생할 것이기 때문입니다. 이 시점까지 오게 되면 해당 리스트를 어떤 메서드가 반환했는지 디버깅하기가 어려워질 수 있습니다. 생성자도 마찬가지 입니다. 객체를 생성하는 시점에 유효성 검사를 철저하게 해서 클래스 불변식을 어기지 않는 객체를 만들어야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;유효성-검사-비용이-지나치게-높거나-계산-과정에서-암묵적으로-검사가-수행된다면-메서드-몸체-실행-전에-유효성-검사를-안-할-수도-있다&quot;&gt;유효성 검사 비용이 지나치게 높거나 계산 과정에서 암묵적으로 검사가 수행된다면 메서드 몸체 실행 전에 유효성 검사를 안 할 수도 있다.&lt;/h4&gt;

&lt;p&gt;가령 Collections.sort(list) 메서드를 호출하면 리스트는 이미 정렬 과정에서 상호 비교가 가능해야 하고, 비교할 수 없는 타입의 객체가 들어가있으면 그 객체와 비교할 때 내부적으로 ClassCastException을 던질 것입니다. 그래서 이런 경우에는 정렬 연산 전에 모든 요소가 비교가능한지 검사하는 것이 아무런 실익이 없습니다. 하지만 너무 암묵적 검사에 의존하면 실패 원자성을 해칠 수 있으니 주의해야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;유효성-검사에-실패했을-때-의도하지-않은-예외가-발생할-때는-적절한-예외로-번역해주자&quot;&gt;유효성 검사에 실패했을 때 의도하지 않은 예외가 발생할 때는 적절한 예외로 번역해주자.&lt;/h4&gt;

&lt;p&gt;때로는 유효성 검사 중에 api 문서에서 던지기로 한 예외와 다른 예외가 발생할 수 있습니다. 이럴 때는 catch 구문에서 그 예외를 받은 다음 api에서 던지기로 한 예외로 적절하게 바꿔서 던져줘야 합니다.&lt;/p&gt;

&lt;p&gt;지금까지 유효성 검사에 대해서 살펴봤습니다. 유효성 검사를 철저하게 해서 오류의 전파 범위를 최소화하는 것은 매우 중요하지만 그보다 더 중요한 것은 &lt;strong&gt;매개변수의 제약이 적은 최대한 범용적인 메서드를 만드는 것&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-50-적시에-방어적-복사본을-만들라&quot;&gt;아이템 50. 적시에 방어적 복사본을 만들라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;자바는 managed language이기 때문에 메모리 관리에 있어서 아주 안정적인 언어이지만 클라이언트로부터 객체 침범을 막을 수 있는 건 아닙니다. 그래서 프로그래머는 클라이언트가 항상 클래스 불변식을 깨려고 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍해야 합니다. 다음의 코드는 불변일 것 같지만 사실 불변이 아닙니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Period&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/**
  * @param start 시작 지삭
  * @param end 종료 시각; 시작 시각보다 뒤여야 한다.
  * @throws IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다.
  * @throws NullPointerException start나 end가 null이면 발생한다.
  */&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;가&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;보다 늦다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;멤버 필드가 final이기 때문에 불변처럼 보일 수 있지만 그렇지 않습니다. Date 자체가 가변이기 때문입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Period&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setYear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;78&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// p의 내부 수정&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Period의 end가 참조타입이고 바깥에서 그 참조에 수정을 가해버려서 불변식이 깨집니다. 사실 Date는 자바 8 이상이라면 사용하면 안 되는 API이고 그 대신 불변인 Instant나 LocalDateTime, ZonedDateTime을 사용하면 됩니다. 위와 같이 객체 바깥에서 내부에 수정을 가하는 것을 막으려면 &lt;strong&gt;생성자에서 받은 매개변수를 방어적으로 복사해서 멤버에 할당&lt;/strong&gt;해주면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;가&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;보다 늦다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드에서 주목해야 하는 점은 &lt;strong&gt;방어적 복사 이후에 유효성 검사&lt;/strong&gt;가 이루어졌다는 것입니다. 그 이유는 &lt;strong&gt;멀티스레딩 환경을 고려&lt;/strong&gt;했기 때문인데요. 만약 유효성 검사를 먼저 하고 복사본을 만들게 되면 유효성 검사가 끝난 시점에 다른 스레드가 생성자로 전달된 객체의 상태를 바꿔버려서 불변식을 깰 위험이 있기 때문입니다.
또 하나 주목할 점은 Date의 clone 메서드로 복사를 하지 않았다는 점입니다. 왜냐하면 Date는 final 클래스가 아니기 때문에 생성자로 전달되는 객체가 Date의 하위 타입이고 그 타입이 clone을 악의적으로 재정의해서 이상한 객체를 반환할 수도 있기 때문입니다. 그래서 &lt;strong&gt;매개변수가 제 3자에 의해 확장될 수 있는 타입이면 방어적 복사본을 만들 때 clone은 절대 사용하면 안 됩니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;하지만 아직 완벽한 방어는 끝나지 않았습니다. getter메서드인 start, end메서드가 필드 참조를 그대로 반환하기 때문입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Period&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Period&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setYear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;78&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// p의 내부 변경&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 공격도 마찬가지로 방어적 복사본을 반환하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 Period 클래스는 완벽한 불변으로 캡슐화됐습니다.(네이티브 메서드, 리플렉션 같은 수단을 동원하지 않는 한)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;매개변수로 전달된 객체를 클래스 내부의 자료구조에 보관해야 하는 경우에는 꼭 그 객체가 변경될 가능성이 있는지 파악해야 합니다.&lt;/strong&gt; 이는 매개변수의 방어적 복사를 하는 또 다른 이유입니다. 그리고 만약 변경이 가능하다면 변경 후에도 그 클래스가 문제 없이 동작할 수 있는지도 생각해야 합니다. 그렇지 않다면 복사본을 만들고 자료구조에 저장합시다. 가령 매개변수로 전달된 객체를 내부의 Set이나 Map의 키로 저장했는데 그 객체가 이후에 변경되면 Set, Map의 불변식이 깨지게 됩니다. 이는 자료구조를 반환할 때도 마찬가지 입니다. &lt;strong&gt;길이가 1 이상인 배열은 무조건 가변입니다.&lt;/strong&gt; 방어적 복사를 수행하거나 그게 아니라면 배열의 불변 뷰를 반환하는 대안도 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;PRIVATE_VALUES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 방어적 복사&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;PRIVATE_VALUES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 불변 뷰 반환&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Thing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;VALUES&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;unmodifiableList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;asList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;PRIVATE_VALUES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 호출자가 컴포넌트 내부를 수정하지 않을 것이라는 확신이 있거나 불변식이 깨져도 그 영향이 호출한 클라이언트로 국한될 때는 방어적 복사는 생략할 수 있습니다. 후자의 예로는 래퍼 클래스 입니다. 래퍼의 불변식을 파괴해도 그 영향은 클라이언트에 국한됩니다. 그럼에도 불구하고 호출자에서 해당 매개변수나 반환값은 수정하지 않아야 함을 문서화하는 것이 좋습니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-51-메서드-시그니처를-신중히-설계하라&quot;&gt;아이템 51. 메서드 시그니처를 신중히 설계하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;이 아이템에서는 api 설계시 중요한 메서드 시그니처 작성 요령들을 소개합니다.&lt;/p&gt;

&lt;h4 id=&quot;메서드-이름을-신중히-짓자&quot;&gt;메서드 이름을 신중히 짓자.&lt;/h4&gt;

&lt;p&gt;메서드의 이름은 항상 표준 명명 규칙을 따라야 합니다. 이해하기 쉽고 같은 패키지에 있는 다른 이름들과 일관되게 짓는 것이 중요합니다. 그 다음 목표기 개발자 커뮤니티에서 널리 통용되는 이름을 쓰는 것입니다. 긴 이름은 지양하고 애매하면 자바 라이브러리 API 가이드를 참조하세요.&lt;/p&gt;

&lt;h4 id=&quot;편의-메서드를-너무-많이-만들지-말자&quot;&gt;편의 메서드를 너무 많이 만들지 말자.&lt;/h4&gt;

&lt;p&gt;메서드가 너무 많아지면 api를 익히기 어려워지고 문서화, 테스트, 유지보수가 어려워집니다. 인터페이스도 그렇습니다. 인터페이스에 메서드가 너무 많으면 그 인터페이스를 구현해야 하는 사람과 사용하는 사람 모두가 고통스럽습니다. 아주 자주 쓰일 때만 별도의 약칭 메서드를 두고 확신이 없으면 만들지 맙시다.&lt;/p&gt;

&lt;h4 id=&quot;매개변수-목록은-4개-이하로-유지하자&quot;&gt;매개변수 목록은 4개 이하로 유지하자.&lt;/h4&gt;

&lt;p&gt;매개변수가 4개를 넘어가기 시작하면 기억하기 어렵습니다. 특히 &lt;strong&gt;더 안 좋은 경우는 같은 타입의 매개변수가 연달아서 나오는 경우&lt;/strong&gt;입니다. 순서를 바꿔서 입력해도 컴파일이 되고 운이 좋으면 런타임에 문제를 발견할 것이고 운이 나쁘면 문제가 안 생기고 의도와 다르게 동작하고 넘어갈 것입니다. 매개변수의 개수를 줄여주는 방법 3가지를 살펴보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;여러 메서드로 쪼개라.
메서드를 쪼개면 쪼개진 메서드는 각각 원래 매개변수 목록의 부분집합을 받습니다. 이는 직교성(소프트웨어 영역에서는 공통점이 없는 기능들이 잘 분리된 정도를 의미)을 높여 오히려 메서드 수를 줄이는 효과를 주기도 합니다. java.util.List 인터페이스가 좋은 예입니다. 리스트에서 지정된 범위의 부분리스트의 인덱스를 찾는다고 해보겠습니다. 이 기능을 하나의 메서드로 만들면 리스트의 시작, 리스트의 끝, 찾을 원소까지 3개의 원소가 필요한데 List는 부분리스트를 반환하는 subList와 주어진 원소의 인덱스를 알려주는 indexOf를 별개로 제공해서 두 메서드를 조합해서 원하는 기능을 수행하게 해뒀습니다. 이렇게 기능을 부분부분 쪼개뒀기 때문에 중복되는 유사한 기능에 대한 메서드의 추가 생성이 줄어들게 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;매개변수 여러 개를 묶어주는 도우미 클래스를 만들어라.
&lt;strong&gt;일반적으로 도우미 클래스는 정적 멤버 클래스&lt;/strong&gt;로 만듭니다. 특히 연속되는 매개변수 몇 개가 독립된 하나의 개념으로 볼 수 있을 때 좋습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1, 2의 혼합으로 빌더 패턴을 메서드 호출에 응용한다.
이 기법은 매개변수가 많은데 그 중 일부는 생략해도 괜찮을 때 유용합니다. 모든 매개변수를 하나로 추상화한 객체를 정의한 후, 이 객체의 세터 메서드를 호출해서 필요한 값을 설정하게 합니다. 특히 세터는 매개변수의 이름을 명확히 명시할 수 있어서 잘못된 값을 넣을 가능성이 낮습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;매개변수-타입으로는-클래스보다-인터페이스가-낫다&quot;&gt;매개변수 타입으로는 클래스보다 인터페이스가 낫다.&lt;/h4&gt;

&lt;p&gt;매개변수가 적절한 인터페이스를 구현했다면 그 인터페이스를 사용하는 것이 좋습니다. 메서드에 Map이 아닌 HashMap을 넘길 일은 존재하지 않습니다. Map을 넘기면 TreeMap, ConcurrentHashMap 등 어떤 맵도 넘길 수 있는 유연성이 생기고 아직 존재하지 않는 Map도 넘길 수 있습니다. 구상 클래스를 써버리면 무조건 그 타입만 넘길 수 있는 제한이 생기는 것이고 만약 다른 타입을 들고 있다면 매개변수 타입으로 변환하는 비용을 치러야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;boolean보다는-원소-2개짜리-열거-타입이-낫다메서드-이름상-boolean을-받는-것이-의미상-명확할-때는-예외&quot;&gt;boolean보다는 원소 2개짜리 열거 타입이 낫다.(메서드 이름상 boolean을 받는 것이 의미상 명확할 때는 예외)&lt;/h4&gt;

&lt;p&gt;열거타입을 쓰면 의미도 명확하여 코드를 읽기 쉽고 2개를 초과하는 선택지에 대해서도 대응이 가능합니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-52-다중정의는-신중히-사용하라&quot;&gt;아이템 52. 다중정의는 신중히 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;다중정의를 하게 되면 다중정의된 메서드 중에 어떤 메서드가 호출될지는 컴파일 타임에 정해지게 됩니다.&lt;/strong&gt; 왜냐하면 다중정의 메서드는 컴파일 타임의 매개변수 타입으로 결정되기 때문입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CollectionClassifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;classify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;집합&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;classify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;리스트&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;classify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;그 외&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collections&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(),&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;BigInteger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;(),&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드는 ‘그 외’만 3번 출력하고 종료됩니다. 왜냐하면 매개변수가 Collection&amp;lt;?&amp;gt; 타입으로 전달되고 그때는 ‘그 외’를 호출하는 메서드가 호출된다고 컴파일 타임에 정해졌기 때문입니다. 매개변수의 런타임 타입이 호출되는 메서드를 결정하는 재정의와는 다른 것을 알 수 있습니다. 문제를 해결하려면 메서드를 하나만 만들고 그 안에서 instanceof를 사용해서 런타임 타입으로 분기가 가능하게 하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;classify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;집합&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;리스트&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;그 외&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로그래머의 입장에서는 재정의가 정상이고, 다중정의가 예외적인 동작으로 보일 것이기 때문에 이처럼 헷갈릴 수 있는 코드는 작성하지 않는 것이 좋습니다. 특히 공개된 api라면 더더욱 그렇습니다.&lt;/p&gt;

&lt;p&gt;다중정의로 인한 혼란을 줄이려면 매개변수의 수가 같은 다중정의는 하지 않는 것이 좋습니다. 그리고 가변인수를 사용하는 메서드라면 다중정의는 아예 하지 말아야 합니다.(아이템 53에 예외가 있긴 합니다.)
이 규칙만 잘 따르면 다중정의로 인해 어떤 메서드가 호출될지 혼란스럽지 않을 것입니다.&lt;/p&gt;

&lt;p&gt;아니면 메서드 이름을 다르게 지어주는 것도 하나의 방법입니다. 대표적으로 ObjectOutputStream의 write메서드가 다중정의 대신 메서드 이름을 다르게 지어줬습니다. writeBoolean(boolean), writeInt(int), writeLong(long) 같은 식입니다. 이 방식이 다중정의보다 좋은 점은 read메서드와 짝을 맞추기 좋다는 것입니다. 실제로 ObjectInputStream의 read 메서드도 이와 같은 식입니다.&lt;/p&gt;

&lt;p&gt;그런데 생성자의 경우에는 이름을 다르게 지을 수 없습니다. 그래서 다중정의가 불가피한데, 이때는 정적 팩터리를 제공해서 클라이언트의 혼란을 방지할 수 있습니다. 그럼에도 불구하고 같은 수의 매개변수를 받는 경우를 완전히 피할 수는 없을 것입니다. 이에 대응할 수 있는 방안이 있습니다. 바로 &lt;strong&gt;매개변수 중 하나 이상이 ‘근본적으로 다르다’면 됩니다. 즉 null이 아닌 두 타입의 값이 서로 형변환이 불가능하면 된다는 것입니다.&lt;/strong&gt; 가령 ArrayList에 int를 받는 생성자와 Collection을 받는 생성자가 있는데 이 두 생성자 매개변수의 타입은 명확히 달라서 둘 중 어떤 것이 호출될지 헷갈리는 일은 없을 것입니다. 하지만 자바 5부터 기본타입 오토박싱이 도입되면서 꼭 그렇지도 않게 되어버렸습니다. List 인터페이스는 remove메서드를 remove(object), remove(int)로 다중정의했는데 첫번째는 매개변수로 전달된 값을 리스트에서 제거하는 것이고 두번째는 매개변수로 전달된 값의 인덱스에 위치하는 원소를 제거하는 것입니다. 근데 기본형인 int도 오토박싱이 되면 object의 하위 타입이 되기 때문에 프로그래머는 int를 전달해도 remove(object)가 호출될 것이라고 기대하게 됩니다. 이 문제를 해결하는 방법은 명시적으로 Integer로 형변환을 해주거나 Integer.valueOf(int)를 호출해서 Integer타입으로 변환해서 매개변수로 전달하는 것입니다.&lt;/p&gt;

&lt;p&gt;자바 8에서 도입된 람다와 메서드 참조 역시 다중정의에 혼란을 키운 사례입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 1번. Thread의 생성자 호출&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 2번. ExecutorService의 submit 메서드 호출&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드에서 2번은 컴파일 오류가 발생합니다. 전달된 인수는 모두 System.out::println이고 둘 다 Runnable을 받는 형제 메서드를 다중정의하고 있습니다. 그런데 submit 다중정의 메서드 중에서는 Callable&amp;#60;T&amp;#62;를 받는 메서드도 있고, println도 다중정의되어있어서 다중정의 해소 알고리즘이 기대처럼 동작하지 않는 상황입니다. 여기서 핵심은 &lt;strong&gt;다중정의된 메서드(혹은 생성자)들이 함수형 인터페이스를 받는 경우에는 서로 다른 함수형 인터페이스라도 인수 위치가 같으면 혼란이 생긴다&lt;/strong&gt;는 것입니다. 이는 서로 다른 함수형 인터페이스라도 서로 근본적으로 다르지 않다는 의미이기도 합니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-53-가변인수는-신중히-사용하라&quot;&gt;아이템 53. 가변인수는 신중히 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;가변인수 메서드를 호출하면 인수의 개수와 길이가 같은 배열을 만들어 인수들을 배열에 저장하여 메서드의 인자로 건네주게 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;args를 순회하면서 sum에 모두 더해서 반환해주는 간단한 함수입니다.&lt;/p&gt;

&lt;p&gt;때론 인수가 1개 이상이어야 할 때도 있습니다. 인자로 전달된 값들 중 최솟값을 찾는 메서드라면 인수를 1개 이상은 받아야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;인수가 1개 이상 필요합니다.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 구현을 하면 런타임에 인자가 0개 전달되면 예외가 발생하면서 실패하는 문제가 있습니다. 또 args 유효성 검사를 무조건 해야 하고 for-each 반복문도 사용할 수 없습니다. 다음이 훨씬 좋은 방식입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstArg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remainingArgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstArg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remainingArgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;첫 번째에 평범한 매개변수를 받게 해서 문제가 깔끔하게 해결됐습니다.&lt;/p&gt;

&lt;p&gt;가변인수 메서드는 호출될 때마다 배열을 생성하기 때문에 성능에 민감한 상황이라면 다음과 같이 절충할 수 있습니다. 예를 들어 가변인수 메서드 호출의 95%가 인수 3개 이하로 이루어진다고 가정하면 인수가 0개인 것부터 4개인 것까지 다중정의를 해서 인수 4개 이상인 메서드는 5%만 호출되게 하는 것입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;아이템-54-null이-아닌-빈-컬렉션이나-배열을-반환하라&quot;&gt;아이템 54. null이 아닌, 빈 컬렉션이나 배열을 반환하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;메서드에서 null을 반환하는 것은 지양해야 합니다. 받는 쪽에서 null 체크를 하는 방어코드를 항상 작성해야 하기 때문입니다. 그리고 이는 반환하는 쪽에서도 성가신 일입니다. null을 반환하는 케이스를 따로 작성해야하기 때문입니다. 혹자는 빈 컨테이너를 할당하는 데 비용이 드니까 null을 반환하는 것이 좋다고 주장하기도 하지만 이는 두 가지 면에서 틀린 주장입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;성능 분석 결과 이 할당이 성능 저하의 주범이라고 확인되지 않는 한 이 정도의 성능 차이는 신경 쓸 수준이 못 된다.
만약 성능 저하가 실제로 발생하면 매번 빈 ‘불변’ 컬렉션을 반환하면 됩니다ㅣ. 불변 객체는 자유롭게 공유해도 안전합니다. Collections.emptyList 메서드를 이용해서 불변 리스트를 반환하면 됩니다. 집합은 Collections.emptySet, 맵은 Collections.emptyMap을 이용합시다.&lt;/li&gt;
  &lt;li&gt;빈 컬렉션과 배열은 굳이 새로 할당하지 않고도 반환할 수 있다.
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Cheese&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getCheeses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cheesesInStock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;위와 같이 반환하면 됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;배열도 마찬가지입니다. null이 아닌 길이가 0인 배열을 반환하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cheese&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getcheeses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cheesesInStock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toArray&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cheese&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;toArray에 건낸 Cheese[]를 통해 타입 유추를 하게 됩니다. 만약 위의 방식으로 성능 저하가 예상되면 마찬가지로 길이 0짜리 배열을 미리 선언하고 그 배열을 반환하면 됩니다. 앞에서도 말했듯이 길이 0인 배열은 모두 불변입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cheese&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;EMPTY_CHEESE_ARRAY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cheese&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cheese&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getCheeses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cheesesInStock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toArray&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EMPTY_CHEESE_ARRAY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 toArray메서드를 이용하면 cheesesInStock에 원소가 없으면 EMPTY_CHEESE_ARRAY를 반환할 것이고 그렇지 않다면 Cheese[]타입의 새로운 배열을 만들어서 반환합니다. 이는 toArray의 스펙입니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-55-옵셔널-반환은-신중히-하라&quot;&gt;아이템 55. 옵셔널 반환은 신중히 하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;자바 8에서 추가된 옵셔널은 메서드가 값을 반환할 수 없을 때 취할 수 있는 좋은 선택지가 될 수 있습니다. 기존에는 null을 반환하거나 예외를 던졌어야 했습니다. null을 반환하면 null 처리를 위한 추가 코드가 필요해지고 만약 이런 처리를 안 하고 그냥 받아버리면 추후에 NullPointerException이 발생할 수 있는데 이는 null을 반환하게 한 근본적인 원인과 무관한 코드에서 발생하게 되기에 추적이 어려워집니다. 예외를 던지는 것도 진짜 예외적인 상황에서 던지는 것이 아닐뿐만 아니라 예외 생성시 스택 추적 전체를 캡처하게 되어서 비용도 만만치 않습니다. 하지만 옵셔널을 이용하면 위의 문제를 발생시키지 않을 수 있습니다.&lt;/p&gt;

&lt;p&gt;옵셔널은 개념적으로 원소를 최대 1개 가질 수 있는 ‘불변’ 컬렉션입니다. 값이 있으면 옵셔널에 담아서 반환하면 되고 비어있어도 빈 옵셔널을 반환하면 되어서 null을 반환하는 것과는 다릅니다. 이렇게 되면 받는 쪽도 옵셔널이라는 것을 알 수 있기 때문에 오류가 발생할 가능성이 낮아집니다.&lt;/p&gt;

&lt;p&gt;옵셔널은 적절한 정적 팩터리를 제공해줘서 그것들을 이용해서 생성하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 빈 옵셔널 생성&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// value를 담는 옵셔널 생성(null을 전달하면 NullPointerException)&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ofNullable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// value를 담는 옵셔널 생성(null도 전달 가능)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;옵셔널은 반환값이 없을 수도 있음을 api 사용자에게 명확히 알려주는 것이기 때문에 클라이언트가 이에 대처하는 코드를 작성해야함을 알 수 있습니다. 즉 값이 비었을 때 취할 행동을 선택하면 됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기본값을 설정한다.&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lastWordInLexicon&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;단어 없음...&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;만약 기본값을 생성하는 비용이 너무 커서 부담이 되면 Supplier&amp;#60;T&amp;#62;를 인수로 받는 orElseGet을 사용해서 값이 비어있을 때 기본값을 생성하게 해서 초기 설정 비용을 낮출 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;원하는 예외를 던진다.&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myToy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;orElseThrow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;TemperTantrumException:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;기본값과 마찬가지로 코드에 예외를 생성해서 전달하지 않고 예외를 생성하는 팩토리를 전달해서 예외가 실제로 발생할 때 예외를 생성해서 비용을 줄였습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;항상 값이 채워져 있다고 가정한다.&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lastNobleGas&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;NOBLE_GASES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;적합한 메서드가 없다면 isPresent메서드도 고려해보면 좋습니다. 옵셔널이 채워져 있으면 true를, 비어있으면 false를 반환하는데 앞서 살펴본 메서드들을 대부분 대체할 수 있습니다. 특히 옵셔널을 원소로 가지는 스트림은 filter와 map으로 편리하게 옵셔널의 값을 뽑아낼 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;streamOfOptionals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;Optional:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isPresent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;Optional:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그럼 옵셔널 반환을 선택해야 하는 기준을 알아보겠습니다. 옵셔널이 무조건 좋은 건 아닙니다. &lt;strong&gt;컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안 됩니다.&lt;/strong&gt; 빈 컨테이너는 그냥 그 자체로 반환해주면 됩니다. 빈 컨테이너도 이미 null이 아니기 때문입니다. 그리고 박싱된 기본 타입을 담는 옵셔널은 기본적으로 OptionalInt, OptionalLong, OptionalDouble을 제공하니 이들을 이용합시다. 즉 박싱된 기본 타입을 담은 옵셔널을 반환하는 일은 없어야 합니다. 이런 경우들을 제외하고 &lt;strong&gt;결과가 없을 수도 있으며, 클라이언트가 이 상황을 특별하게 처리해야 한다면&lt;/strong&gt; 옵셔널을 사용하면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-56-공개된-api-요소에는-항상-문서화-주석을-작성하라&quot;&gt;아이템 56. 공개된 API 요소에는 항상 문서화 주석을 작성하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;자바는 자바독(javadoc)이라는 유틸리티를 제공하는데 주석을 통해서 문서를 작성할 수 있게 해줍니다. 이런 특수한 형태의 주석을 문서화 주석이라고 합니다. 문서화 주석을 작성하는 업계의 표준 규칙이 존재합니다.&lt;/p&gt;

&lt;h4 id=&quot;외부로-공개되는-모든-클래스-인터페이스-메서드-필드-선언에-문서화-주석을-달아야-한다&quot;&gt;외부로 공개되는 모든 클래스, 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아야 한다.&lt;/h4&gt;

&lt;p&gt;만약 직렬화가 가능한 클래스라면 직렬화 형태에 관해서도 적어야 합니다. 문서화 주석이 없으면 api에 대한 사용법을 알기 어려워서 오류를 발생시킬 가능성이 높습니다. 그리고 기본 생성자에는 문서화 주석을 달 방법이 없어서 공개 클래스에는 절대 기본 생성자를 사용하면 안 됩니다. 유지보수까지 고려한다면 공개되지 않은 클래스, 인터페이스, 생성자, 메서드, 필더에도 문서화 주석을 달아주는 것이 좋습니다.&lt;/p&gt;

&lt;h4 id=&quot;메서드용-문서화-주석에는-해당-메서드와-클라이언트-사이의-규약을-명료하게-기술해라&quot;&gt;메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해라.&lt;/h4&gt;

&lt;p&gt;상속용으로 설계된 클래스의 메서드가 아니라면 그 메서드가 어떻게 동작하는지가 아닌 무엇을 하는지를 기술해야 합니다. 또한 클라이언트가 해당 메서드를 호출하기 위한 전제조건, 성공적으로 수행된 후에 만족해야 하는 사후조건, 부작용을 모두 나열해야 합니다. 여기서 부작용은 사후조건으로 명확히 나타나지는 않지만 시스템의 상태에 어떤 변화를 가져오는 것을 의미합니다. 이런 조건들을 모두 나열해서 작성된 문서화 주석을 하나 살펴보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* Returns the element at the specified position in this list.
* &amp;lt;p&amp;gt;This method is &amp;lt;i&amp;gt;not&amp;lt;/i&amp;gt; guaranteed to run in constant time. In Some
* implementations it may run in time proportional to the element position.
*
* @param index index of element to run; must be non-negative and less than
* the size of this list
* @return the element at the specified position in this list
* @throws IndexOutOfBoundsException if the index is out of range
*         ({@code index &amp;lt; 0 || index &amp;gt;= this.size()})
*/&lt;/span&gt;
&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;첫 문장: 문서화 주석의 첫 문장은 해당 요소의 요약 설명이 들어갑니다. 이때 요약 설명은 반드시 고유해야 합니다. 한 클래스(인터페이스) 안에서 요약 설명이 똑같은 멤버(생성자)가 둘 이상이면 안 됩니다. 이는 다중정의된 메서드에서도 마찬가지입니다.&lt;/li&gt;
  &lt;li&gt;@param: 매개변수가 뜻하는 값을 설명합니다. 명사구를 사용합니다.&lt;/li&gt;
  &lt;li&gt;@return: 반환값을 설명합니다. 명사구를 사용합니다.&lt;/li&gt;
  &lt;li&gt;@throws: 메서드에서 던질 수 있는 예외를 기술합니다. if로 시작해서 해당 예외를 던지는 조건을 설명하는 절이 뒤따릅니다.&lt;/li&gt;
  &lt;li&gt;@code: 이 태그로 감싼 내용을 코드용 폰트로 렌더링해주고, html 요소나 다른 자바독 태그를 무시해줍니다. 이 태그 덕분에 html 메타 문자인 &amp;lt; 같은 기호를 별다른 처리 없이 사용할 수 있습니다. 여러 줄로 된 코드 예시를 넣고 싶으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; 태그로 감싸면 됩니다. 그럼 html의 탈출 메타문자를 쓰지 않아도 줄바꿈이 유지됩니다. 단, @ 기호에는 탈출문자를 붙여야 하니 애너테이션을 사용할 때는 주의해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리고 주석의 첫 문장의 마지막에 this list에서 this는 해당 메서드가 속한 객체를 의미합니다. 관례상 그렇게 쓰입니다.&lt;/p&gt;

&lt;p&gt;위에서 상속용 클래스가 아닌 이상 무엇을 하는지 기술해야 한다고 했습니다. 그 말은 상속용 클래스의 경우에는 어떻게 동작하는지도 적어줘야 함을 의미합니다. 자기사용 패턴에 대해 문서를 남겨서 그 메서드를 올바로 재정의하는 방법을 알려줘야 합니다. 이는 @implSpec 태그로 문서화합니다. 이 주석은 메서드와 클라이언트가 아닌 메서드와 하위 클래스 사이의 계약을 설명하여 하위 클래스들이 그 메서드를 상속하거나 super 키워드를 이용해 호출할 때 그 메서드가 어떻게 동작하는지를 인지하도록 하기 위해 존재합니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* Returns true if this collection is empty.
*
* @implSpec
* This implementation returns {@code this.size() == 0}
*
* @return true if this collection is empty
*/&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자바 11버전까지도 자바독 명령줄에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-tag &quot;implSpec:a:Implementation Requirements:&quot;&lt;/code&gt; 스위치를 켜줘야지만 @implSpec 태그가 반영됩니다.&lt;/p&gt;

&lt;p&gt;api 설명에 &amp;lt;, &amp;gt;, &amp;amp; 등의 html 메타문자를 포함시키려면 {@literal} 태그로 감싸면 됩니다. {@code}와 비슷하지만 코드용 폰트로 렌더링하지 않아서 일반 주석처럼 나오게 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* A geometric series converges if {@literal |r| &amp;lt; 1}
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사실 &amp;lt; 기호만 감싸도 결과는 똑같지만 문서화 주석을 읽기가 불편해지기 때문에 표현식 하나를 통으로 묶은 것입니다. {@literal} 태그는 첫 문장인 요약 설명 문장 사이에 마침표가 나와서 의도치 않은 지점에서 첫 문장이 끊어지는 것을 방지하기 위해서 사용할 수도 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* 머스터드 대령이나 Mrs. 피콕 같은 용의자.
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 요약 설명에서 작성자가 의도한 문장의 끝은 ‘용의자’일 것입니다. 하지만 ‘Mrs’뒤에 마침표가 나와버리면서 ‘Mrs’를 문장의 끝으로 인식해버립니다. 이럴 때는 {@literal} 태그로 감싸주면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* 머스터드 대령이나 {@literal Mrs. 피콕} 같은 용의자.
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자바 10 부터는 {@summary}라는 요약 설명 전용 태그가 추가되어서 더 깔끔하게 처리할 수 있게 되었습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* {@summary 머스터드 대령이나 Mrs. 피콕 같은 용의자.}
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자바 9부터는 자바독이 생성한 html 문서에 검색 기능이 추가되어서 문서 내에서 원하는 내용을 찾는 것이 한결 수월해졌습니다. 문서 페이지 오른쪽 위에 있는 검색창에 키워드를 입력하면 관련 페이지들이 드롭다운으로 나타납니다. 클래스, 메서드, 필드 같은 요소의 색인은 자동으로 만들어지며 만약 추가적으로 중요한 용어를 색인화하고 싶다면 {@index} 태그를 사용하면 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;제네릭-타입이나-제네릭-메서드를-문서화할-때는-모든-타입-매개변수에-주석을-달아야-한다&quot;&gt;제네릭 타입이나 제네릭 메서드를 문서화할 때는 모든 타입 매개변수에 주석을 달아야 한다.&lt;/h4&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* An object that maps keys to values. A map cannot contain
* duplicate keys; each key can map to at most one value.
*
* (Remainder omitted)
*
* @param &amp;lt;K&amp;gt; the type of Keys maintained by this map
* @param &amp;lt;V&amp;gt; the type of mapped values
*/&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;@param 태그를 이용해서 제네릭 타입에 대한 설명을 추가해야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;열거-타입을-문서화할-때는-상수들에도-주석을-달아야-한다&quot;&gt;열거 타입을 문서화할 때는 상수들에도 주석을 달아야 한다.&lt;/h4&gt;

&lt;p&gt;열거 타입 자체와 열거 타입의 public 메서드에도 주석을 달아야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* An instrument section of a symphony orchestra.
*/&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrchestraSection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/** Woodwinds, such as flute, clarinet, and oboe. */&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;WOODWIND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/** Brass instruments, such as french horn and trumpet. */&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;BRASS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/** Percussio instruments, such as timpani and cymbals. */&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;PERCUSSION&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;

  &lt;span class=&quot;cm&quot;&gt;/** Stringed instruments, such as violin and cello. */&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;STRING&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;애녀테이션-타입을-문서화할-때는-멤버들에도-모두-주석을-달아야-한다&quot;&gt;애녀테이션 타입을 문서화할 때는 멤버들에도 모두 주석을 달아야 한다.&lt;/h4&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
* Indicates that the annotated method is a test method
* that must throw the designated exception to pass.
*/&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Retention&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RetentionPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;RUNTIME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;METHOD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExceptionTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/**
  * The exception that the annotated test method must throw
  * in order to pass. (The test is permitted to throw any
  * subtype of the type described by this class object.)
  */&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><category term="자바" /><summary type="html">조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.</summary></entry><entry><title type="html">이펙티브자바 - 7장. 람다와 스트림</title><link href="https://anstn1993.github.io/2021/07/14/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-7%EC%9E%A5.html" rel="alternate" type="text/html" title="이펙티브자바 - 7장. 람다와 스트림" /><published>2021-07-14T00:00:00+09:00</published><updated>2021-07-14T00:00:00+09:00</updated><id>https://anstn1993.github.io/2021/07/14/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-7%EC%9E%A5</id><content type="html" xml:base="https://anstn1993.github.io/2021/07/14/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-7%EC%9E%A5.html">&lt;p&gt;조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.&lt;/p&gt;

&lt;h1 id=&quot;7장-람다와-스트림&quot;&gt;7장. 람다와 스트림&lt;/h1&gt;

&lt;p&gt;자바 8부터 추가되기 시작한 함수형 인터페이스, 람다, 메서드 참조 개념과 더불어 스트림 API가 추가되었습니다. 이들에 대해서 살펴보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-42-익명-클래스보다는-람다를-사용하라&quot;&gt;아이템 42. 익명 클래스보다는 람다를 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;자바 8이 등장하기 전에는 자바에서 함수 타입을 표현하기 위해서 추상 메서드를 딱 하나만 가지는 인터페이스(드물게 추상 클래스)를 사용했습니다. 이런 인터페이스를 인스턴스화하면 그것을 함수 객체라고 불렀고 주로 익명 클래스로 생성을 했습니다. 하지만 익명 클래스는 코드가 너무 길어지는 문제가 있었고 이는 함수형 프로그래밍에 적합하지 않았습니다.&lt;/p&gt;

&lt;p&gt;그래서 자바 8부터는 위와 같은 추상 메서드 하나만 가지는 인터페이스에 특별한 의미를 부여하여 &lt;strong&gt;함수형 인터페이스&lt;/strong&gt;라는 명칭을 부여하고 함수형 인터페이스는 람다식으로 표현이 가능하게 되었습니다. 람다의 대부분의 경우 매개변수, 반환 타입은 컴파일러가 문맥을 살펴 타입 추론을 해줍니다. 만약 타입을 결정하지 못하는 경우에는 프로그래머가 직접 명시를 해주면 됩니다. 이와 관련해서 제네릭의 사용이 중요합니다. 제네릭은 컴파일러의 타입을 추론하는 데 필요한 타입 정보를 제공하기에 제네릭을 사용해야 컴파일러가 람다의 타입을 추론할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 익명 클래스로 표현한 함수 객체&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Comparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 람다로 표현한 함수 객체&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 비교자 생성 정적 메서드를 이용해서 더 간결하게 표현 가능&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comparingInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;String:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 람다를 써서 코드가 매우 간결해져서 함수 객체를 실용적으로 쓸 수 있게 됐습니다. 아이템 34의 Operation 열거 타입의 코드를 생각해보면, apply 메서드의 동작이 상수마다 달라야 해서 상수별로 apply 메서드를 재정의했습니다. 그런데 람다를 이용하면 함수 객체를 필드로 두고 생성자로 람다를 넘기면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Operation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;PLUS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;+&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;MINUS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;TIMES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;DIVIDE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DoubleBinaryOperator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;nc&quot;&gt;Operation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DoubleBinaryOperator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;symbol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;applyAsDouble&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;DoubleBinaryOperator는 java.util.function 패키지가 제공하는 표준 함수형 인터페이스 중 하나입니다. double 타입 인수 2개를 받아서 double 타입을 반환합니다. 이렇게 보면 Operation에서는 더 이상 상수 인스턴스별로 클래스 몸체를 사용할 이유가 없다고 느낄 수 있지만 꼭 그렇지는 않습니다. 메서드나 클래스와 달리 람다는 이름을 가지지 않고 문서화를 하지 못 합니다. 그래서 &lt;strong&gt;코드 자체로 동작이 명확하게 설명되지 않거나 코드 줄 수가 많아지만 람다를 쓰면 안 됩니다.&lt;/strong&gt; 람다는 한 줄로 표현 가능할 때 가장 좋고 아무리 길어도 3을 넘지 않는 게 좋습니다. 또한 &lt;strong&gt;생성자 안의 람다는 열거 타입의 인스턴스 멤버에 접근할 수 없습니다.&lt;/strong&gt; 인스턴스가 런타임에 만들어지기 때문 입니다. 그러니 위의 두 경우에는 상수별 클래스 몸체를 사용해서 메서드를 구현하는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;마지막으로 람다가 대체할 수 없는 케이스를 살펴보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;추상 클래스의 인스턴스를 만들 때는 람다를 사용할 수 없고 익명 클래스를 써야만 한다.&lt;/li&gt;
  &lt;li&gt;추상 메서드가 여러 개인 인터페이스의 인스턴스도 무조건 익명 클래스를 써야 한다.&lt;/li&gt;
  &lt;li&gt;람다는 자신을 참조할 수 없기 때문에 함수 객체가 자기 자신을 참조할 일이 있다면 무조건 익명 클래스를 써야 한다.
람다의 this 키워드는 바깥 인스턴스를 가리키지만, 익명 클래스의 this는 자기 자신을 가리킵니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;아이템-43-람다보다는-메서드-참조를-사용하라&quot;&gt;아이템 43. 람다보다는 메서드 참조를 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;이전 아이템에서 람다가 익명 클래스보다 훨씬 간결하게 함수 객체를 표현하는 것을 봤습니다. 그런데 &lt;strong&gt;매서드 참조&lt;/strong&gt;를 이용하면 람다보다도 더 간결하게 함수 객체를 만들 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;incr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;incr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자바 8에서 Map에 추가된 merge 메서드 입니다. 매개변수로는 키, 값, 함수를 받으며, 전달된 키가 맵 안에 없으면 전달된 키, 값을 맵에 추가합니다. 키가 맵 안에 있다면 그 키의 현재 값과 매개변수로 전달된 값을 세 번째 매개변수인 함수의 인자로 전달해서 연산을 한 결과 값을 현재 키의 값으로 덮어쓰게 됩니다. 람다를 통해 충분히 간결하지만 count, incr는 단순히 합해져서 반환되기 때문에 이런 더하기 연산을 해서 반환해주는 람다와 같은 기능을 제공하는 박싱 클래스의 정적 메서드 sum을 자바 8부터 제공해줍니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;Ingeter:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그래서 위처럼 메서드 참조를 전달해서 더 간단하게 표현 가능합니다. 단 때론 람다의 매개변수 이름이 프로그래머에게 정보를 제공하는 경우도 있기 때문에 그런 경우에는 람다를 유지하는 게 더 좋을 수 있습니다. 또한 람다가 메서드 참조보다 간결할 때가 있습니다. 바로 메서드와 람다가 같은 클래스에 있을 때입니다. 다음의 코드가 GoshThisClassNameIsHumongous 클래스 안에 있다고 해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;GoshThisClassNameIsHumongous:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이를 람다로 대체하면 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이처럼 같은 클래스 내부의 메서드를 호출할 일이 있으면 차라리 람다가 더 간결합니다. 같은 맥락으로 java.util.function패키지가 제공하는 제네릭 정적 팩터리 메서드인 Function.identity()를 사용하는 것보다는 똑같은 기능을 하는 (x -&amp;gt; x)를 사용하는 것이 더 짧으면서도 명확합니다.&lt;/p&gt;

&lt;h3 id=&quot;5개의-메서드-참조-유형&quot;&gt;5개의 메서드 참조 유형&lt;/h3&gt;

&lt;p&gt;메서드 참조는 5개의 유형을 가집니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;정적 메서드 참조
앞서 살펴본 유형입니다.&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;Integer:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parseInt&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;위의 두 표현식은 같습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;한정적 (인스턴스) 메서드 참조
참조 대상 인스턴스(수신 객체)를 특정하는 메서드 참조 입니다. 이 참조는 근본적으로 정적 참조와 비슷합니다.&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nc&quot;&gt;Instant&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Instant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isAfter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;nc&quot;&gt;Instant&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isAfter&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;위의 두 표현식은 같습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비한정적 (인스턴스) 메서드 참조
참조 대상 인스턴스(수신 객체)를 특정하지 않는 메서드 참조 입니다. 이 참조의 경우 함수 객체를 적용하는 시점에 수신 객체를 알려주게 됩니다.&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toLowerCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;String:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toLowerCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;위의 두 표현식은 같습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클래스 생성자&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;();&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;TreeMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;위의 두 표현식은 같습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열 생성자&lt;/p&gt;
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;위의 두 표현식은 같습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;아이템-44-표준-함수형-인터페이스를-사용하라&quot;&gt;아이템 44. 표준 함수형 인터페이스를 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;자바가 람다를 지원하면서 동시에 java.util.functoin 패키지에 다양한 용도의 표준 함수형 인터페이스를 제공하기 시작했습니다. 기존에는 이를 직접 생성해서 사용했다면 이제는 용도에 맞는 표준 함수형 인터페이스를 사용하는 것이 좋을 겁니다. 그렇게 해야 코드들의 통일성이 높아지고 코드별로 익혀야 하는 개념들이 줄어들고, 다른 코드들과의 상호 운용성도 좋아질 것입니다.&lt;/p&gt;

&lt;h4 id=&quot;6개의-표준-함수형-인터페이스&quot;&gt;6개의 표준 함수형 인터페이스&lt;/h4&gt;

&lt;p&gt;java.util.function 패키지에는 43개의 인터페이스가 담겨 있지만, 기본 인터페이스 6개만 잘 익혀두면 나머지는 유추할 수 있습니다. 먼저 이 기본 인터페이스들은 모두 참조 타입용입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UnaryOperator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BinaryOperator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Predicate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Supplier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Consumer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;먼저 Operator는 입력 인수와 반환 인수가 같은 함수를 의미합니다. Unary와 Binary의 차이는 입력 인수의 개수로 각각 1개, 2개를 받습니다. 각각 String::toLowerCase, BigInteger::add가 대표적입니다. Predicate는 인수 하나를 받아서 boolean을 반환하는 함수를 의미합니다. Collection::isEmpty가 대표적입니다. Function 인터페이스는 인수와 반환 타입이 다른 함수를 의미합니다. Arrays.asList가 대표적입니다. Supplier는 인수는 받지 않고 반환하는 함수, Consumer는 인수는 받고 반환하지 않는 함수입니다. 각각 Instant::now, System.out::println가 대표적입니다.&lt;/p&gt;

&lt;p&gt;위의 6개에서 특정 키워드가 붙으면서 가지수가 늘어나는 겁니다. 예를 들면 참조 타입이 아닌 기본 타입인 int, long, double용으로 3개의 변형이 생깁니다. 기본 인터페이스의 이름 앞에 기본 타입을 붙이면 됩니다. 예를 들면, int를 받는 Predicate의 경우 IntPredicate가 됩니다. 이 변형들 중에 Function은 좀 예외적으로 입력 타입은 똑같이 인터페이스 이름 앞에 붙이고 반환 타입은 매개변수화하여 지정합니다. long인수를 받아서 int[]를 반환하는 Function의 경우 LongFunction&amp;lt;int[]&amp;gt;이 됩니다.&lt;/p&gt;

&lt;p&gt;추가적으로 Function은 기본타입을 반환하는 변형이 9개 존재합니다. 입력과 결과 타입이 모두 기본형이면 접두어로 SrcToResult를 사용합니다. long을 받아서 int를 반환하면 LongToIntFunction이 됩니다.(6개) 나머지는 입력이 객체 참조고 결과가 int, long, double인 경우로 접두어로 ToResult를 사용합니다. 즉, ToLongFunction&amp;lt;int[]&amp;gt;는 int[] 인수를 받아서 long을 반환합니다.(3개)&lt;/p&gt;

&lt;p&gt;기본 함수형 인터페이스 중 3개는 인수를 2개씩 받는 변형이 있습니다. BiPredicate&amp;lt;T, U&amp;gt;, BiFunction&amp;lt;T, U, R&amp;gt;, BiConsumer&amp;lt;T, U&amp;gt;가 그 주인공인데, BiFunction에는 다시 기본 타입을 반환하는 세 개의 변형인 ToIntBiFunction&amp;lt;T, U&amp;gt;, ToLongBiFunction&amp;lt;T, U&amp;gt;, ToDoubleBiFunction&amp;lt;T, U&amp;gt;가 있습니다. Consumer에도 객체 참조와 기본 타입 하나, 즉 인수 2개를 받는 변형인 ObjDoubleConsumer&amp;#60;T&amp;#62;, ObjIntConsumer&amp;#60;T&amp;#62;, ObjLongConsumer&amp;#60;T&amp;#62;이 존재합니다. 이렇게 기본 인터페이스의 인수 2개짜리 변형은 총 9개 입니다.&lt;/p&gt;

&lt;p&gt;마지막으로 BooleanSupplier는 boolean을 반환하도록 한 Supplier의 파생입니다.&lt;/p&gt;

&lt;p&gt;표준 함수형 인터페이스는 이처럼 대부분 기본 타입만 지원합니다. 그런데 여기에 박싱된 타입을 넣어서 사용하는 것은 지양해야 합니다. 동작하긴 하지만 계산량이 많을 때는 성능저하가 심해질 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;인터페이스를-직접-작성해야-하는-순간&quot;&gt;인터페이스를 직접 작성해야 하는 순간?&lt;/h4&gt;

&lt;p&gt;대부분 표준 함수형 인터페이스를 쓸 수 있으면 쓰는 것이 좋지만 직접 작성해야 하는 순간도 있습니다. 당연한 말이지만 표준 인터페이스 중 적합한 용도가 없다면 직접 작성해야 합니다. 그런데 존재하더라도 직접 작성해야하는 경우가 있습니다. 가장 대표적인 예가 Comparator&amp;#60;T&amp;#62;입니다. Comparator는 ToIntBiFunction&amp;lt;T, U&amp;gt;와 동일한데도 독자적인 인터페이스로 존재합니다. 그 이유는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;매우 자주 사용되며 이름 자체가 용도를 아주 훌륭하게 표현해준다.&lt;/li&gt;
  &lt;li&gt;구현하는 쪽에서 반드시 지켜야 하는 규약을 담는다.&lt;/li&gt;
  &lt;li&gt;비교자들을 변환, 조합해주는 유용한 디폴트 메서드들이 많이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만약, 위의 조건 중에 하나라도 해당하는 경우라면 직접 함수형 인터페이스를 작성하는 것을 고민해보는 것이 좋습니다.&lt;/p&gt;

&lt;h4 id=&quot;함수형-인터페이스를-직접-작성할-때는-functionalinterface를-쓰자&quot;&gt;함수형 인터페이스를 직접 작성할 때는 @FunctionalInterface를 쓰자&lt;/h4&gt;

&lt;p&gt;함수형 인터페이스를 직접 작성할 때는 @FunctionalInterface 애너테이션을 사용하는 것이 좋습니다. 그 이유는 @Override를 사용하는 것과 비슷합니다. 우선 정보를 제공하는 용도입니다. 해당 인터페이스가 람다용으로 설계된 것임을 알릴 수 있습니다. 더 중요한 것은 이 애너테이션이 붙어있으면 추상 메서드를 딱 하나만 가질 때 컴파일이 되기 때문에 추후에 누가 메서드를 추가하는 등의 실수를 막아줍니다.&lt;/p&gt;

&lt;h4 id=&quot;api에서-함수형-인터페이스를-사용할-때의-주의점&quot;&gt;API에서 함수형 인터페이스를 사용할 때의 주의점&lt;/h4&gt;

&lt;p&gt;서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들은 다중정의하면 안 됩니다. 클라이언트에게 모호함만 안겨주고 실제 문제로 이어질 수 있습니다. ExecutorService의 submit 메서드는 Callable&amp;#60;T&amp;#62;를 받는 것과 Runnable을 받는 것을 다중정의해서 올바른 메서드를 알려주기 위해서 형변환을 해야 할 경우가 생깁니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-45-스트림은-주의해서-사용하라&quot;&gt;아이템 45. 스트림은 주의해서 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;스트림 api는 다량의 데이터 원소를 원하는 방식으로 처리해줍니다. 이 api는 두 가지의 추상 개념을 가집니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스트림은 데이터 원소의 유한 혹은 무한 시퀀스를 뜻한다.&lt;/li&gt;
  &lt;li&gt;스트림 파이프라인은 이 원소들로 수행하는 연산의 단계를 의미한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;스트림-api의-기본-개념&quot;&gt;스트림 api의 기본 개념&lt;/h4&gt;

&lt;p&gt;스트림 원소의 원천은 컬렉션, 배열, 파일, 혹은 다른 스트림 등 무엇이든지 될 수 있습니다. 그리고 원소는 참조타입과 기본타입(int, long, double)을 지원합니다.&lt;/p&gt;

&lt;p&gt;스트림 파이프라인은 소스 스트림(원소의 원천)에서 시작해서 원한다면 하나 이상의 중간 연산을 거쳐서 종단 연산으로 끝이 납니다. 각각의 중간 연산에서 소스 스트림의 원소에 어떤 함수를 적용하거나 원소를 걸러내는 등 다양한 작업을 할 수 있습니다. 그리고 종단 연산에서는 컬렉션에 원소를 담거나 하나의 원소를 선택하는 등의 작업을 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;스트림 파이프라인은 지연 평가됩니다. 종단 연산이 이루어지기 전까지는 평가가 이루어지지 않으며 종단 연산에 쓰이지 않는 원소는 계산에서 제외되기 때문에 효율적입니다. 이 말은 종단 연산을 빼면 중간 연산은 일어나지 않는다는 것이니 종단 연산으로 꼭 마무리를 해줘야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;스트림-api를-잘-활용하기&quot;&gt;스트림 api를 잘 활용하기&lt;/h4&gt;

&lt;p&gt;사전 파일에서 단어를 읽어서 사용자가 지정한 문턱값보다 원소 수가 많은 아나그램(철자를 구성하는 알파벳이 같고 순서만 다른 단어) 그룹을 출력하는 코드를 보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Anagrams&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minGroupSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;groups&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;groups&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;computeIfAbsent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alphabetize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unused&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;groups&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minGroupSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alphabetize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toCharArray&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Arrays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드를 스트림을 이용하면 아래와 같이 간결하게 표현할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Anagrams&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Path&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Paths&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minGroupSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Files&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lines&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dictionary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;groupingBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alphabetize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 영단어를 키로 하는 맵 생성&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Stream&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; 생성&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minGroupSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 문턱값보다 큰 리스트만 남김&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 필터링에서 살아남은 리스트만 출력&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// alphabetize 코드는 동일&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;alphabetize도 스트림으로 구현할 수 있지만 자바는 char용 스트림을 지원하지 않기 때문에 char 값들을 처리할 때는 스트림을 사용하지 않는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;스트림이 아무리 간결해보이더라도 무조건 반복문을 스트림으로 바꾸는 것이 능사는 아닙니다. 오히려 스트림만 고집하면 가독성, 유지보수성이 떨어질 수 있으니 스트림과 반복문을 적절히 조합하는 것이 가장 좋습니다. 뿐만 아니라 스트림이 반복문을 모두 대체할 수 있는 것도 아닙니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;람다는 final인 변수만 읽을 수 있기 때문에 지역변수는 읽을 수 없다. 즉 반복문만이 지역변수에 접근할 수 있다.&lt;/li&gt;
  &lt;li&gt;람다에서는 return, break, continue를 이용해서 반복 제어를 할 수 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;함수객체(람다)를 인자로 전달하는 스트림에서 위의 로직이 필요하다면 반복문을 사용할 수밖에 없습니다. 반대로 다음은 스트림을 쓰기에 아주 좋은 경우들 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;원소들의 시퀀스를 일관되게 변환한다.&lt;/li&gt;
  &lt;li&gt;원소들의 시퀀스를 필터링한다.&lt;/li&gt;
  &lt;li&gt;원소들의 시퀀스를 하나의 연산을 사용해 결합한다.(더하기, 연결하기, 최솟값 구하기 등)&lt;/li&gt;
  &lt;li&gt;원소들의 시퀀스를 컬렉션에 모은다.(아마도 공통된 속성을 기준으로 묶어가며)&lt;/li&gt;
  &lt;li&gt;원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;아이템-46-스트림에서는-부작용-없는-함수를-사용하라&quot;&gt;아이템 46. 스트림에서는 부작용 없는 함수를 사용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;스트림 api 패러다임의 핵심은 연산들 간의 독립성입니다. 각 연산을 통한 변환 단계는 이전 단계의 결과를 받아서 처리하는 &lt;strong&gt;순수함수&lt;/strong&gt;입니다. 즉 스트림 연산에 전달되는 함수 객체는 부작용이 없어야 합니다. 즉 함수가 외부의 상태를 변경하지 않아야 한다는 것입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toLowerCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;Long:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드는 단어별 수를 카운트해서 빈도표를 만듭니다. 스트림, 람다, 메서드 참조를 사용했고 결과도 올바르지만 스트림 코드를 가장한 반복문 코드입니다. 왜냐하면 이 코드의 모든 작업이 종단 연산인 forEach에서 일어나는데 여기서 만약 외부 상태(빈도표)를 수정하는 람다를 실행하면 문제가 생깁니다ㅣ. forEach에서 스트림의 수행 결과를 출력하는 것 이상의 일을 하면 나쁜 코드는 아닌지 의심해봐야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;tokens&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;groupingBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;String:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toLowerCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counting&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 작성하는 것이 스트림을 제대로 활용한 것입니다. &lt;strong&gt;forEach 종산 연산은 종단 연산 중 기능이 가장 적고 덜 스트림답기 때문에 계산 결과를 보고할 때만 사용하고 계산하는 용도로 사용하지 않는 것이 좋습니다.&lt;/strong&gt; 다시 코드로 돌아가서 수집기(collector)를 사용하고 있는데 수집기를 통해서 스트림 원소를 컬렉션으로 모을 수 있습니다. 수집기는 총 3가지가 있는데 toList(), toSet(), toCollection(collectionFactory) 입니다.&lt;/p&gt;

&lt;p&gt;그럼 위에서 생성한 빈도표에서 가장 빈도수가 높은 10개의 단어를 뽑아내보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topTen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;keySet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;comparing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;freq:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;reversed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;sorted에는 비교자를 넣어줘서 정렬이 되게 하고 reversed를 통해서 빈도가 높은 단어가 위로 가게 역순 정렬을 했습니다.&lt;/p&gt;

&lt;h4 id=&quot;collectors의-다양한-메서드들&quot;&gt;Collectors의 다양한 메서드들&lt;/h4&gt;

&lt;p&gt;java.util.stream.Collectors 클래스는 메서드를 총 39개 가지고 있습니다. 그 중 대부분은 스트림을 맵으로 취합하는 기능입니다. 스트림의 각 원소는 키 하나와 값 하나에 연관되어 있습니다. 그리고 다수의 원소가 같은 키에 연관될 수 있습니다.&lt;/p&gt;

&lt;h5 id=&quot;tomap&quot;&gt;toMap&lt;/h5&gt;

&lt;p&gt;가장 간단한 맵 수집기는 toMap(keyMapper, valueMapper)로 원소를 키에 맵핑하는 함수, 값에 맵핑하는 함수를 인수로 받습니다. 이 toMap은 각 원소가 고유한 키에 맵핑될 때 사용해야 합니다. 다수의 원소가 같은 키를 사용하면 파이프라인이 IllegalStateException을 던지면서 종료됩니다. 이외에도 더 복잡한 toMap, groupingBy는 이런 충돌을 다루는 전략들을 제공합니다. 가령, toMap에는 키, 값 매퍼 함수 뿐만 아니라 merge(병합) 함수까지 전달할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,?,&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;toMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keyMapper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valueMapper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BinaryOperator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mergeFunction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;병합 함수의 형태는 BinaryOpeerator&amp;#60;U&amp;#62;이고 U는 해당 맵의 값 타입이 됩니다. 같은 키를 공유하는 원소들은 모두 이 병합 함수를 통해서 기존 값에 합쳐집니다. 만약 병합 함수가 곱셈이면 키가 같은 모든 값을 곱한 결과를 얻게 됩니다. 이 toMap을 이용해서 키와 그 키에 연관된 원소들 중 하나만 골라서 값으로 삼는 맵을 만들 수도 있습니다. 다양한 음악가의 앨범들을 담은 스트림으로 음악가와 그 음악가의 베스트 앨범을 연관 지어보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Artist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Album&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;topHits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;albums&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;Album:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;artist&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;comparing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;Album:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sales&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;maxBy는 BinaryOperator의 정적 팩토리 메서드 입니다. Comparator&amp;#60;T&amp;#62;를 입력받아서 BinaryOperator&amp;#60;T&amp;#62;를 돌려줍니다.&lt;/p&gt;

&lt;p&gt;다음과 같이 값이 충돌하면 마지막 값을 취하는 수집기를 만들 수도 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;toMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keyMapper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valueMapper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막으로 인수를 4개 받는 toMap입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,?,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;toMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keyMapper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valueMapper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BinaryOperator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mergeFunction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Supplier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapSupplier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;네 번째 인수로 맵 팩토리를 받습니다. 이 인수로 EnumMap이나 TreeMap 같은 맵 구현체를 지정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;위의 세 가지 toMap 각각에 대응되는 toConcurrentMap도 존재합니다. 이들은 병렬로 실행되어 ConcurrentHashMap 인스턴스를 생성합니다.&lt;/p&gt;

&lt;h5 id=&quot;groupingby&quot;&gt;groupingBy&lt;/h5&gt;

&lt;p&gt;이 메서드는 입력으로 분류 함수를 받고 출력으로 원소들을 카테고리별로 모아 놓은 맵을 담은 수집기를 반환합니다. 분류 함수로 반환된 값이 카테고리이자 맵의 키가 됩니다. 가장 간단한 형태는 분류 함수 하나만 인수로 받는 메서드 입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,?,&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;groupingBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classifier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 수집기로 반환된 맵의 값 타입은 해당 카테고리에 속하는 모든 원소를 담은 리스트가 됩니다. 앞서 살펴봤던 아나그램의 예에서 삺펴봤던 그것입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;groupingBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alphabetize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 리스트가 아닌 다른 타입을 값으로 갖는 맵을 만들고 싶으면 분류 함수와 함께 다운스트림 수집기도 명시하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,?,&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;groupingBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classifier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;downstream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;가령 두 번째 인자에 toSet()을 넘기면 리스트가 아닌 집합을 값으로 갖는 맵이 반환됩니다. toCollection(collectionFactory)를 건네면 원하는 컬렉션 타입을 값으로 가지는 유연한 맵을 반환할 수도 있습니다. 다운스트림으로 counting()을 건네면 해당 카테고리에 속하는 원소의 개수와 맵핑된 맵을 얻게 됩니다.&lt;/p&gt;

&lt;p&gt;인수가 3개인 경우에는 다운스트림 수집기에 더해서 맵 팩토리도 지정해서 반환되는 맵의 구현체까지 지정할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,?,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;groupingBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;classifier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Supplier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;downstream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;toMap과 마찬가지로 위의 세 groupingBy에 대응되는 groupingByConcurrent 메서드들도 존재합니다. 동시수행으로 ConcurrentHashMap 인스턴스를 반환합니다.&lt;/p&gt;

&lt;p&gt;추가적으로 자주 사용되지는 않지만 groupingBy의 사촌격인 partitioningBy도 존재합니다. 분류 함수로 Predicate를 받고 키가 Boolean인 맵을 반환합니다. 여기에 더해 다운스트림 수집기까지 입력받는 다중정의도 되어있습니다.&lt;/p&gt;

&lt;h4 id=&quot;다운스트림-전용-수집기&quot;&gt;다운스트림 전용 수집기&lt;/h4&gt;

&lt;p&gt;앞서 살펴본 counting()은 다운스트림 전용 수집기 입니다. Stream의 count 메서드를 직접 이용해서 같은 기능을 수행할 수 있기 때문에 collect(counting())과 같은 형태로 쓸 일은 절대 없습니다. 이런 속성을 가지는 메서드가 16개나 더 있습니다. 그 중에서 9개는 summing, averaging, summarizing으로 시작하고 각각 int, long, double 스트림용으로 하나씩 존재합니다.&lt;/p&gt;

&lt;h4 id=&quot;collectors에-정의되어있지만-수집과는-무관한-메서드들&quot;&gt;Collectors에 정의되어있지만 수집과는 무관한 메서드들&lt;/h4&gt;

&lt;h5 id=&quot;minby-maxby&quot;&gt;minBy, maxBy&lt;/h5&gt;

&lt;p&gt;위 두 메서드는 인수로 비교자를 받아서 스트림에서 가장 작은, 혹은 큰 값을 반홚랍니다. Stream인터페이스의 min, max를 일반화하고 BinaryOperator의 minBy, maxBy 메서드가 반환하는 이진 연산자의 수집기 버전 입니다.&lt;/p&gt;

&lt;h5 id=&quot;joining&quot;&gt;joining&lt;/h5&gt;

&lt;p&gt;이 메서드는 CharSequence 인스턴스 스트림에만 적용할 수 있습니다. 매개변수가 없으면 원소들을 이어붙여주고 매개변수가 존재하면 구분자 역할을 해서 원소 사이사이에 함께 추가해서 붙여줍니다. 매개변수를 3개 넣을 수도 있는데 구분자와 더불어 접두, 접미 문자 입니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-47-반환-타입으로는-스트림보다-컬렉션이-낫다&quot;&gt;아이템 47. 반환 타입으로는 스트림보다 컬렉션이 낫다.&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;반환 타입을 스트림으로 할지, 반복(itreation)으로 할지를 정하는 것은 쉽지 않은 문제 입니다. 스트림은 반복을 지원하지 않기 때문에 스트림만 반환하게 api를 설계하면 for-each로 반복하길 원하는 클라이언트 입장에서는 불만일 것입니다. 재밌는 점은 Stream 인터페이스는 Iterable 인터페이스가 정의한 추상 메서드를 전부 포함하고 동작도 Iterable이 정의한 대로 하는데 다만 Iterable을 확장하지 않았기 때문에 for-each에 사용할 수 없는 것입니다. 이를 우회할 수 있는 방법은 어댑터를 사용하는 것입니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;iterableOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;stream:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스트림을 인자로 전달해서 스트림의 iterator를 반환하면 됩니다. 그럼 for-each문으로 반복할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ProcessHandle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterableOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ProcessHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;allProcesses&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;반대로 api가 Iterable만 반환하면 이를 스트림 파이프라인에서 처리하고자 하는 클라이언트 입장에서 불만일 것입니다. 물론 이것도 어댑터로 해결할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;streamOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StreamSupport&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;spliterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;결국 api의 사용자가 스트림이나 반복 중 하나만 사용할 것이라는 확신이 있지 않는 이상 둘을 모두 만족시키기 위해 노력해야 합니다. Collection 인터페이스는 Iterable의 하위 타입이면서 stream 메서드도 제공하기 때문에 반복과 스트림을 동시에 지원합니다. 즉, &lt;strong&gt;원소 시퀀스를 반환하는 공개 api의 반환 타입에는 Collection이나 그 하위 타입을 쓰는 것이 현 상황에서는 최선 입니다.&lt;/strong&gt;(자바가 stream에도 iterable을 지원하지 않는 현 상황에선) Arrays 또한 Arrays.asList, Stream.of를 통해 반복과 스트림을 지원하니 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;또 다른 주의점으로 반환하는 시퀀스의 크기가 크다면 표준 컬렉션 구현체인 ArrayList, HashSet 같은 것을 반환하지 않고 AbstractList 등을 이용해서 전용 컬렉션을 구현하는 것을 검토하는 것이 좋습니다. 물론 시퀀스의 크기가 메모리에 올려도 안전할 정도로 작다면 표준 구현체를 사용해도 됩니다. AbstractCollection을 활용해서 Collection 구현체를 작성할 때는 Iterable용 메서드 외에 contains, size만 더 구현하면 됩니다. 혹, 반복이 시작되기 전에 시퀀스의 내용을 확정할 수 없는 등의 이유로 contains, size를 구현하는 것이 불가능할 경우에는 스트림이나 Iterable을 반환하는 것이 더 좋습니다.&lt;/p&gt;

&lt;h2 id=&quot;아이템-48-스트림-병렬화는-주의해서-적용하라&quot;&gt;아이템 48. 스트림 병렬화는 주의해서 적용하라&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;스트림의 parallel 메서드를 호출하면 파이프라인을 병려르 실행할 수 있는 스트림을 지원합니다. 메서드 하나로 동시성 프로그램을 작성할 수 있다는 편리함이 있지만 그것이 올바르게 사용하는 것이라는 보장은 없습니다. 동시성에서는 안전성(safety)과 응답 가능 상태(liveness)를 유지해야 하는데 병렬 스트림 파이프라인 프로그래밍에서도 마찬가지 입니다. 병렬화를 할 때는 다음의 내용들을 기억합시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;데이터 소스가 Stream.iterate이거나 중간연산으로 limit을 쓰면 병렬화로 성능 개선을 할 수 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋다.
해당 자료구조들은 모두 데이터를 원하는 크기로 정확히 나눌 수 있어서 다수의 스레드에 분배하기 좋다는 특징이 있습니다. 나누는 작업은 Spliterator가 담당하고 Spliterator 객체는 Stream이나 Iterable의 spliterator 메서드로 얻어올 수 있습니다.
또 다른 중요한 점은 해당 자료구조들은 원소들을 순차적으로 실행할 때 참조 지역성이 뛰어나다는 것입니다. 이는 캐시 히트의 가능성이 높아짐을 의미하고 캐시 미스로 인한 캐시로의 데이터 이동에 드는 시간을 최소화할 수 있음을 의미합니다. 지역성이 가장 뛰어난 자료구조는 기본 타입 배열입니다. 값 자체가 배열에 연속된 공간으로 들어가기 때문입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;종단 연산에서는 축소가 병렬화에 가장 적합하다.
종단 연산에서 수행하는 작업량이 전체 작업에서 높은 비중을 차지하면서 순차적인 연산이면 병렬 수행의 효과는 제한적입니다. 가장 적합한 방식은 축소 연산을 통해서 원소를 하나로 합치는 연산 입니다. reduce메서드 중 하나나 min, max, count, sum 같이 완성된 형태로 제공되는 메서드나 anyMatch, allMatch, noneMatch처럼 조건에 맞으면 바로 반환되는 메서드도 적합합니다. 반면 collect의 경우에는 컬렉션들을 합치는 부담이 있기에 적합하지 않습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;스트림을 잘못 병렬화하면 (응답 불가를 포함해) 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.(safety failure-안전실패)
안전 실패는 스트림에 전달되는 함수가 스트림 명세에 정의해둔 엄격한 함수 객체에 대한 규약을 지키지 않으면 발생할 수 있습니다. 가령 Stream의 reduce 연산에 전달되는 accumulator(누적기)와 combiner(결합기) 함수는 반드시 결합법칙을 만족하고 간섭받지 않고(파이프라인이 수행되는 동안 데이터 소스에 변경이 발생하지 않고), 상태를 갖지 않아야 합니다. 위의 규약을 지키지 않아도 순차 수행시에는 올바른 결과를 얻을 수도 있지만 병렬로 하면 실패로 이어지기 십상입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Mun Soo Kim</name></author><category term="기술" /><category term="자바" /><summary type="html">조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.</summary></entry></feed>