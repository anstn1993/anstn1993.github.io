<!DOCTYPE html>
<!--
    Type on Strap jekyll theme v2.3.0
    Copyright 2016-2020 Sylhare
    Theme free for personal and commercial use under the MIT license
    https://github.com/sylhare/Type-on-Strap/blob/master/LICENSE
-->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!-- Main JS (navbar.js, katex_init.js and masonry_init.js)-->
    <script defer src="/assets/js/main.min.js"></script>
    
    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <!--Favicon-->
    <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

    <!-- RSS -->
    <link rel="alternate" type="application/atom+xml" title="MunSooKim's devlog" href="https://anstn1993.github.io/feed.xml"/>
    
    

    <!-- KaTeX 0.12.0 -->
    
    <script defer src="/assets/js/vendor/katex.min.js"></script>
    <script defer src="/assets/js/vendor/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
    

    <!-- Mermaid 8.8.2 -->
    
    <!-- <script src=”https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.8.2/mermaid.min.js" onload="mermaid.initialize({startOnLoad:true});"></script> -->
    <script defer src="/assets/js/vendor/mermaid.min.js" onload="mermaid.initialize({startOnLoad:true});"></script>
    

    <!-- Simple-Jekyll-Search 1.17.12 -->
    <script src="/assets/js/vendor/simple-jekyll-search.min.js" type="text/javascript"></script>

    <!-- Google Analytics / Cookie Consent -->
    <script>
      const cookieName = 'cookie-notice-dismissed-https://anstn1993.github.io';
      const isCookieConsent = 'false';
      const analyticsName = '';
    </script>

    
    

    <!-- seo tags -->
    <meta property="og:image" content="https://anstn1993.github.io/assets/img/pexels/triangular.jpeg">
    
    <meta property="og:type" content="website" />
    
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>이펙티브자바 - 7장. 람다와 스트림 | MunSooKim’s devlog</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="이펙티브자바 - 7장. 람다와 스트림" />
<meta name="author" content="Mun Soo Kim" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다." />
<meta property="og:description" content="조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다." />
<link rel="canonical" href="https://anstn1993.github.io/2021/07/14/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-7%EC%9E%A5.html" />
<meta property="og:url" content="https://anstn1993.github.io/2021/07/14/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-7%EC%9E%A5.html" />
<meta property="og:site_name" content="MunSooKim’s devlog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-14T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="이펙티브자바 - 7장. 람다와 스트림" />
<script type="application/ld+json">
{"description":"조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.","mainEntityOfPage":{"@type":"WebPage","@id":"https://anstn1993.github.io/2021/07/14/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-7%EC%9E%A5.html"},"datePublished":"2021-07-14T00:00:00+09:00","url":"https://anstn1993.github.io/2021/07/14/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-7%EC%9E%A5.html","author":{"@type":"Person","name":"Mun Soo Kim"},"headline":"이펙티브자바 - 7장. 람다와 스트림","@type":"BlogPosting","dateModified":"2021-07-14T00:00:00+09:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <!-- RSS -->
    <link type="application/atom+xml" rel="alternate" href="https://anstn1993.github.io/feed.xml" title="MunSooKim&apos;s devlog" />

    <!-- Twitter Cards -->
    <meta name="twitter:title" content="이펙티브자바 - 7장. 람다와 스트림">
    <meta name="twitter:description" content="조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.7장. 람다와 스트림자바 8부터 추가되기 시작한 함수형 인터페이스, 람다, 메서드 참조 개념과 더불어 스트림 API가 추가되었습니다. 이들에 대해서 살펴보겠습니다.아이템 42. 익명 클래스보다는 람다를...">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:image" content="https://anstn1993.github.io/assets/img/pexels/triangular.jpeg">
    <meta name="twitter:image:alt" content="이펙티브자바 - 7장. 람다와 스트림">
</head>

  <body>
    <header class="site-header">

    <!-- Logo and title -->
	<div class="branding">
        
		<a href="/">
			<img alt="logo img" class="avatar" src="/assets/img/triangle.png" />
		</a>
        
        <a class="site-title" aria-label="MunSooKim's devlog" href="/">
        MunSooKim's devlog
		</a>
	</div>

    <!-- Toggle menu -->
    <nav class="clear">
    <a aria-label="pull" id="pull" class="toggle" href="#">
    <i class="fa fa-bars fa-lg"></i>
    </a>

    <!-- Menu -->
    <ul class="hide">
        

        
            
            
        
            
            <li class="separator"> | </li>
            <li>
                <a class="clear" aria-label="About" title="About" href="/about">
                     About 
                </a>
            </li>
            
            
        
            
            
        
            
            
        
            
            
        
            
            <li class="separator"> | </li>
            <li>
                <a class="clear" aria-label="Search" title="Search" href="/search">
                     <i class="fa fa-search" aria-hidden="true"></i>
                    
                </a>
            </li>
            
            
        
            
            <li class="separator"> | </li>
            <li>
                <a class="clear" aria-label="Tags" title="Tags" href="/tags">
                     <i class="fa fa-tags" aria-hidden="true"></i>
                    
                </a>
            </li>
            
            
        
            
            
        
            
            
        
            
            
        
    </ul>

	</nav>
</header>

    <div class="content">
      <article class="feature-image" >
  <header id="main" style="">
    <div class="title-padder">
      
      <h1 id="%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94+-+7%EC%9E%A5.+%EB%9E%8C%EB%8B%A4%EC%99%80+%EC%8A%A4%ED%8A%B8%EB%A6%BC" class="title">이펙티브자바 - 7장. 람다와 스트림</h1>
      


<div class="post-info">
    <p class="meta">
      July 14, 2021
    </p></div>

      
    </div>
  </header>

  <section class="post-content">
  
      <p>조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.</p>

<h1 id="7장-람다와-스트림">7장. 람다와 스트림</h1>

<p>자바 8부터 추가되기 시작한 함수형 인터페이스, 람다, 메서드 참조 개념과 더불어 스트림 API가 추가되었습니다. 이들에 대해서 살펴보겠습니다.</p>

<h2 id="아이템-42-익명-클래스보다는-람다를-사용하라">아이템 42. 익명 클래스보다는 람다를 사용하라</h2>

<hr />

<p>자바 8이 등장하기 전에는 자바에서 함수 타입을 표현하기 위해서 추상 메서드를 딱 하나만 가지는 인터페이스(드물게 추상 클래스)를 사용했습니다. 이런 인터페이스를 인스턴스화하면 그것을 함수 객체라고 불렀고 주로 익명 클래스로 생성을 했습니다. 하지만 익명 클래스는 코드가 너무 길어지는 문제가 있었고 이는 함수형 프로그래밍에 적합하지 않았습니다.</p>

<p>그래서 자바 8부터는 위와 같은 추상 메서드 하나만 가지는 인터페이스에 특별한 의미를 부여하여 <strong>함수형 인터페이스</strong>라는 명칭을 부여하고 함수형 인터페이스는 람다식으로 표현이 가능하게 되었습니다. 람다의 대부분의 경우 매개변수, 반환 타입은 컴파일러가 문맥을 살펴 타입 추론을 해줍니다. 만약 타입을 결정하지 못하는 경우에는 프로그래머가 직접 명시를 해주면 됩니다. 이와 관련해서 제네릭의 사용이 중요합니다. 제네릭은 컴파일러의 타입을 추론하는 데 필요한 타입 정보를 제공하기에 제네릭을 사용해야 컴파일러가 람다의 타입을 추론할 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 익명 클래스로 표현한 함수 객체</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">words</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">});</span>

<span class="c1">// 람다로 표현한 함수 객체</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">words</span><span class="o">,</span> <span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">()));</span>

<span class="c1">// 비교자 생성 정적 메서드를 이용해서 더 간결하게 표현 가능</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">words</span><span class="o">,</span> <span class="n">comparingInt</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">length</span><span class="o">));</span>
</code></pre></div></div>

<p>위와 같이 람다를 써서 코드가 매우 간결해져서 함수 객체를 실용적으로 쓸 수 있게 됐습니다. 아이템 34의 Operation 열거 타입의 코드를 생각해보면, apply 메서드의 동작이 상수마다 달라야 해서 상수별로 apply 메서드를 재정의했습니다. 그런데 람다를 이용하면 함수 객체를 필드로 두고 생성자로 람다를 넘기면 됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">Operation</span> <span class="o">{</span>
  <span class="no">PLUS</span><span class="o">(</span><span class="s">"+"</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">),</span>
  <span class="no">MINUS</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">),</span>
  <span class="no">TIMES</span><span class="o">(</span><span class="s">"*"</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">),</span>
  <span class="no">DIVIDE</span><span class="o">(</span><span class="s">"/"</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="o">);</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">symbol</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">DoubleBinaryOperator</span> <span class="n">op</span><span class="o">;</span>

  <span class="nc">Operation</span><span class="o">(</span><span class="nc">String</span> <span class="n">symbol</span><span class="o">,</span> <span class="nc">DoubleBinaryOperator</span> <span class="n">op</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">symbol</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">op</span> <span class="o">=</span> <span class="n">op</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">double</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="na">applyAsDouble</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>DoubleBinaryOperator는 java.util.function 패키지가 제공하는 표준 함수형 인터페이스 중 하나입니다. double 타입 인수 2개를 받아서 double 타입을 반환합니다. 이렇게 보면 Operation에서는 더 이상 상수 인스턴스별로 클래스 몸체를 사용할 이유가 없다고 느낄 수 있지만 꼭 그렇지는 않습니다. 메서드나 클래스와 달리 람다는 이름을 가지지 않고 문서화를 하지 못 합니다. 그래서 <strong>코드 자체로 동작이 명확하게 설명되지 않거나 코드 줄 수가 많아지만 람다를 쓰면 안 됩니다.</strong> 람다는 한 줄로 표현 가능할 때 가장 좋고 아무리 길어도 3을 넘지 않는 게 좋습니다. 또한 <strong>생성자 안의 람다는 열거 타입의 인스턴스 멤버에 접근할 수 없습니다.</strong> 인스턴스가 런타임에 만들어지기 때문 입니다. 그러니 위의 두 경우에는 상수별 클래스 몸체를 사용해서 메서드를 구현하는 것이 좋습니다.</p>

<p>마지막으로 람다가 대체할 수 없는 케이스를 살펴보겠습니다.</p>

<ul>
  <li>추상 클래스의 인스턴스를 만들 때는 람다를 사용할 수 없고 익명 클래스를 써야만 한다.</li>
  <li>추상 메서드가 여러 개인 인터페이스의 인스턴스도 무조건 익명 클래스를 써야 한다.</li>
  <li>람다는 자신을 참조할 수 없기 때문에 함수 객체가 자기 자신을 참조할 일이 있다면 무조건 익명 클래스를 써야 한다.
람다의 this 키워드는 바깥 인스턴스를 가리키지만, 익명 클래스의 this는 자기 자신을 가리킵니다.</li>
</ul>

<h2 id="아이템-43-람다보다는-메서드-참조를-사용하라">아이템 43. 람다보다는 메서드 참조를 사용하라</h2>

<hr />

<p>이전 아이템에서 람다가 익명 클래스보다 훨씬 간결하게 함수 객체를 표현하는 것을 봤습니다. 그런데 <strong>매서드 참조</strong>를 이용하면 람다보다도 더 간결하게 함수 객체를 만들 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="n">count</span><span class="o">,</span> <span class="n">incr</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">count</span> <span class="o">+</span> <span class="n">incr</span><span class="o">);</span>
</code></pre></div></div>

<p>자바 8에서 Map에 추가된 merge 메서드 입니다. 매개변수로는 키, 값, 함수를 받으며, 전달된 키가 맵 안에 없으면 전달된 키, 값을 맵에 추가합니다. 키가 맵 안에 있다면 그 키의 현재 값과 매개변수로 전달된 값을 세 번째 매개변수인 함수의 인자로 전달해서 연산을 한 결과 값을 현재 키의 값으로 덮어쓰게 됩니다. 람다를 통해 충분히 간결하지만 count, incr는 단순히 합해져서 반환되기 때문에 이런 더하기 연산을 해서 반환해주는 람다와 같은 기능을 제공하는 박싱 클래스의 정적 메서드 sum을 자바 8부터 제공해줍니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nl">Ingeter:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
</code></pre></div></div>

<p>그래서 위처럼 메서드 참조를 전달해서 더 간단하게 표현 가능합니다. 단 때론 람다의 매개변수 이름이 프로그래머에게 정보를 제공하는 경우도 있기 때문에 그런 경우에는 람다를 유지하는 게 더 좋을 수 있습니다. 또한 람다가 메서드 참조보다 간결할 때가 있습니다. 바로 메서드와 람다가 같은 클래스에 있을 때입니다. 다음의 코드가 GoshThisClassNameIsHumongous 클래스 안에 있다고 해보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">service</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="nl">GoshThisClassNameIsHumongous:</span><span class="o">:</span><span class="n">action</span><span class="o">);</span>
</code></pre></div></div>

<p>이를 람다로 대체하면 다음과 같습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">service</span><span class="o">.</span><span class="na">execute</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">action</span><span class="o">());</span>
</code></pre></div></div>

<p>이처럼 같은 클래스 내부의 메서드를 호출할 일이 있으면 차라리 람다가 더 간결합니다. 같은 맥락으로 java.util.function패키지가 제공하는 제네릭 정적 팩터리 메서드인 Function.identity()를 사용하는 것보다는 똑같은 기능을 하는 (x -&gt; x)를 사용하는 것이 더 짧으면서도 명확합니다.</p>

<h3 id="5개의-메서드-참조-유형">5개의 메서드 참조 유형</h3>

<p>메서드 참조는 5개의 유형을 가집니다.</p>

<ul>
  <li>
    <p>정적 메서드 참조
앞서 살펴본 유형입니다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">str</span> <span class="o">-&gt;</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">str</span><span class="o">)</span>
  <span class="nl">Integer:</span><span class="o">:</span><span class="n">parseInt</span>
</code></pre></div>    </div>

    <p>위의 두 표현식은 같습니다.</p>
  </li>
  <li>
    <p>한정적 (인스턴스) 메서드 참조
참조 대상 인스턴스(수신 객체)를 특정하는 메서드 참조 입니다. 이 참조는 근본적으로 정적 참조와 비슷합니다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">Instant</span> <span class="n">then</span> <span class="o">=</span> <span class="nc">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
  <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">then</span><span class="o">.</span><span class="na">isAfter</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>

  <span class="nc">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">()::</span><span class="n">isAfter</span>
</code></pre></div>    </div>

    <p>위의 두 표현식은 같습니다.</p>
  </li>
  <li>
    <p>비한정적 (인스턴스) 메서드 참조
참조 대상 인스턴스(수신 객체)를 특정하지 않는 메서드 참조 입니다. 이 참조의 경우 함수 객체를 적용하는 시점에 수신 객체를 알려주게 됩니다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">str</span> <span class="o">-&gt;</span> <span class="n">str</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">()</span>
  <span class="nl">String:</span><span class="o">:</span><span class="n">toLowerCase</span><span class="o">()</span>
</code></pre></div>    </div>

    <p>위의 두 표현식은 같습니다.</p>
  </li>
  <li>
    <p>클래스 생성자</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;();</span>
  <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="no">L</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;::</span><span class="k">new</span>
</code></pre></div>    </div>

    <p>위의 두 표현식은 같습니다.</p>
  </li>
  <li>
    <p>배열 생성자</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">(</span><span class="n">len</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">len</span><span class="o">];</span>
  <span class="kt">int</span><span class="o">[]::</span><span class="k">new</span>
</code></pre></div>    </div>
    <p>위의 두 표현식은 같습니다.</p>
  </li>
</ul>

<h2 id="아이템-44-표준-함수형-인터페이스를-사용하라">아이템 44. 표준 함수형 인터페이스를 사용하라</h2>

<hr />

<p>자바가 람다를 지원하면서 동시에 java.util.functoin 패키지에 다양한 용도의 표준 함수형 인터페이스를 제공하기 시작했습니다. 기존에는 이를 직접 생성해서 사용했다면 이제는 용도에 맞는 표준 함수형 인터페이스를 사용하는 것이 좋을 겁니다. 그렇게 해야 코드들의 통일성이 높아지고 코드별로 익혀야 하는 개념들이 줄어들고, 다른 코드들과의 상호 운용성도 좋아질 것입니다.</p>

<h4 id="6개의-표준-함수형-인터페이스">6개의 표준 함수형 인터페이스</h4>

<p>java.util.function 패키지에는 43개의 인터페이스가 담겨 있지만, 기본 인터페이스 6개만 잘 익혀두면 나머지는 유추할 수 있습니다. 먼저 이 기본 인터페이스들은 모두 참조 타입용입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">interface</span> <span class="nc">UnaryOperator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span> <span class="nf">apply</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">interface</span> <span class="nc">BinaryOperator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span> <span class="nf">apply</span><span class="o">(</span><span class="no">T</span> <span class="n">t1</span><span class="o">,</span> <span class="no">T</span> <span class="n">t2</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">interface</span> <span class="nc">Predicate</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">test</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">interface</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">R</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">R</span> <span class="nf">apply</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">interface</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span> <span class="nf">get</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">interface</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>먼저 Operator는 입력 인수와 반환 인수가 같은 함수를 의미합니다. Unary와 Binary의 차이는 입력 인수의 개수로 각각 1개, 2개를 받습니다. 각각 String::toLowerCase, BigInteger::add가 대표적입니다. Predicate는 인수 하나를 받아서 boolean을 반환하는 함수를 의미합니다. Collection::isEmpty가 대표적입니다. Function 인터페이스는 인수와 반환 타입이 다른 함수를 의미합니다. Arrays.asList가 대표적입니다. Supplier는 인수는 받지 않고 반환하는 함수, Consumer는 인수는 받고 반환하지 않는 함수입니다. 각각 Instant::now, System.out::println가 대표적입니다.</p>

<p>위의 6개에서 특정 키워드가 붙으면서 가지수가 늘어나는 겁니다. 예를 들면 참조 타입이 아닌 기본 타입인 int, long, double용으로 3개의 변형이 생깁니다. 기본 인터페이스의 이름 앞에 기본 타입을 붙이면 됩니다. 예를 들면, int를 받는 Predicate의 경우 IntPredicate가 됩니다. 이 변형들 중에 Function은 좀 예외적으로 입력 타입은 똑같이 인터페이스 이름 앞에 붙이고 반환 타입은 매개변수화하여 지정합니다. long인수를 받아서 int[]를 반환하는 Function의 경우 LongFunction&lt;int[]&gt;이 됩니다.</p>

<p>추가적으로 Function은 기본타입을 반환하는 변형이 9개 존재합니다. 입력과 결과 타입이 모두 기본형이면 접두어로 SrcToResult를 사용합니다. long을 받아서 int를 반환하면 LongToIntFunction이 됩니다.(6개) 나머지는 입력이 객체 참조고 결과가 int, long, double인 경우로 접두어로 ToResult를 사용합니다. 즉, ToLongFunction&lt;int[]&gt;는 int[] 인수를 받아서 long을 반환합니다.(3개)</p>

<p>기본 함수형 인터페이스 중 3개는 인수를 2개씩 받는 변형이 있습니다. BiPredicate&lt;T, U&gt;, BiFunction&lt;T, U, R&gt;, BiConsumer&lt;T, U&gt;가 그 주인공인데, BiFunction에는 다시 기본 타입을 반환하는 세 개의 변형인 ToIntBiFunction&lt;T, U&gt;, ToLongBiFunction&lt;T, U&gt;, ToDoubleBiFunction&lt;T, U&gt;가 있습니다. Consumer에도 객체 참조와 기본 타입 하나, 즉 인수 2개를 받는 변형인 ObjDoubleConsumer&#60;T&#62;, ObjIntConsumer&#60;T&#62;, ObjLongConsumer&#60;T&#62;이 존재합니다. 이렇게 기본 인터페이스의 인수 2개짜리 변형은 총 9개 입니다.</p>

<p>마지막으로 BooleanSupplier는 boolean을 반환하도록 한 Supplier의 파생입니다.</p>

<p>표준 함수형 인터페이스는 이처럼 대부분 기본 타입만 지원합니다. 그런데 여기에 박싱된 타입을 넣어서 사용하는 것은 지양해야 합니다. 동작하긴 하지만 계산량이 많을 때는 성능저하가 심해질 수 있습니다.</p>

<h4 id="인터페이스를-직접-작성해야-하는-순간">인터페이스를 직접 작성해야 하는 순간?</h4>

<p>대부분 표준 함수형 인터페이스를 쓸 수 있으면 쓰는 것이 좋지만 직접 작성해야 하는 순간도 있습니다. 당연한 말이지만 표준 인터페이스 중 적합한 용도가 없다면 직접 작성해야 합니다. 그런데 존재하더라도 직접 작성해야하는 경우가 있습니다. 가장 대표적인 예가 Comparator&#60;T&#62;입니다. Comparator는 ToIntBiFunction&lt;T, U&gt;와 동일한데도 독자적인 인터페이스로 존재합니다. 그 이유는 다음과 같습니다.</p>

<ul>
  <li>매우 자주 사용되며 이름 자체가 용도를 아주 훌륭하게 표현해준다.</li>
  <li>구현하는 쪽에서 반드시 지켜야 하는 규약을 담는다.</li>
  <li>비교자들을 변환, 조합해주는 유용한 디폴트 메서드들이 많이 있다.</li>
</ul>

<p>만약, 위의 조건 중에 하나라도 해당하는 경우라면 직접 함수형 인터페이스를 작성하는 것을 고민해보는 것이 좋습니다.</p>

<h4 id="함수형-인터페이스를-직접-작성할-때는-functionalinterface를-쓰자">함수형 인터페이스를 직접 작성할 때는 @FunctionalInterface를 쓰자</h4>

<p>함수형 인터페이스를 직접 작성할 때는 @FunctionalInterface 애너테이션을 사용하는 것이 좋습니다. 그 이유는 @Override를 사용하는 것과 비슷합니다. 우선 정보를 제공하는 용도입니다. 해당 인터페이스가 람다용으로 설계된 것임을 알릴 수 있습니다. 더 중요한 것은 이 애너테이션이 붙어있으면 추상 메서드를 딱 하나만 가질 때 컴파일이 되기 때문에 추후에 누가 메서드를 추가하는 등의 실수를 막아줍니다.</p>

<h4 id="api에서-함수형-인터페이스를-사용할-때의-주의점">API에서 함수형 인터페이스를 사용할 때의 주의점</h4>

<p>서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들은 다중정의하면 안 됩니다. 클라이언트에게 모호함만 안겨주고 실제 문제로 이어질 수 있습니다. ExecutorService의 submit 메서드는 Callable&#60;T&#62;를 받는 것과 Runnable을 받는 것을 다중정의해서 올바른 메서드를 알려주기 위해서 형변환을 해야 할 경우가 생깁니다.</p>

<h2 id="아이템-45-스트림은-주의해서-사용하라">아이템 45. 스트림은 주의해서 사용하라</h2>

<hr />

<p>스트림 api는 다량의 데이터 원소를 원하는 방식으로 처리해줍니다. 이 api는 두 가지의 추상 개념을 가집니다.</p>

<ul>
  <li>스트림은 데이터 원소의 유한 혹은 무한 시퀀스를 뜻한다.</li>
  <li>스트림 파이프라인은 이 원소들로 수행하는 연산의 단계를 의미한다.</li>
</ul>

<h4 id="스트림-api의-기본-개념">스트림 api의 기본 개념</h4>

<p>스트림 원소의 원천은 컬렉션, 배열, 파일, 혹은 다른 스트림 등 무엇이든지 될 수 있습니다. 그리고 원소는 참조타입과 기본타입(int, long, double)을 지원합니다.</p>

<p>스트림 파이프라인은 소스 스트림(원소의 원천)에서 시작해서 원한다면 하나 이상의 중간 연산을 거쳐서 종단 연산으로 끝이 납니다. 각각의 중간 연산에서 소스 스트림의 원소에 어떤 함수를 적용하거나 원소를 걸러내는 등 다양한 작업을 할 수 있습니다. 그리고 종단 연산에서는 컬렉션에 원소를 담거나 하나의 원소를 선택하는 등의 작업을 할 수 있습니다.</p>

<p>스트림 파이프라인은 지연 평가됩니다. 종단 연산이 이루어지기 전까지는 평가가 이루어지지 않으며 종단 연산에 쓰이지 않는 원소는 계산에서 제외되기 때문에 효율적입니다. 이 말은 종단 연산을 빼면 중간 연산은 일어나지 않는다는 것이니 종단 연산으로 꼭 마무리를 해줘야 합니다.</p>

<h4 id="스트림-api를-잘-활용하기">스트림 api를 잘 활용하기</h4>

<p>사전 파일에서 단어를 읽어서 사용자가 지정한 문턱값보다 원소 수가 많은 아나그램(철자를 구성하는 알파벳이 같고 순서만 다른 단어) 그룹을 출력하는 코드를 보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Anagrams</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="nc">File</span> <span class="n">dictionary</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="kt">int</span> <span class="n">minGroupSize</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>

    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">groups</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="k">try</span> <span class="o">(</span><span class="nc">Scanner</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="n">dictionary</span><span class="o">))</span> <span class="o">{</span>
      <span class="k">while</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">word</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="n">groups</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">alphabetize</span><span class="o">(</span><span class="n">word</span><span class="o">),</span> <span class="o">(</span><span class="n">unused</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">TreeSet</span><span class="o">&lt;&gt;()).</span><span class="na">add</span><span class="o">(</span><span class="n">word</span><span class="o">));</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">for</span> <span class="o">(</span><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">group</span> <span class="o">:</span> <span class="n">groups</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">group</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">minGroupSize</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">group</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">group</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">alphabetize</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위의 코드를 스트림을 이용하면 아래와 같이 간결하게 표현할 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Anagrams</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="nc">Path</span> <span class="n">dictionary</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="kt">int</span> <span class="n">minGroupSize</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>

    <span class="k">try</span> <span class="o">(</span><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">lines</span><span class="o">(</span><span class="n">dictionary</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">words</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">groupingBy</span><span class="o">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="n">alphabetize</span><span class="o">(</span><span class="n">word</span><span class="o">)))</span> <span class="c1">// 영단어를 키로 하는 맵 생성</span>
      <span class="o">.</span><span class="na">values</span><span class="o">().</span><span class="na">stream</span><span class="o">()</span> <span class="c1">// Stream&lt;List&lt;String&gt;&gt; 생성</span>
      <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">group</span> <span class="o">-&gt;</span> <span class="n">group</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">minGroupSize</span><span class="o">)</span> <span class="c1">// 문턱값보다 큰 리스트만 남김</span>
      <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">group</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">group</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">group</span><span class="o">));</span><span class="c1">// 필터링에서 살아남은 리스트만 출력</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="c1">// alphabetize 코드는 동일</span>
<span class="o">}</span>
</code></pre></div></div>

<p>alphabetize도 스트림으로 구현할 수 있지만 자바는 char용 스트림을 지원하지 않기 때문에 char 값들을 처리할 때는 스트림을 사용하지 않는 것이 좋습니다.</p>

<p>스트림이 아무리 간결해보이더라도 무조건 반복문을 스트림으로 바꾸는 것이 능사는 아닙니다. 오히려 스트림만 고집하면 가독성, 유지보수성이 떨어질 수 있으니 스트림과 반복문을 적절히 조합하는 것이 가장 좋습니다. 뿐만 아니라 스트림이 반복문을 모두 대체할 수 있는 것도 아닙니다.</p>

<ul>
  <li>람다는 final인 변수만 읽을 수 있기 때문에 지역변수는 읽을 수 없다. 즉 반복문만이 지역변수에 접근할 수 있다.</li>
  <li>람다에서는 return, break, continue를 이용해서 반복 제어를 할 수 없다.</li>
</ul>

<p>함수객체(람다)를 인자로 전달하는 스트림에서 위의 로직이 필요하다면 반복문을 사용할 수밖에 없습니다. 반대로 다음은 스트림을 쓰기에 아주 좋은 경우들 입니다.</p>

<ul>
  <li>원소들의 시퀀스를 일관되게 변환한다.</li>
  <li>원소들의 시퀀스를 필터링한다.</li>
  <li>원소들의 시퀀스를 하나의 연산을 사용해 결합한다.(더하기, 연결하기, 최솟값 구하기 등)</li>
  <li>원소들의 시퀀스를 컬렉션에 모은다.(아마도 공통된 속성을 기준으로 묶어가며)</li>
  <li>원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.</li>
</ul>

<h2 id="아이템-46-스트림에서는-부작용-없는-함수를-사용하라">아이템 46. 스트림에서는 부작용 없는 함수를 사용하라</h2>

<hr />

<p>스트림 api 패러다임의 핵심은 연산들 간의 독립성입니다. 각 연산을 통한 변환 단계는 이전 단계의 결과를 받아서 처리하는 <strong>순수함수</strong>입니다. 즉 스트림 연산에 전달되는 함수 객체는 부작용이 없어야 합니다. 즉 함수가 외부의 상태를 변경하지 않아야 한다는 것입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="n">freq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="n">file</span><span class="o">).</span><span class="na">tokens</span><span class="o">())</span> <span class="o">{</span>
  <span class="n">words</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">freq</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">(),</span> <span class="mi">1L</span><span class="o">,</span> <span class="nl">Long:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
  <span class="o">})</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위의 코드는 단어별 수를 카운트해서 빈도표를 만듭니다. 스트림, 람다, 메서드 참조를 사용했고 결과도 올바르지만 스트림 코드를 가장한 반복문 코드입니다. 왜냐하면 이 코드의 모든 작업이 종단 연산인 forEach에서 일어나는데 여기서 만약 외부 상태(빈도표)를 수정하는 람다를 실행하면 문제가 생깁니다ㅣ. forEach에서 스트림의 수행 결과를 출력하는 것 이상의 일을 하면 나쁜 코드는 아닌지 의심해봐야 합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="n">freq</span><span class="o">;</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="n">file</span><span class="o">).</span><span class="na">tokens</span><span class="o">())</span> <span class="o">{</span>
  <span class="n">freq</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">groupingBy</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">toLowerCase</span><span class="o">,</span> <span class="n">counting</span><span class="o">()));</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위와 같이 작성하는 것이 스트림을 제대로 활용한 것입니다. <strong>forEach 종산 연산은 종단 연산 중 기능이 가장 적고 덜 스트림답기 때문에 계산 결과를 보고할 때만 사용하고 계산하는 용도로 사용하지 않는 것이 좋습니다.</strong> 다시 코드로 돌아가서 수집기(collector)를 사용하고 있는데 수집기를 통해서 스트림 원소를 컬렉션으로 모을 수 있습니다. 수집기는 총 3가지가 있는데 toList(), toSet(), toCollection(collectionFactory) 입니다.</p>

<p>그럼 위에서 생성한 빈도표에서 가장 빈도수가 높은 10개의 단어를 뽑아내보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">topTen</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="na">keySet</span><span class="o">().</span><span class="na">stream</span><span class="o">().</span><span class="na">sorted</span><span class="o">(</span><span class="n">comparing</span><span class="o">(</span><span class="nl">freq:</span><span class="o">:</span><span class="n">get</span><span class="o">).</span><span class="na">reversed</span><span class="o">())</span>
<span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">toList</span><span class="o">());</span>
</code></pre></div></div>

<p>sorted에는 비교자를 넣어줘서 정렬이 되게 하고 reversed를 통해서 빈도가 높은 단어가 위로 가게 역순 정렬을 했습니다.</p>

<h4 id="collectors의-다양한-메서드들">Collectors의 다양한 메서드들</h4>

<p>java.util.stream.Collectors 클래스는 메서드를 총 39개 가지고 있습니다. 그 중 대부분은 스트림을 맵으로 취합하는 기능입니다. 스트림의 각 원소는 키 하나와 값 하나에 연관되어 있습니다. 그리고 다수의 원소가 같은 키에 연관될 수 있습니다.</p>

<h5 id="tomap">toMap</h5>

<p>가장 간단한 맵 수집기는 toMap(keyMapper, valueMapper)로 원소를 키에 맵핑하는 함수, 값에 맵핑하는 함수를 인수로 받습니다. 이 toMap은 각 원소가 고유한 키에 맵핑될 때 사용해야 합니다. 다수의 원소가 같은 키를 사용하면 파이프라인이 IllegalStateException을 던지면서 종료됩니다. 이외에도 더 복잡한 toMap, groupingBy는 이런 충돌을 다루는 전략들을 제공합니다. 가령, toMap에는 키, 값 매퍼 함수 뿐만 아니라 merge(병합) 함수까지 전달할 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">,</span><span class="no">K</span><span class="o">,</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">Collector</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,?,</span><span class="nc">Map</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">U</span><span class="o">&gt;&gt;</span> <span class="nf">toMap</span><span class="o">(</span><span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">&gt;</span> <span class="n">keyMapper</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,?</span> <span class="kd">extends</span> <span class="no">U</span><span class="o">&gt;</span> <span class="n">valueMapper</span><span class="o">,</span> <span class="nc">BinaryOperator</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="n">mergeFunction</span><span class="o">)</span>
</code></pre></div></div>

<p>병합 함수의 형태는 BinaryOpeerator&#60;U&#62;이고 U는 해당 맵의 값 타입이 됩니다. 같은 키를 공유하는 원소들은 모두 이 병합 함수를 통해서 기존 값에 합쳐집니다. 만약 병합 함수가 곱셈이면 키가 같은 모든 값을 곱한 결과를 얻게 됩니다. 이 toMap을 이용해서 키와 그 키에 연관된 원소들 중 하나만 골라서 값으로 삼는 맵을 만들 수도 있습니다. 다양한 음악가의 앨범들을 담은 스트림으로 음악가와 그 음악가의 베스트 앨범을 연관 지어보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Artist</span><span class="o">,</span> <span class="nc">Album</span><span class="o">&gt;</span> <span class="n">topHits</span> <span class="o">=</span> <span class="n">albums</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">toMap</span><span class="o">(</span><span class="nl">Album:</span><span class="o">:</span><span class="n">artist</span><span class="o">,</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">,</span> <span class="n">maxBy</span><span class="o">(</span><span class="n">comparing</span><span class="o">(</span><span class="nl">Album:</span><span class="o">:</span><span class="n">sales</span><span class="o">))));</span>
</code></pre></div></div>

<p>maxBy는 BinaryOperator의 정적 팩토리 메서드 입니다. Comparator&#60;T&#62;를 입력받아서 BinaryOperator&#60;T&#62;를 돌려줍니다.</p>

<p>다음과 같이 값이 충돌하면 마지막 값을 취하는 수집기를 만들 수도 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">toMap</span><span class="o">(</span><span class="n">keyMapper</span><span class="o">,</span> <span class="n">valueMapper</span><span class="o">,</span> <span class="o">(</span><span class="n">oldVal</span><span class="o">,</span> <span class="n">newVal</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">newVal</span><span class="o">)</span>
</code></pre></div></div>

<p>마지막으로 인수를 4개 받는 toMap입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">,</span><span class="no">K</span><span class="o">,</span><span class="no">U</span><span class="o">,</span><span class="no">M</span> <span class="kd">extends</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">U</span><span class="o">&gt;&gt;</span> <span class="nc">Collector</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,?,</span><span class="no">M</span><span class="o">&gt;</span> <span class="nf">toMap</span><span class="o">(</span><span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">&gt;</span> <span class="n">keyMapper</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,?</span> <span class="kd">extends</span> <span class="no">U</span><span class="o">&gt;</span> <span class="n">valueMapper</span><span class="o">,</span> <span class="nc">BinaryOperator</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="n">mergeFunction</span><span class="o">,</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">M</span><span class="o">&gt;</span> <span class="n">mapSupplier</span><span class="o">)</span>
</code></pre></div></div>

<p>네 번째 인수로 맵 팩토리를 받습니다. 이 인수로 EnumMap이나 TreeMap 같은 맵 구현체를 지정할 수 있습니다.</p>

<p>위의 세 가지 toMap 각각에 대응되는 toConcurrentMap도 존재합니다. 이들은 병렬로 실행되어 ConcurrentHashMap 인스턴스를 생성합니다.</p>

<h5 id="groupingby">groupingBy</h5>

<p>이 메서드는 입력으로 분류 함수를 받고 출력으로 원소들을 카테고리별로 모아 놓은 맵을 담은 수집기를 반환합니다. 분류 함수로 반환된 값이 카테고리이자 맵의 키가 됩니다. 가장 간단한 형태는 분류 함수 하나만 인수로 받는 메서드 입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">,</span><span class="no">K</span><span class="o">&gt;</span> <span class="nc">Collector</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,?,</span><span class="nc">Map</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;&gt;</span> <span class="nf">groupingBy</span><span class="o">(</span><span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">&gt;</span> <span class="n">classifier</span><span class="o">)</span>
</code></pre></div></div>

<p>이 수집기로 반환된 맵의 값 타입은 해당 카테고리에 속하는 모든 원소를 담은 리스트가 됩니다. 앞서 살펴봤던 아나그램의 예에서 삺펴봤던 그것입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">words</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">groupingBy</span><span class="o">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="n">alphabetize</span><span class="o">(</span><span class="n">word</span><span class="o">)))</span>
</code></pre></div></div>

<p>만약 리스트가 아닌 다른 타입을 값으로 갖는 맵을 만들고 싶으면 분류 함수와 함께 다운스트림 수집기도 명시하면 됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">,</span><span class="no">K</span><span class="o">,</span><span class="no">A</span><span class="o">,</span><span class="no">D</span><span class="o">&gt;</span> <span class="nc">Collector</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,?,</span><span class="nc">Map</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">D</span><span class="o">&gt;&gt;</span> <span class="nf">groupingBy</span><span class="o">(</span><span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">&gt;</span> <span class="n">classifier</span><span class="o">,</span> <span class="nc">Collector</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,</span><span class="no">A</span><span class="o">,</span><span class="no">D</span><span class="o">&gt;</span> <span class="n">downstream</span><span class="o">)</span>
</code></pre></div></div>

<p>가령 두 번째 인자에 toSet()을 넘기면 리스트가 아닌 집합을 값으로 갖는 맵이 반환됩니다. toCollection(collectionFactory)를 건네면 원하는 컬렉션 타입을 값으로 가지는 유연한 맵을 반환할 수도 있습니다. 다운스트림으로 counting()을 건네면 해당 카테고리에 속하는 원소의 개수와 맵핑된 맵을 얻게 됩니다.</p>

<p>인수가 3개인 경우에는 다운스트림 수집기에 더해서 맵 팩토리도 지정해서 반환되는 맵의 구현체까지 지정할 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">,</span><span class="no">K</span><span class="o">,</span><span class="no">D</span><span class="o">,</span><span class="no">A</span><span class="o">,</span><span class="no">M</span> <span class="kd">extends</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">D</span><span class="o">&gt;&gt;</span> <span class="nc">Collector</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,?,</span><span class="no">M</span><span class="o">&gt;</span> <span class="nf">groupingBy</span><span class="o">(</span><span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">&gt;</span> <span class="n">classifier</span><span class="o">,</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">M</span><span class="o">&gt;</span> <span class="n">mapFactory</span><span class="o">,</span> <span class="nc">Collector</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,</span><span class="no">A</span><span class="o">,</span><span class="no">D</span><span class="o">&gt;</span> <span class="n">downstream</span><span class="o">)</span>
</code></pre></div></div>

<p>toMap과 마찬가지로 위의 세 groupingBy에 대응되는 groupingByConcurrent 메서드들도 존재합니다. 동시수행으로 ConcurrentHashMap 인스턴스를 반환합니다.</p>

<p>추가적으로 자주 사용되지는 않지만 groupingBy의 사촌격인 partitioningBy도 존재합니다. 분류 함수로 Predicate를 받고 키가 Boolean인 맵을 반환합니다. 여기에 더해 다운스트림 수집기까지 입력받는 다중정의도 되어있습니다.</p>

<h4 id="다운스트림-전용-수집기">다운스트림 전용 수집기</h4>

<p>앞서 살펴본 counting()은 다운스트림 전용 수집기 입니다. Stream의 count 메서드를 직접 이용해서 같은 기능을 수행할 수 있기 때문에 collect(counting())과 같은 형태로 쓸 일은 절대 없습니다. 이런 속성을 가지는 메서드가 16개나 더 있습니다. 그 중에서 9개는 summing, averaging, summarizing으로 시작하고 각각 int, long, double 스트림용으로 하나씩 존재합니다.</p>

<h4 id="collectors에-정의되어있지만-수집과는-무관한-메서드들">Collectors에 정의되어있지만 수집과는 무관한 메서드들</h4>

<h5 id="minby-maxby">minBy, maxBy</h5>

<p>위 두 메서드는 인수로 비교자를 받아서 스트림에서 가장 작은, 혹은 큰 값을 반홚랍니다. Stream인터페이스의 min, max를 일반화하고 BinaryOperator의 minBy, maxBy 메서드가 반환하는 이진 연산자의 수집기 버전 입니다.</p>

<h5 id="joining">joining</h5>

<p>이 메서드는 CharSequence 인스턴스 스트림에만 적용할 수 있습니다. 매개변수가 없으면 원소들을 이어붙여주고 매개변수가 존재하면 구분자 역할을 해서 원소 사이사이에 함께 추가해서 붙여줍니다. 매개변수를 3개 넣을 수도 있는데 구분자와 더불어 접두, 접미 문자 입니다.</p>

<h2 id="아이템-47-반환-타입으로는-스트림보다-컬렉션이-낫다">아이템 47. 반환 타입으로는 스트림보다 컬렉션이 낫다.</h2>

<hr />

<p>반환 타입을 스트림으로 할지, 반복(itreation)으로 할지를 정하는 것은 쉽지 않은 문제 입니다. 스트림은 반복을 지원하지 않기 때문에 스트림만 반환하게 api를 설계하면 for-each로 반복하길 원하는 클라이언트 입장에서는 불만일 것입니다. 재밌는 점은 Stream 인터페이스는 Iterable 인터페이스가 정의한 추상 메서드를 전부 포함하고 동작도 Iterable이 정의한 대로 하는데 다만 Iterable을 확장하지 않았기 때문에 for-each에 사용할 수 없는 것입니다. 이를 우회할 수 있는 방법은 어댑터를 사용하는 것입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">iterableOf</span><span class="o">(</span><span class="nc">Stream</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">stream</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nl">stream:</span><span class="o">:</span><span class="n">iterator</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>스트림을 인자로 전달해서 스트림의 iterator를 반환하면 됩니다. 그럼 for-each문으로 반복할 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="o">(</span><span class="nc">ProcessHandle</span> <span class="n">p</span> <span class="o">:</span> <span class="n">iterableOf</span><span class="o">(</span><span class="nc">ProcessHandle</span><span class="o">.</span><span class="na">allProcesses</span><span class="o">()))</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>반대로 api가 Iterable만 반환하면 이를 스트림 파이프라인에서 처리하고자 하는 클라이언트 입장에서 불만일 것입니다. 물론 이것도 어댑터로 해결할 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">streamOf</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">iterable</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nc">StreamSupport</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">iterable</span><span class="o">.</span><span class="na">spliterator</span><span class="o">(),</span> <span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>결국 api의 사용자가 스트림이나 반복 중 하나만 사용할 것이라는 확신이 있지 않는 이상 둘을 모두 만족시키기 위해 노력해야 합니다. Collection 인터페이스는 Iterable의 하위 타입이면서 stream 메서드도 제공하기 때문에 반복과 스트림을 동시에 지원합니다. 즉, <strong>원소 시퀀스를 반환하는 공개 api의 반환 타입에는 Collection이나 그 하위 타입을 쓰는 것이 현 상황에서는 최선 입니다.</strong>(자바가 stream에도 iterable을 지원하지 않는 현 상황에선) Arrays 또한 Arrays.asList, Stream.of를 통해 반복과 스트림을 지원하니 사용할 수 있습니다.</p>

<p>또 다른 주의점으로 반환하는 시퀀스의 크기가 크다면 표준 컬렉션 구현체인 ArrayList, HashSet 같은 것을 반환하지 않고 AbstractList 등을 이용해서 전용 컬렉션을 구현하는 것을 검토하는 것이 좋습니다. 물론 시퀀스의 크기가 메모리에 올려도 안전할 정도로 작다면 표준 구현체를 사용해도 됩니다. AbstractCollection을 활용해서 Collection 구현체를 작성할 때는 Iterable용 메서드 외에 contains, size만 더 구현하면 됩니다. 혹, 반복이 시작되기 전에 시퀀스의 내용을 확정할 수 없는 등의 이유로 contains, size를 구현하는 것이 불가능할 경우에는 스트림이나 Iterable을 반환하는 것이 더 좋습니다.</p>

<h2 id="아이템-48-스트림-병렬화는-주의해서-적용하라">아이템 48. 스트림 병렬화는 주의해서 적용하라</h2>

<hr />

<p>스트림의 parallel 메서드를 호출하면 파이프라인을 병려르 실행할 수 있는 스트림을 지원합니다. 메서드 하나로 동시성 프로그램을 작성할 수 있다는 편리함이 있지만 그것이 올바르게 사용하는 것이라는 보장은 없습니다. 동시성에서는 안전성(safety)과 응답 가능 상태(liveness)를 유지해야 하는데 병렬 스트림 파이프라인 프로그래밍에서도 마찬가지 입니다. 병렬화를 할 때는 다음의 내용들을 기억합시다.</p>

<ul>
  <li>
    <p>데이터 소스가 Stream.iterate이거나 중간연산으로 limit을 쓰면 병렬화로 성능 개선을 할 수 없다.</p>
  </li>
  <li>
    <p>스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋다.
해당 자료구조들은 모두 데이터를 원하는 크기로 정확히 나눌 수 있어서 다수의 스레드에 분배하기 좋다는 특징이 있습니다. 나누는 작업은 Spliterator가 담당하고 Spliterator 객체는 Stream이나 Iterable의 spliterator 메서드로 얻어올 수 있습니다.
또 다른 중요한 점은 해당 자료구조들은 원소들을 순차적으로 실행할 때 참조 지역성이 뛰어나다는 것입니다. 이는 캐시 히트의 가능성이 높아짐을 의미하고 캐시 미스로 인한 캐시로의 데이터 이동에 드는 시간을 최소화할 수 있음을 의미합니다. 지역성이 가장 뛰어난 자료구조는 기본 타입 배열입니다. 값 자체가 배열에 연속된 공간으로 들어가기 때문입니다.</p>
  </li>
  <li>
    <p>종단 연산에서는 축소가 병렬화에 가장 적합하다.
종단 연산에서 수행하는 작업량이 전체 작업에서 높은 비중을 차지하면서 순차적인 연산이면 병렬 수행의 효과는 제한적입니다. 가장 적합한 방식은 축소 연산을 통해서 원소를 하나로 합치는 연산 입니다. reduce메서드 중 하나나 min, max, count, sum 같이 완성된 형태로 제공되는 메서드나 anyMatch, allMatch, noneMatch처럼 조건에 맞으면 바로 반환되는 메서드도 적합합니다. 반면 collect의 경우에는 컬렉션들을 합치는 부담이 있기에 적합하지 않습니다.</p>
  </li>
  <li>
    <p>스트림을 잘못 병렬화하면 (응답 불가를 포함해) 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.(safety failure-안전실패)
안전 실패는 스트림에 전달되는 함수가 스트림 명세에 정의해둔 엄격한 함수 객체에 대한 규약을 지키지 않으면 발생할 수 있습니다. 가령 Stream의 reduce 연산에 전달되는 accumulator(누적기)와 combiner(결합기) 함수는 반드시 결합법칙을 만족하고 간섭받지 않고(파이프라인이 수행되는 동안 데이터 소스에 변경이 발생하지 않고), 상태를 갖지 않아야 합니다. 위의 규약을 지키지 않아도 순차 수행시에는 올바른 결과를 얻을 수도 있지만 병렬로 하면 실패로 이어지기 십상입니다.</p>
  </li>
</ul>

    
  </section>

  <!-- Social media shares -->
  

<div class="share-buttons">
    <ul class="share-buttons">
        <div class="meta">Share</div>
        
        <li>
            <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fanstn1993.github.io%2F2021%2F07%2F14%2F%25EC%259D%25B4%25ED%258E%2599%25ED%258B%25B0%25EB%25B8%258C-%25EC%259E%2590%25EB%25B0%2594-7%25EC%259E%25A5.html" target="_blank" title=" Facebook">
			<i class="fa fa-facebook-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Share on Facebook</span>
		</a>
        </li>
         
        <li>
            <a href="https://twitter.com/intent/tweet?text=%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94+-+7%EC%9E%A5.+%EB%9E%8C%EB%8B%A4%EC%99%80+%EC%8A%A4%ED%8A%B8%EB%A6%BC%20https%3A%2F%2Fanstn1993.github.io%2F2021%2F07%2F14%2F%25EC%259D%25B4%25ED%258E%2599%25ED%258B%25B0%25EB%25B8%258C-%25EC%259E%2590%25EB%25B0%2594-7%25EC%259E%25A5.html" target="_blank" title="">
			<i class="fa fa-twitter-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Tweet</span>
		</a>
        </li>
            
        <li>
            <a href="http://www.reddit.com/submit?url=https://anstn1993.github.io/2021/07/14/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-7%EC%9E%A5.html&title=%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94+-+7%EC%9E%A5.+%EB%9E%8C%EB%8B%A4%EC%99%80+%EC%8A%A4%ED%8A%B8%EB%A6%BC%20%7C%20MunSooKim%27s+devlog" target="_blank" title=" Reddit">
			<i class="fa fa-reddit-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Share on Reddit</span>
		</a>
        </li>
           
        <li>
            <a href="mailto:?subject=%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94+-+7%EC%9E%A5.+%EB%9E%8C%EB%8B%A4%EC%99%80+%EC%8A%A4%ED%8A%B8%EB%A6%BC%20%7C%20MunSooKim%27s+devlog&body=:%20https://anstn1993.github.io/2021/07/14/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-7%EC%9E%A5.html" target="_blank" title="">
			<i class="fa fa-envelope-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Email</span>
		</a>
        </li>
        
    </ul>
</div>




   <!-- Tag list -->
  
  


<footer>
  <div class="tag-list">
    
      <div class="meta">Tags</div>
    

    
    <a class="button" href="/tags#%EA%B8%B0%EC%88%A0">
      <p><i class="fa fa-tag fa-fw"></i> 기술</p>
    </a>
    
    <a class="button" href="/tags#%EC%9E%90%EB%B0%94">
      <p><i class="fa fa-tag fa-fw"></i> 자바</p>
    </a>
    
  </div>
</footer>


</article>

<!-- Disqus -->

<div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname = 'https-anstn1993-github-io';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view comments.</noscript>
</div>


<!-- Post navigation -->

  <div id="post-nav">
    
    <div id="previous-post">
        <a alt="이펙티브자바 - 8장. 메서드" href="/2021/07/21/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-8%EC%9E%A5.html">
            <p>Previous post</p>
            이펙티브자바 - 8장. 메서드
        </a>
    </div>
    

    
    <div id="next-post">
        <a alt="이펙티브자바 - 6장. 열거 타입과 애너테이션" href="/2021/07/07/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-6%EC%9E%A5.html">
            <p>Next post</p>
            이펙티브자바 - 6장. 열거 타입과 애너테이션
        </a>
    </div>
    
</div>



<!-- To change color of links in the page -->
<style>
  
  .feature-image a { color: brown !important; }
  div#post-nav a { color: brown !important; }
  footer a { color: brown !important; }
  .site-header nav a:hover {  color: brown !important; }
  header#main { background-color: brown !important; }
  

  header#main {
    background-repeat:no-repeat;
  background-image: url('/assets/img/lineart.png');  
  }
</style>

    </div>
    <footer class="site-footer">
    <p class="text">
         </p>
            <div class="footer-icons">
                <ul>
                <!-- Social icons from Font Awesome, if enabled -->
                


<li>
    <a href="mailto:anstn1993@gmail.com" title="Email">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
        </span>
    </a>
</li>













<li>
    <a href="https://github.com/anstn1993" title="Follow on GitHub">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-github fa-stack-1x fa-inverse"></i>
        </span>
    </a>
</li>
































                </ul>
            </div>
</footer>



  </body>
</html>
