<!DOCTYPE html>
<!--
    Type on Strap jekyll theme v2.3.0
    Copyright 2016-2020 Sylhare
    Theme free for personal and commercial use under the MIT license
    https://github.com/sylhare/Type-on-Strap/blob/master/LICENSE
-->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!-- Main JS (navbar.js, katex_init.js and masonry_init.js)-->
    <script defer src="/assets/js/main.min.js"></script>
    
    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <!--Favicon-->
    <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

    <!-- RSS -->
    <link rel="alternate" type="application/atom+xml" title="MunSooKim's devlog" href="https://anstn1993.github.io/feed.xml"/>
    
    

    <!-- KaTeX 0.12.0 -->
    
    <script defer src="/assets/js/vendor/katex.min.js"></script>
    <script defer src="/assets/js/vendor/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
    

    <!-- Mermaid 8.8.2 -->
    
    <!-- <script src=”https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.8.2/mermaid.min.js" onload="mermaid.initialize({startOnLoad:true});"></script> -->
    <script defer src="/assets/js/vendor/mermaid.min.js" onload="mermaid.initialize({startOnLoad:true});"></script>
    

    <!-- Simple-Jekyll-Search 1.17.12 -->
    <script src="/assets/js/vendor/simple-jekyll-search.min.js" type="text/javascript"></script>

    <!-- Google Analytics / Cookie Consent -->
    <script>
      const cookieName = 'cookie-notice-dismissed-https://anstn1993.github.io';
      const isCookieConsent = 'false';
      const analyticsName = '';
    </script>

    
    

    <!-- seo tags -->
    <meta property="og:image" content="https://anstn1993.github.io/assets/img/pexels/triangular.jpeg">
    
    <meta property="og:type" content="website" />
    
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>이펙티브자바 - 12장. 직렬화 | MunSooKim’s devlog</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="이펙티브자바 - 12장. 직렬화" />
<meta name="author" content="Mun Soo Kim" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다." />
<meta property="og:description" content="조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다." />
<link rel="canonical" href="https://anstn1993.github.io/2021/08/18/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-12%EC%9E%A5.html" />
<meta property="og:url" content="https://anstn1993.github.io/2021/08/18/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-12%EC%9E%A5.html" />
<meta property="og:site_name" content="MunSooKim’s devlog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-08-18T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="이펙티브자바 - 12장. 직렬화" />
<script type="application/ld+json">
{"headline":"이펙티브자바 - 12장. 직렬화","dateModified":"2021-08-18T00:00:00+09:00","datePublished":"2021-08-18T00:00:00+09:00","url":"https://anstn1993.github.io/2021/08/18/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-12%EC%9E%A5.html","mainEntityOfPage":{"@type":"WebPage","@id":"https://anstn1993.github.io/2021/08/18/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-12%EC%9E%A5.html"},"author":{"@type":"Person","name":"Mun Soo Kim"},"description":"조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <!-- RSS -->
    <link type="application/atom+xml" rel="alternate" href="https://anstn1993.github.io/feed.xml" title="MunSooKim's devlog" />

    <!-- Twitter Cards -->
    <meta name="twitter:title" content="이펙티브자바 - 12장. 직렬화">
    <meta name="twitter:description" content="조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.12장. 직렬화직렬화는 자바가 객체를 바이트 스트림으로 인코딩하고(직렬화) 그 바이트 스트림으로부터 다시 객체를 재구성하는(역직렬화) 메커니즘입니다. 주로 다른 VM에 전송하거나 디스크에 저장하고 불러...">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:image" content="https://anstn1993.github.io/assets/img/pexels/triangular.jpeg">
    <meta name="twitter:image:alt" content="이펙티브자바 - 12장. 직렬화">
</head>

  <body>
    <header class="site-header">

    <!-- Logo and title -->
	<div class="branding">
        
		<a href="/">
			<img alt="logo img" class="avatar" src="/assets/img/triangle.png" />
		</a>
        
        <a class="site-title" aria-label="MunSooKim's devlog" href="/">
        MunSooKim's devlog
		</a>
	</div>

    <!-- Toggle menu -->
    <nav class="clear">
    <a aria-label="pull" id="pull" class="toggle" href="#">
    <i class="fa fa-bars fa-lg"></i>
    </a>

    <!-- Menu -->
    <ul class="hide">
        

        
            
            
        
            
            <li class="separator"> | </li>
            <li>
                <a class="clear" aria-label="About" title="About" href="/about">
                     About 
                </a>
            </li>
            
            
        
            
            
        
            
            
        
            
            
        
            
            <li class="separator"> | </li>
            <li>
                <a class="clear" aria-label="Search" title="Search" href="/search">
                     <i class="fa fa-search" aria-hidden="true"></i>
                    
                </a>
            </li>
            
            
        
            
            <li class="separator"> | </li>
            <li>
                <a class="clear" aria-label="Tags" title="Tags" href="/tags">
                     <i class="fa fa-tags" aria-hidden="true"></i>
                    
                </a>
            </li>
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    </ul>

	</nav>
</header>

    <div class="content">
      <article class="feature-image" >
  <header id="main" style="">
    <div class="title-padder">
      
      <h1 id="%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94+-+12%EC%9E%A5.+%EC%A7%81%EB%A0%AC%ED%99%94" class="title">이펙티브자바 - 12장. 직렬화</h1>
      


<div class="post-info">
    <p class="meta">
      August 18, 2021
    </p></div>

      
    </div>
  </header>

  <section class="post-content">
  
      <p>조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.</p>

<h1 id="12장-직렬화">12장. 직렬화</h1>

<p>직렬화는 자바가 객체를 바이트 스트림으로 인코딩하고(직렬화) 그 바이트 스트림으로부터 다시 객체를 재구성하는(역직렬화) 메커니즘입니다. 주로 다른 VM에 전송하거나 디스크에 저장하고 불러오기 위해서 사용합니다. 하지만 직렬화는 사용하지 않는 것이 좋습니다. 이 장에서는 직렬화의 위험과 위험을 최소화하는 방법을 살펴봅니다.</p>

<h2 id="아이템-85-자바-직렬화의-대안을-찾으라">아이템 85. 자바 직렬화의 대안을 찾으라</h2>

<hr />

<p>직렬화의 <code class="language-plaintext highlighter-rouge">readObject</code> 메서드로 바이트 스르팀을 역질렬화하는 과정에서 클래스패스 내의 (<code class="language-plaintext highlighter-rouge">Serializable</code>을 구현한) 모든 타입의 객체를 만들어낼 수 있습니다.(표준 라이브러리나 아파치 커먼즈 컬렉션 같은 서드파티 라이브러리도 포함됩니다.) 그리고 <code class="language-plaintext highlighter-rouge">readObject</code> 메서드는 만들어내는 모든 타입들 안의 코드를 수행할 수 있기에 그 코드들이 모두 공격의 대상이 될 수 있습니다. 아무리 모든 공격에 대비하고 모범사례를 따른다고 자부하더라도 여전히 취약할 수 있습니다. 뿐만 아니라 역릭렬화에 시간이 매우 오래 걸리는 스트림(역직렬화 폭탄)을 역질렬화하게 되면 서비스 거부 공격에 노출됩니다. 역직렬화는 객체 그래프를 타고 들어가면서 객체를 생성해내기 때문에 이 그래프의 깊이가 너무 깊어지면 스택 오버플로가 발생하게 됩니다.</p>

<p>이런 문제들에 대처하기 위한 방법을 살펴보겠습니다.</p>

<ol>
  <li>
    <p><strong>아무것도 역직렬화하지 말자.</strong>
우리가 작성하는 새로운 시스템에서 자바 직렬화를 써야 할 이유는 전혀 없습니다. 이미 자바 직렬화의 위험을 회피할 수 있는 좋은 크로스-플랫폼 구조화된 데이터 표현(cross-platform structured-data representation)들이 존재합니다. 대표적으로 <strong>JSON, 프로토콜 버퍼</strong>가 있습니다. <code class="language-plaintext highlighter-rouge">JSON</code>은 텍스트 기반이라서 사람이 읽을 수 있고, <code class="language-plaintext highlighter-rouge">프로토콜 버퍼</code>는 이진 표현이라 효율이 좋습니다.(<code class="language-plaintext highlighter-rouge">프로토콜 버퍼</code>도 사람이 읽을 수 있는 텍스트 표현도 지원합니다.) 또한 <code class="language-plaintext highlighter-rouge">JSON</code>은 데이터 표현을 위해서만 쓰이지만 <code class="language-plaintext highlighter-rouge">프로토콜 버퍼</code>는 문서를 위한 스키마를 제공하고 올바로 쓰게 강제합니다.</p>
  </li>
  <li>
    <p><strong>신뢰할 수 없는 데이터는 절대 역질렬화하지 말자.</strong>
레거시 시스템 때문에 어쩔 수 없이 직렬화를 사용해야 한다면 신뢰할 수 있는 데이터만 역직렬화해야 합니다. 만약 역직렬화한 데이터가 안전한지 완전히 확신할 수 없다면 자바 9에 추가된 <code class="language-plaintext highlighter-rouge">역직렬화 필터링(ObjectInputFilter)</code>를 사용합시다. 역직렬화가 되기 전에 필터를 설치하여 특정 클래스를 받아들이거나 거부할 수 있습니다. 크게 ‘기본 수용’ 모드와 ‘기본 거부’ 모드가 있습니다. ‘기본 수용’ 모드는 블랙리스트에 기록된 잠재적으로 위험한 클래스들을 거부합니다. ‘기본 거부’ 모드는 화이트리스트에 기록된 안전하다고 알려진 클래스들만 수용합니다. 기본적으로 ‘기본 거부’ 모드가 더 안전합니다. 블랙리스트 방식은 이미 알려진 위험만 차단할 수 있기 때문입니다. 스왓(SWAT, Serial Whitelist Appplication Trainer)이라는 도구로 화이트리스트를 자동 생성할 수 있습니다.</p>
  </li>
</ol>

<h2 id="아이템-86-serializable을-구현할지는-신중히-결정하라">아이템 86. Serializable을 구현할지는 신중히 결정하라</h2>

<hr />

<p>직렬화를 지원하려면 <code class="language-plaintext highlighter-rouge">Serializable</code>만 구현하면 되기 때문에 매우 쉬워보이지만 길게 보면 아주 비싼 일입니다. 그 이유를 살펴보겠습니다.</p>

<ol>
  <li>
    <p><strong>Serializable을 구현하면 릴리스한 뒤에는 수정하기 어렵다.</strong>
클래스가 <code class="language-plaintext highlighter-rouge">Serializable</code>을 구현하면 직렬화된 바이트 스트림 인코딩도 하나의 공개 API가 됩니다. 그래서 이 클래스가 널리 퍼지면 그 직렬화 형태도 영원히 지원을 해야 합니다. 만약 커스텀 직렬화가 아닌 자바의 기본 직렬화를 적용하면 그 형태의 클래스의 <code class="language-plaintext highlighter-rouge">private</code>, <code class="language-plaintext highlighter-rouge">package-private</code> 필드들까지 공개되는 꼴이 되어서 정보 은닉이 무력화됩니다. 또한 추후에 클래스 내부 구현을 바꾸면 원래의 직렬화 형태와 달라지기 때문에 구버전과 신버전의 호환성 문제도 발생합니다. 물론 원래의 코드를 유지하면서 새로운 코드를 추가할 수 있지만 이는 쉽지 않고 불필요하고 지저분한 코드를 남겨두는 꼴입니다. 그러니까 직렬화를 꼭 적용해야 한다면 초기 설계부터 확장성을 고려해야 합니다.
직렬화가 클래스 개선을 방해하는 대표적인 예가 바로 스트림 고유 식별자, 즉 <code class="language-plaintext highlighter-rouge">직렬 버전 UID(Serial version UID)</code>입니다. 모든 직렬화된 클래스는 고유 식별 번호를 부여받습니다. 해당 클래스에 명시적으로 <code class="language-plaintext highlighter-rouge">private static final long serialVersionUID</code>필드를 선언하지 않으면 시스템이 임의로 런타임에 암호 해시 함수를 적용해서 자동으로 클래스에 식별 번호를 부여하게 됩니다. 이 값을 만드는 데 필요한 재료는 클래스 이름, 구현 인터페이스들, 대부분의 클래스 멤버 등입니다. 그래서 이후에 편의 메서드를 추가하는 식으로 하나라도 수정을 가하면 <code class="language-plaintext highlighter-rouge">직렬 버전 UID</code>의 값도 변해서 호환성이 깨집니다.</p>
  </li>
  <li>
    <p><strong>버그와 보안 굼벙이 생길 위험이 높아진다.</strong>
직렬화는 생성자를 통해 객체를 생성하는 기본적인 루트를 우회하여 객체를 생성하기 때문에 생성자에서 구축한 불변식을 모두 보장해야 하고 생성 도중 공격자가 객체 내부를 들여다볼 수 없도록 해야 한다는 사실을 떠올리기 어렵습니다. 기본 역직렬화를 사용하면 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출됩니다.</p>
  </li>
  <li>
    <p><strong>Serializable을 구현한 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다.</strong>
직렬화 가능 클래스가 수정되면 신버전 인스턴스를 직렬화하고 구버전으로 역직렬화가 가능한지, 그 반대도 가능한지를 검사해야 합니다. 그래서 테스트해야 할 양이 직렬화 가능 클래스의 수와 릴리스 횟수에 비례해서 증가합니다. 클래스를 처음 제작할 때 커스텀 직렬화 형태로 설계를 잘 했다면 이런 테스트 부담을 줄일 수 있습니다.</p>
  </li>
</ol>

<p>이처럼 <code class="language-plaintext highlighter-rouge">Serializable</code>의 구현 여부는 쉽게 결정할 사안이 아닙니다. 하지만 우리가 사용하려고 하는 프레임워크, 라이브러리가 객체의 전송과 저장을 할 때 직렬화를 이용하고 있다면 <code class="language-plaintext highlighter-rouge">Serializable</code>의 구현을 할 수밖에 없습니다. 하지만 이런 경우를 제외하고는 구현 여부를 잘 생각해봐야 합니다. 역사적으로 <code class="language-plaintext highlighter-rouge">BigInteger</code>, <code class="language-plaintext highlighter-rouge">Instant</code> 같은 ‘값’ 클래스와 컬렉션 클래스들은 Serializable을 구현했고, 스레드 풀처럼 ‘동작’하는 객체를 표현하는 클래스들은 대부분 Serializable을 구현하지 않았습니다.
특히 상속용으로 설계된 클래스는 대부분 <code class="language-plaintext highlighter-rouge">Serializable</code>을 구현하면 안 되고 인터페이스도 <code class="language-plaintext highlighter-rouge">Serializable</code>을 확장하면 안 됩니다. 왜냐하면 이런 클래스를 확장하거나 구현하는 쪽에 부담이 생기기 때문입니다. 이런 클래스는 역질렬화를 하려면 그 상위 클래스는 기본 생성자를 제공해야 합니다. 그런데 만약 그런 생성자를 제공하지 않으면 하위 클래스에서 어쩔 수 없이 직렬화 프록시 패턴을 사용해야만 합니다.</p>

<p>만약 우리가 작성하는 클래스의 인스턴스 필드가 직렬화와 확장이 모두 가능하면 주의해야 할 사항이 몇 가지 있습니다.</p>

<ol>
  <li>
    <p>인스턴스 필드 값 중 불변식 보장이 필요한 게 있다면 반드시 하위 클래스에서 finalize 메서드를 재정의하지 못하게 막아야 한다.
이렇게 하는 이유는 finalizer 공격을 막기 위함입니다.</p>
  </li>
  <li>
    <p>인스턴스 필드 중 기본값으로 초기화되면 위배되는 불변식이 있다면 클래스에 <code class="language-plaintext highlighter-rouge">readObjectNoData</code>메서드를 반드시 추가해야 한다.</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">readObjectNoData</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InvalidObjectException</span> <span class="o">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidObjectException</span><span class="o">(</span><span class="s">"스트림 데이터가 필요합니다."</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>이 메서드는 기존의 직렬화 가능 클래스에 직렬화 가능 상위 클래스를 추가하는 드문 드문 경우를 위한 메서드입니다.</p>
  </li>
</ol>

<p>마지막으로 정적 멤버 클래스를 제외한 내부 클래스는 직렬화를 구현하지 말아야 합니다.</p>

<h2 id="아이템-87-커스텀-직렬화-형태를-고려해보라">아이템 87. 커스텀 직렬화 형태를 고려해보라</h2>

<hr />

<p><strong>기본 직렬화 형태는 객체의 물리적 표현과 논리적 내용이 같은 경우에만 사용</strong>해야 합니다. 다음의 예는 기본 직렬화 형태를 써도 됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Name</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
  <span class="cm">/**
  * 성. null이 아니어야 함
  * @serial
  */</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">string</span> <span class="n">lastName</span><span class="o">;</span>

  <span class="cm">/**
  * 이름. null이 아니어야 함
  * @serial
  */</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">string</span> <span class="n">firstName</span><span class="o">;</span>

  <span class="cm">/**
  * 중간이름. 중간이름이 없다면 null
  * @serial
  */</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">string</span> <span class="n">middleName</span><span class="o">;</span>

  <span class="o">...</span> <span class="c1">// 나머지 코드는 생략</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 성명 클래스는 논리적으로 이름, 성, 중간이름이라는 3개의 문자열로 구성되고, 앞 코드의 인스턴스 필드들은 이 논리적 구성요소를 정확히 반영했습니다. 그런데 기본 직렬화 형태가 적합하다고 판단했더라도 불변식 보장과 보안을 위해서 <code class="language-plaintext highlighter-rouge">readObject</code> 메서드를 제공해야 할 때가 많습니다. <code class="language-plaintext highlighter-rouge">Name</code> 클래스는 성과 이름이 null이 아님을 보장해야 합니다. 이에 관해서는 아이템 88, 90에서 살펴봅니다. 한 가지 더 주목할 점은 <code class="language-plaintext highlighter-rouge">private</code> 필드임에도 문서화 주석이 달렸다는 것입니다. 앞에서도 말했지만 직렬화를 하는 순간 이미 그 클래스의 모든 구성요소는 공개 API가 되기 때문에 문서화의 대상이 됩니다. <code class="language-plaintext highlighter-rouge">@serial</code> 태그를 사용하면 그 내용은 API 문서에서 직렬화 형태를 설명하는 특별한 페이지에 기록됩니다.</p>

<p>이번에는 기본 직렬화에 적합하지 않은 예로 살펴보겠습니다. 아래 클래스는 문자열 리스트를 표현합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">StringList</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">Entry</span> <span class="n">head</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Entry</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">data</span><span class="o">;</span>
    <span class="nc">Entry</span> <span class="n">next</span><span class="o">;</span>
    <span class="nc">Entry</span> <span class="n">previous</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="o">...</span> <span class="c1">// 나머지 코드는 생략</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 클래스는 논리적으로 일련의 문자열을 표현합니다. 물리적으로는 문자열을 이중 연결 리스트로 연결합니다. 이 클래스에 기본 직렬화를 적용하면 각 노드의 양방향 연결 정보를 포함해 모든 엔트리를 다 기록합니다. 이처럼 객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화를 사용하면 크게 네 가지 문제가 생깁니다.</p>

<ol>
  <li><strong>공개 API가 현재의 내부 표현 방식에 영구하게 묶인다.</strong>
<code class="language-plaintext highlighter-rouge">private</code> 클래스인 <code class="language-plaintext highlighter-rouge">StringList.Entry</code>도 공개 API가 됩니다. 그래서 다음 릴리스에서 내부 표현 방식을 바꿔도 여전히 연결 리스트로 표현된 입력도 처리해야 하기에 사용하지 않음에도 불구하고 코드를 제거할 수 없습니다.</li>
  <li><strong>너무 많은 공간을 차지할 수 있다.</strong>
위 코드에서 직렬화를 하면 연결 리스트의 모든 엔트리와 연결 정보까지 기록하는데 사실 이들은 직렬화 형태에 포함될 필요가 없습니다. 이런 데이터들로 인해 크기가 너무 커져 디스크에 저장하거나 네트워크로 전송하는 속도가 느려집니다.</li>
  <li><strong>시간이 너무 많이 걸릴 수 있다.</strong>
기본 직렬화 로직은 객체 그래프의 위상에 관한 정보가 없어서 그래프를 직접 순회해봐야 하기에 시간이 오래 걸립니다.</li>
  <li><strong>스택 오버플로를 일으킬 수 있다.</strong>
객체 그래프를 재귀적으로 순회하는 과정에서 스택 오버플로가 일어날 수 있습니다.</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">StringList</code>의 합리적인 직렬화 형태는 리스트가 포함한 문자열의 개수를 적고 그 뒤로 문자열들을 나열하는 수준이면 될 것입니다. StringList의 논리적인 구성만 담는 것입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">StringList</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">transient</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">transient</span> <span class="nc">Entry</span> <span class="n">head</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

  <span class="c1">// 이제 직렬화하지 않는다.</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Entry</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">data</span><span class="o">;</span>
    <span class="nc">Entry</span> <span class="n">next</span><span class="o">;</span>
    <span class="nc">Entry</span> <span class="n">previous</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="c1">// 지정한 문자열을 이 리스트에 추가</span>
  <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

  <span class="cm">/**
  * 이 {@code StringList} 인스턴스를 직렬화한다.
  *
  * @serialData 이 리스트의 크기(포함된 문자열의 개수)를 기록한 후
  * ({@code int}), 이어서 모든 원소를(각각은 {@code String})
  * 순서대로 기록한다.
  */</span>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">writeObject</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">s</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="n">s</span><span class="o">.</span><span class="na">defaultWriteObject</span><span class="o">();</span>
    <span class="n">s</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>

    <span class="c1">// 모든 원소를 올바른 순서로 기록</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Entry</span> <span class="n">e</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">s</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">data</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">readObject</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">s</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ClassNotFoundException</span> <span class="o">{</span>
    <span class="n">s</span><span class="o">.</span><span class="na">defaultReadObject</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">numElements</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>

    <span class="c1">// 모든 원소를 읽어서 이 리스트에 삽입</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numElements</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="n">add</span><span class="o">((</span><span class="nc">String</span><span class="o">)</span> <span class="n">s</span><span class="o">.</span><span class="na">readObject</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="o">...</span> <span class="c1">// 나머지 코드는 생략</span>
<span class="o">}</span>
</code></pre></div></div>

<p>우선 <code class="language-plaintext highlighter-rouge">writeObject</code>, <code class="language-plaintext highlighter-rouge">readObject</code> 메서드가 직렬화 형태를 처리합니다. 그리고 일시적이라는 의미를 가지는 <code class="language-plaintext highlighter-rouge">transient</code> 한정자는 해당 필드가 기본 직렬화 형태에 포함되지 않는다는 표시입니다. 팔드가 모두 <code class="language-plaintext highlighter-rouge">transient</code>라고 해도 <code class="language-plaintext highlighter-rouge">writeObject</code>, <code class="language-plaintext highlighter-rouge">readObject</code>가 각각 가장 먼저 <code class="language-plaintext highlighter-rouge">defaultWriteObject</code>, <code class="language-plaintext highlighter-rouge">defaultReadObject</code> 메서드를 호출합니다. 이 메서드들은 오직 <code class="language-plaintext highlighter-rouge">writeObject</code>, <code class="language-plaintext highlighter-rouge">readObject</code>에서만 호출 가능한 메서드로 <code class="language-plaintext highlighter-rouge">non-static</code>, <code class="language-plaintext highlighter-rouge">non-transient</code>필드에 대한 값을 스트림에 쓰고 읽게 됩니다. 필드가 모두 <code class="language-plaintext highlighter-rouge">transient</code>임에도 이 메서드를 호출하는 이유는 직렬화 명세가 이 작업을 무조건 하라고 하기 때문입니다. 이렇게 해야 향후 <code class="language-plaintext highlighter-rouge">non-transient</code> 필드가 추가되더라도 호환이 됩니다. <code class="language-plaintext highlighter-rouge">defaultWriteObject</code> 메서드를 호출하면 <code class="language-plaintext highlighter-rouge">transient</code>로 선언하지 않은 모든 필드가 직렬화되니까 <code class="language-plaintext highlighter-rouge">transient</code>로 선언해도 되는 필드에는 모두 사용합시다. <code class="language-plaintext highlighter-rouge">transient</code>한정자를 생략해야 하는 경우는 해당 객체의 논리적 상태와 무관한 필드라고 확신할 수 있을 때입니다. 그리고 기본 직렬화를 사용하면 <code class="language-plaintext highlighter-rouge">transient</code> 필드들은 역직렬화시에 모두 기본값으로 초기화가 됩니다. 만약 기본값으로 초기화가 되면 안 되는 경우에는 <code class="language-plaintext highlighter-rouge">readObject</code> 메서드에서 <code class="language-plaintext highlighter-rouge">defaultReadObject</code>를 호출하고 해당 필드를 뭔하는 값으로 복원합시다.</p>

<p>그리고 <code class="language-plaintext highlighter-rouge">writeObject</code> 메서드가 <code class="language-plaintext highlighter-rouge">private</code>임에도 문서화 주석이 달린 건 앞에서 봤던 예와 동일한 이유입니다. <code class="language-plaintext highlighter-rouge">@serialData</code> 태그는 자바독 유틸리트에게 이 내용을 직렬화 형태 페이지에 추가하게끔 합니다.</p>

<p>직렬화를 이렇게 커스텀하기만 해도 문자열들의 평균 길이가 10이라고 가정했을 때 커스텀 직렬화 버전이 기본 직렬화보다 공간을 절반만 차지하고 스택 오버플로도 발생하지 않아서 직렬화 크기 제한이 없어집니다.</p>

<p><strong>기본 직렬화 사용 여부와 상관없이 객체의 전체 상태를 읽는 메서드에 적용해야 하는 동기화 메커니즘은 직렬화에도 적용해야 합니다.</strong> 예를 들어 모든 메서드를 <code class="language-plaintext highlighter-rouge">synchronized</code>로 선언하여 스레드 안전한 객체에서 기본 직렬화를 사용하면 <code class="language-plaintext highlighter-rouge">writeObject</code>도 동기화 메서드로 만들어야 합니다.</p>

<p>마지막으로 어떤 직렬화 형태를 택하든 <strong>직렬화 가능 클래스 모두에 <code class="language-plaintext highlighter-rouge">직렬 버전 UID</code>를 명시적으로 부여</strong>합시다. 이렇게 하면 <code class="language-plaintext highlighter-rouge">직렬 버전 UID</code>가 매번 달라져서 발생하는 호환성 문제도 사라지고, <code class="language-plaintext highlighter-rouge">직렬 버전 UID</code> 값을 런타임에 생성하는 연산도 하지 않기 때문에 성능 개선도 이루어집니다. 그냥 각 클래스에 아래 같은 한 줄만 추가하면 끝입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">무작위로</span> <span class="n">고른</span> <span class="kt">long</span> <span class="n">값</span><span class="o">&gt;;</span>
</code></pre></div></div>

<p>어떤 값이라도 상관 없습니다. 고유할 필요도 없습니다. 클래스 일련 번호를 생성해주는 <code class="language-plaintext highlighter-rouge">serialver</code> 유틸리티를 이용해도 됩니다. 이 유틸리티는 <code class="language-plaintext highlighter-rouge">직렬 버전 UID</code>가 없던 클래스를 구버전으로 직렬화된 인스턴스와 호환성을 유지하면서 수정하고 싶을 때 사용하기 좋습니다. 구버전에서 생성됐던 자동 생성된 값을 신버전에도 사용해야하기 때문에 직렬화된 인스턴스가 존재하는 구버전 클래스를 <code class="language-plaintext highlighter-rouge">serialver</code> 유틸리티에 입력으로 주고 실행해서 얻을 수 있습니다. 만약 구버전과의 호환성을 끊고 싶으면 <code class="language-plaintext highlighter-rouge">직렬 버전 UID</code>값을 바꿔버리면 됩니다. 이런 경우를 제외하고는 절대 수정하지 맙시다.</p>

<h2 id="아이템-88-readobject-메서드는-방어적으로-작성하라">아이템 88. readObject 메서드는 방어적으로 작성하라</h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">readObject</code> 메서드는 직렬화 과정에서 마치 <code class="language-plaintext highlighter-rouge">public 생성자</code>로 객체를 생성하는 것과 같기 때문에 그 어떤 바이트 스트림이 넘어오더라도 방어적 복사가 잘 이루어지도록 해야 합니다. 직렬화된 바이트 스트림에 어떤 조작이 가해졌을 지 모르기 때문입니다. 아이템 50에서 살펴봤던 불변인 날짜 범위 클래스를 만들 때 가변인 <code class="language-plaintext highlighter-rouge">Date</code>필드를 사용했습니다. 그 클래스를 직렬화하기로 결정했다고 가정하겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Period</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Date</span> <span class="n">start</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Date</span> <span class="n">end</span><span class="o">;</span>

  <span class="cm">/**
  * @param start 시작 시각
  * @param end 종료 시각; 시작 시각보다 뒤여야 한다.
  * @throws IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다.
  * @throws NullPointerException start나 end가 null이면 발행한다.
  */</span>
  <span class="kd">public</span> <span class="nf">Period</span><span class="o">(</span><span class="nc">Date</span> <span class="n">start</span><span class="o">,</span> <span class="nc">Date</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">start</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="o">(</span><span class="n">start</span><span class="o">.</span><span class="na">getTime</span><span class="o">());</span>
    <span class="k">this</span><span class="o">.</span><span class="na">end</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="o">(</span><span class="n">end</span><span class="o">.</span><span class="na">getTime</span><span class="o">());</span>
    <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">start</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">end</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="s">"가"</span> <span class="o">+</span> <span class="n">end</span> <span class="o">+</span> <span class="s">"보다 늦다."</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nc">Date</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">Date</span><span class="o">(</span><span class="n">start</span><span class="o">.</span><span class="na">getTime</span><span class="o">());</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="nc">Date</span> <span class="nf">end</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">Date</span><span class="o">(</span><span class="n">end</span><span class="o">.</span><span class="na">getTime</span><span class="o">());</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">start</span> <span class="o">+</span> <span class="s">" - "</span> <span class="o">+</span> <span class="n">end</span><span class="o">;</span> <span class="o">}</span>

  <span class="o">...</span> <span class="c1">// 나머지 코드는 생략</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위와 같이 <code class="language-plaintext highlighter-rouge">Serializable</code>만 구현하면 될 것이라고 생각할 수 있지만 그렇게 하는 걸로는 불변식을 보장받지 못하게 됩니다. 왜냐하면 직렬화된 데이터를 객체로 변환하는 것은 <code class="language-plaintext highlighter-rouge">readObjcet</code>로 일어나지, 위에 정의된 생성자로 일어나는 것이 아니기 때문입니다. 그래서 직렬화된 바이트 스트림이 불변식이 깨진 형태(start가 end보다 늦는 경우)로 변환되어서 들어오면 그대로 불변식이 깨진 객체가 만들어집니다. 아래의 코드를 참조하세요.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BogusPeriod</span> <span class="o">{</span>
  <span class="c1">// 진짜 Period 인스턴스에서는 만들어질 수 없는 바이트 스트림</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">serializedForm</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">};</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Period</span> <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Period</span><span class="o">)</span> <span class="n">deserialize</span><span class="o">(</span><span class="n">serializedForm</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">static</span> <span class="nc">Object</span> <span class="nf">deserialize</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">sf</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">ObjectInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="n">sf</span><span class="o">)).</span><span class="na">readObject</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="o">|</span> <span class="nc">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 문제를 해결학려면 <code class="language-plaintext highlighter-rouge">Period</code>의 <code class="language-plaintext highlighter-rouge">readObject</code> 메서드가 <code class="language-plaintext highlighter-rouge">defaultReadObject</code>를 호출하고 역직렬화된 객체가 유효한지 검사해야 합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">readObject</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">s</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ClassNotFoundException</span> <span class="o">{</span>
  <span class="n">s</span><span class="o">.</span><span class="na">defaultReadObject</span><span class="o">();</span>

  <span class="c1">// 불변식을 만족하는지 검사한다.</span>
  <span class="k">if</span><span class="o">(</span><span class="n">start</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">end</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="s">"가"</span> <span class="o">+</span> <span class="n">end</span> <span class="o">+</span> <span class="s">"보다 늦다."</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="아이템-89-인스턴스-수를-통제해야-한다면-readresolve-보다는-열거-타입을-사용하라">아이템 89. 인스턴스 수를 통제해야 한다면 readResolve 보다는 열거 타입을 사용하라</h2>

<hr />

<p>싱글턴 패턴으로 인스턴스를 오직 하나만 만드는 것을 보장할 수 있지만, 그 클래스에 직렬화 기능을 구현하는 순간 더 이상 싱글턴을 보장할 수 없게 됩니다. 기본 직렬화를 쓰든, 명시적인 <code class="language-plaintext highlighter-rouge">readObject</code>를 제공하든 직렬화를 통해서 객체를 생성하면 싱글턴 인스턴스와 별개의 인스턴스를 반환하게 됩니다. 하지만 <code class="language-plaintext highlighter-rouge">readResolve</code>메서드를 잘 정의해두면 역직렬화 후 새로 생성된 객체를 인수로 하여 이 메서드가 호출되고 이 메서드가 반환하는 객체의 참조가 역직렬화로 생성된 객체를 대신해서 반환하기 때문에 <code class="language-plaintext highlighter-rouge">readResolve</code>에서 싱글턴 인스턴스를 반환해주면 됩니다. 그리고 역직렬화된 기존 객체는 가비지 컬렉터에 의해 수거됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Elvis</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Elvis</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Elvis</span><span class="o">();</span>

  <span class="kd">private</span> <span class="nf">Elvis</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

  <span class="c1">// 인스턴스 통제를 위한 readResolve</span>
  <span class="kd">private</span> <span class="nc">Object</span> <span class="nf">readResolve</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 진짜 Elvis를 반환하고, 가짜 Elvis는 가비지 컬렉터에 맡긴다.</span>
    <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이처럼 역직렬화된 <code class="language-plaintext highlighter-rouge">Elvis</code>가 쓰이지 않으니 직렬화 영태는 아무런 실 데이터를 가질 이유가 없습니다. 그래서 <strong><code class="language-plaintext highlighter-rouge">readResolve</code>를 인스턴스 통제 목적으로 활용하는 경우에는 객체 참조 타입 인스턴스 필드는 모두 <code class="language-plaintext highlighter-rouge">transient</code>로 선언해야 합니다.</strong> 그렇지 않으면 <code class="language-plaintext highlighter-rouge">readResolve</code>가 수행되기 전에 역직렬화된 객체의 참조를 공격할 수 있게 됩니다. 싱글턴이 <code class="language-plaintext highlighter-rouge">transient</code>가 아닌 참조 필드를 가지고 있으면 그 필드의 내용은 <code class="language-plaintext highlighter-rouge">readResolve</code> 메서드가 실행되기 전에 격직렬화됩니다. 그럼 조작된 스트림을 써서 해당 참조 필드의 내용이 역직렬화되는 시점에 그 역직렬화된 인스턴스의 참조를 훔쳐올 수 있게 됩니다.</p>

<p>그렇기 때문에 단순히 인스턴스 통제를 원한다면 <strong>열거 타입</strong>을 이용하는 것이 가장 좋습니다. 하지만 직렬화가 가능한 인스턴스 통제 클래스를 작성해야 하는데, 컴파일 타임에 어떤 인스턴스들이 있는지 알 수 없는 상황이라면 열거 타입으로 표현하는 것이 불가능하기 때문에 <code class="language-plaintext highlighter-rouge">readResolve</code>를 써야 합니다. 이때 메서드의 접근성이 중요합니다. 만약 <code class="language-plaintext highlighter-rouge">final</code> 클래스라면 <code class="language-plaintext highlighter-rouge">readResolve</code> 메서드는 <code class="language-plaintext highlighter-rouge">private</code>가 되어야 합니다. <code class="language-plaintext highlighter-rouge">final</code>이 아닌 클래스라면 주의해야 합니다. <code class="language-plaintext highlighter-rouge">protected</code>나 <code class="language-plaintext highlighter-rouge">public</code>이면서 하위 클래스에서 재정의하지 않고 사용하면 하위 클래스의 인스턴스를 역직렬화하면서 상위 클래스 인스턴스를 생성하여 <code class="language-plaintext highlighter-rouge">ClassCastException</code>을 일으킬 수 있습니다.</p>

<h2 id="아이템-90-직렬화된-인스턴스-대신-직렬화-프록시-사용을-검토하라">아이템 90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라</h2>

<hr />

<p>직렬화 프록시 패턴을 이용하면 직렬화로 인한 버그나 보안 문제를 크게 해결할 수 있습니다. 직렬화 프록시 패턴의 적용은 간단합니다. 바깥 클래스의 논리적 상태를 정밀하게 표현하는 중첩 클래스를 설계하여 <code class="language-plaintext highlighter-rouge">private static</code>으로 선언합니다. 이 클래스가 바깥 클래스의 직렬화 프록시입니다. 중첩 클래스의 생성자는 단 하나여야 하며, 바깥 클래스를 매개변수로 받고, 생성자에서는 단순히 인스턴스 데이터의 복사만 수행합니다.(일관성 검사, 방어적 복사 불필요)</p>

<p>앞에서 살펴본 <code class="language-plaintext highlighter-rouge">Period</code> 클래스를 예로 살펴보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SerializationProxy</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Date</span> <span class="n">start</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Date</span> <span class="n">end</span><span class="o">;</span>

  <span class="nc">SerializationProxy</span><span class="o">(</span><span class="nc">Period</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">start</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">start</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">end</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">end</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">234098243823485285L</span><span class="o">;</span> <span class="c1">// 아무 값이나 상관없다.</span>
<span class="o">}</span>
</code></pre></div></div>

<p>그리고 바깥 클래스에 다음의 <code class="language-plaintext highlighter-rouge">writeReplace</code> 메서드를 추가합니다. 이 메서드는 범용적이기 때문에 직렬화 프록시를 사용하는 모든 클래스에 그대로 사용하면 됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">Object</span> <span class="nf">writeReplace</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nf">SerializationProxy</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 메서드를 정의해두면 자바 직렬화시스템이 바깥 클래스의 인스턴스 대신 <code class="language-plaintext highlighter-rouge">SerializationProxy</code>의 인스턴스를 반환하게 합니다. 즉, 직렬화가 이루어지기 전에 바깥 클래스의 인스턴스를 직렬화 프록시로 변환해줍니다. 이 덕분에 직렬화 시스템은 절대로 바깥 클래스의 직렬화된 인스턴스를 생성할 수 없습니다. 하지만 공격자가 불변식 훼손 시도를 할 수 있기 때문에 다음의 <code class="language-plaintext highlighter-rouge">readObject</code> 메서드를 바깥 클래스에 추가하면 가볍게 막을 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">readObject</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">s</span><span class="o">)</span> <span class="n">thorws</span> <span class="nc">InvalidObjectException</span> <span class="o">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidObjectException</span><span class="o">(</span><span class="s">"프록시가 필요합니다."</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>마지막으로 바깥 클래스와 논리적으로 동일한 인스턴스를 반환하는 <code class="language-plaintext highlighter-rouge">readResolve</code> 메서드를 <code class="language-plaintext highlighter-rouge">SerializationProxy</code> 클래스에 추가합니다. 이 메서드를 통해서 역직렬화 시에 직렬화 시스템이 직렬화 프록시를 다시 바깥 클래스의 인스턴스로 변환하게 해줍니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">Object</span> <span class="nf">readResolve</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nf">Period</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span> <span class="c1">// public 생성자 사용</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">readResolve</code> 메서드는 공개된 API만 사용해서 인스턴스를 생성합니다. 이 패턴이 아름다운 이유는 직렬화로 인스턴스를 생성하면서도 공개된 생성자, 정적 팩터리 같은 일반적인 방식으로 역직렬화된 인스턴스를 만들어내기 때문입니다. 이미 생성자에서 불변식 검사를 하기 때문에 역직렬화된 인스턴스가 해당 클래스의 불변식을 만족하는지 별도로 검사할 필요도 없습니다. 즉 직렬화 프록시 패턴은 가짜 바이트 스트림 공격과 내부 필드 탈취 공격을 프록시 수준에서 차단해주게 됩니다.
그리고 앞선 두 접근법과 달리 <code class="language-plaintext highlighter-rouge">Period</code> 필드를 <code class="language-plaintext highlighter-rouge">final</code>로 선언해도 되기 때문에 <code class="language-plaintext highlighter-rouge">Period</code> 클래스를 진정한 불변으로 만들 수도 있습니다.</p>

<p>하지만 직렬화 프록시 패턴도 한계는 있습니다.</p>

<ol>
  <li>클라이언트가 멋대로 확장할 수 있는 클래스에는 적용할 수 없다.</li>
  <li>객체 그래프에 순환이 있는 클래스에도 적용할 수 없다.
이런 객체의 메서드를 직렬화 프록시의 <code class="language-plaintext highlighter-rouge">readResolve</code> 안에서 호출하려면 <code class="language-plaintext highlighter-rouge">ClassCastException</code>이 발생할 것입니다. 직렬화 프록시만 가졌을 뿐, 실제 객체는 아직 만들어진 것이 아니기 때문입니다.</li>
  <li>방어적 복사보다 느리다.</li>
</ol>

    
  </section>

  <!-- Social media shares -->
  

<div class="share-buttons">
    <ul class="share-buttons">
        <div class="meta">Share</div>
        
        <li>
            <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fanstn1993.github.io%2F2021%2F08%2F18%2F%25EC%259D%25B4%25ED%258E%2599%25ED%258B%25B0%25EB%25B8%258C-%25EC%259E%2590%25EB%25B0%2594-12%25EC%259E%25A5.html" target="_blank" title=" Facebook">
			<i class="fa fa-facebook-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Share on Facebook</span>
		</a>
        </li>
         
        <li>
            <a href="https://twitter.com/intent/tweet?text=%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94+-+12%EC%9E%A5.+%EC%A7%81%EB%A0%AC%ED%99%94%20https%3A%2F%2Fanstn1993.github.io%2F2021%2F08%2F18%2F%25EC%259D%25B4%25ED%258E%2599%25ED%258B%25B0%25EB%25B8%258C-%25EC%259E%2590%25EB%25B0%2594-12%25EC%259E%25A5.html" target="_blank" title="">
			<i class="fa fa-twitter-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Tweet</span>
		</a>
        </li>
            
        <li>
            <a href="http://www.reddit.com/submit?url=https://anstn1993.github.io/2021/08/18/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-12%EC%9E%A5.html&title=%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94+-+12%EC%9E%A5.+%EC%A7%81%EB%A0%AC%ED%99%94%20%7C%20MunSooKim%27s+devlog" target="_blank" title=" Reddit">
			<i class="fa fa-reddit-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Share on Reddit</span>
		</a>
        </li>
           
        <li>
            <a href="mailto:?subject=%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94+-+12%EC%9E%A5.+%EC%A7%81%EB%A0%AC%ED%99%94%20%7C%20MunSooKim%27s+devlog&body=:%20https://anstn1993.github.io/2021/08/18/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-12%EC%9E%A5.html" target="_blank" title="">
			<i class="fa fa-envelope-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Email</span>
		</a>
        </li>
        
    </ul>
</div>




   <!-- Tag list -->
  
  


<footer>
  <div class="tag-list">
    
      <div class="meta">Tags</div>
    

    
    <a class="button" href="/tags#%EA%B8%B0%EC%88%A0">
      <p><i class="fa fa-tag fa-fw"></i> 기술</p>
    </a>
    
    <a class="button" href="/tags#%EC%9E%90%EB%B0%94">
      <p><i class="fa fa-tag fa-fw"></i> 자바</p>
    </a>
    
  </div>
</footer>


</article>

<!-- Disqus -->

<div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname = 'https-anstn1993-github-io';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view comments.</noscript>
</div>


<!-- Post navigation -->

  <div id="post-nav">
    
    <div id="previous-post">
        <a alt="실용주의 프로그래머 1장" href="/2021/11/17/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-1%EC%9E%A5.html">
            <p>Previous post</p>
            실용주의 프로그래머 1장
        </a>
    </div>
    

    
    <div id="next-post">
        <a alt="이펙티브자바 - 11장. 동시성" href="/2021/08/11/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-11%EC%9E%A5.html">
            <p>Next post</p>
            이펙티브자바 - 11장. 동시성
        </a>
    </div>
    
</div>



<!-- To change color of links in the page -->
<style>
  
  .feature-image a { color: brown !important; }
  div#post-nav a { color: brown !important; }
  footer a { color: brown !important; }
  .site-header nav a:hover {  color: brown !important; }
  header#main { background-color: brown !important; }
  

  header#main {
    background-repeat:no-repeat;
  background-image: url('/assets/img/lineart.png');  
  }
</style>

    </div>
    <footer class="site-footer">
    <p class="text">
         </p>
            <div class="footer-icons">
                <ul>
                <!-- Social icons from Font Awesome, if enabled -->
                


<li>
    <a href="mailto:anstn1993@gmail.com" title="Email">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
        </span>
    </a>
</li>













<li>
    <a href="https://github.com/anstn1993" title="Follow on GitHub">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-github fa-stack-1x fa-inverse"></i>
        </span>
    </a>
</li>
































                </ul>
            </div>
</footer>



  </body>
</html>
