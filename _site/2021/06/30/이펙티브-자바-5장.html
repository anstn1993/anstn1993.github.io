<!DOCTYPE html>
<!--
    Type on Strap jekyll theme v2.3.0
    Copyright 2016-2020 Sylhare
    Theme free for personal and commercial use under the MIT license
    https://github.com/sylhare/Type-on-Strap/blob/master/LICENSE
-->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!-- Main JS (navbar.js, katex_init.js and masonry_init.js)-->
    <script defer src="/assets/js/main.min.js"></script>
    
    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <!--Favicon-->
    <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

    <!-- RSS -->
    <link rel="alternate" type="application/atom+xml" title="MunSooKim's devlog" href="https://anstn1993.github.io/feed.xml"/>
    
    

    <!-- KaTeX 0.12.0 -->
    
    <script defer src="/assets/js/vendor/katex.min.js"></script>
    <script defer src="/assets/js/vendor/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
    

    <!-- Mermaid 8.8.2 -->
    
    <!-- <script src=”https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.8.2/mermaid.min.js" onload="mermaid.initialize({startOnLoad:true});"></script> -->
    <script defer src="/assets/js/vendor/mermaid.min.js" onload="mermaid.initialize({startOnLoad:true});"></script>
    

    <!-- Simple-Jekyll-Search 1.17.12 -->
    <script src="/assets/js/vendor/simple-jekyll-search.min.js" type="text/javascript"></script>

    <!-- Google Analytics / Cookie Consent -->
    <script>
      const cookieName = 'cookie-notice-dismissed-https://anstn1993.github.io';
      const isCookieConsent = 'false';
      const analyticsName = '';
    </script>

    
    

    <!-- seo tags -->
    <meta property="og:image" content="https://anstn1993.github.io/assets/img/pexels/triangular.jpeg">
    
    <meta property="og:type" content="website" />
    
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>이펙티브자바 - 5장. 제네릭 | MunSooKim’s devlog</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="이펙티브자바 - 5장. 제네릭" />
<meta name="author" content="Mun Soo Kim" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다." />
<meta property="og:description" content="조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다." />
<link rel="canonical" href="https://anstn1993.github.io/2021/06/30/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-5%EC%9E%A5.html" />
<meta property="og:url" content="https://anstn1993.github.io/2021/06/30/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-5%EC%9E%A5.html" />
<meta property="og:site_name" content="MunSooKim’s devlog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-06-30T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="이펙티브자바 - 5장. 제네릭" />
<script type="application/ld+json">
{"description":"조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.","mainEntityOfPage":{"@type":"WebPage","@id":"https://anstn1993.github.io/2021/06/30/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-5%EC%9E%A5.html"},"datePublished":"2021-06-30T00:00:00+09:00","url":"https://anstn1993.github.io/2021/06/30/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-5%EC%9E%A5.html","author":{"@type":"Person","name":"Mun Soo Kim"},"headline":"이펙티브자바 - 5장. 제네릭","@type":"BlogPosting","dateModified":"2021-06-30T00:00:00+09:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <!-- RSS -->
    <link type="application/atom+xml" rel="alternate" href="https://anstn1993.github.io/feed.xml" title="MunSooKim&apos;s devlog" />

    <!-- Twitter Cards -->
    <meta name="twitter:title" content="이펙티브자바 - 5장. 제네릭">
    <meta name="twitter:description" content="조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.5장. 제네릭자바 5부터 사용 가능한 제니릭은 클래스나 인터페이스의 타입 매개변수를 통해서 런타임에서 발생해오던 형변환 에러를 컴파일 타임에 잡아낼 수 있게 해줍니다. 주로 컬렉션의 원소로 담을 수 있...">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:image" content="https://anstn1993.github.io/assets/img/pexels/triangular.jpeg">
    <meta name="twitter:image:alt" content="이펙티브자바 - 5장. 제네릭">
</head>

  <body>
    <header class="site-header">

    <!-- Logo and title -->
	<div class="branding">
        
		<a href="/">
			<img alt="logo img" class="avatar" src="/assets/img/triangle.png" />
		</a>
        
        <a class="site-title" aria-label="MunSooKim's devlog" href="/">
        MunSooKim's devlog
		</a>
	</div>

    <!-- Toggle menu -->
    <nav class="clear">
    <a aria-label="pull" id="pull" class="toggle" href="#">
    <i class="fa fa-bars fa-lg"></i>
    </a>

    <!-- Menu -->
    <ul class="hide">
        

        
            
            
        
            
            <li class="separator"> | </li>
            <li>
                <a class="clear" aria-label="About" title="About" href="/about">
                     About 
                </a>
            </li>
            
            
        
            
            
        
            
            
        
            
            
        
            
            <li class="separator"> | </li>
            <li>
                <a class="clear" aria-label="Search" title="Search" href="/search">
                     <i class="fa fa-search" aria-hidden="true"></i>
                    
                </a>
            </li>
            
            
        
            
            <li class="separator"> | </li>
            <li>
                <a class="clear" aria-label="Tags" title="Tags" href="/tags">
                     <i class="fa fa-tags" aria-hidden="true"></i>
                    
                </a>
            </li>
            
            
        
            
            
        
            
            
        
            
            
        
    </ul>

	</nav>
</header>

    <div class="content">
      <article class="feature-image" >
  <header id="main" style="">
    <div class="title-padder">
      
      <h1 id="%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94+-+5%EC%9E%A5.+%EC%A0%9C%EB%84%A4%EB%A6%AD" class="title">이펙티브자바 - 5장. 제네릭</h1>
      


<div class="post-info">
    <p class="meta">
      June 30, 2021
    </p></div>

      
    </div>
  </header>

  <section class="post-content">
  
      <p>조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.</p>

<h1 id="5장-제네릭">5장. 제네릭</h1>

<p>자바 5부터 사용 가능한 제니릭은 클래스나 인터페이스의 타입 매개변수를 통해서 런타임에서 발생해오던 형변환 에러를 컴파일 타임에 잡아낼 수 있게 해줍니다. 주로 컬렉션의 원소로 담을 수 있는 타입을 명시하는 용도로 많이 사용합니다.</p>

<h2 id="아이템-26-로-타입은-사용하지-말라">아이템 26. 로 타입은 사용하지 말라</h2>

<hr />

<p>클래스와 인터페이스 선언에 타입 매개변수가 쓰이면 그것을 제네릭 클래스, 제네릭 인터페이스라고 합니다. 제네릭 타입을 하나 정의하면 로 타입도 함께 정의됩니다. 로 타입은 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 의미합니다. 가령 List&#60;E&#62;의 로 타입은 List가 됩니다. 이 로 타입을 사용하면 마치 제네릭 타입 정보가 모두 지워진 것처럼 동작하는데 이는 제네릭이 지원되지 이전 버전들과의 호환성을 위한 궁여지책입니다. 하지만 제네릭이 지원되는 버전에서는 제네릭 타입을 사용할 수 있으면 사용하는 것이 좋습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Stamp 인스턴스만 취급한다.</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Collection</span> <span class="n">stamps</span> <span class="o">=</span> <span class="o">...;</span>
</code></pre></div></div>

<p>stamsp는 Stamp 타입만 원소로 받는 역할을 하지만 그 어떤 타입도 다 넣을 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">stamps</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Coin</span><span class="o">());</span>
</code></pre></div></div>

<p>이렇게 Coin을 넣어도 컴파일 타임에는 아무 문제가 없다가 런타임에서 Coin을 꺼내려고 할 때가 되어서야 ClassCastException이 발생합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">for</span> <span class="o">(</span><span class="nc">Iterable</span> <span class="n">i</span> <span class="o">=</span> <span class="n">stamps</span><span class="o">.</span><span class="na">iterable</span><span class="o">;</span> <span class="n">i</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
    <span class="nc">Stamp</span> <span class="n">stamp</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Stamp</span><span class="o">)</span> <span class="n">i</span><span class="o">.</span><span class="na">next</span><span class="o">();</span><span class="c1">// ClassCastException</span>
    <span class="n">stamp</span><span class="o">.</span><span class="na">cancel</span><span class="o">();</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>제네릭을 활용하면 컴파일타임에 이런 오류를 잡아낼 수 있습니다. 그리고 컴파일러는 컬렉션에서 원소를 꺼내는 모든 곳에 암묵적 형변환을 추가해서 절대 실패하지 않음을 보장합니다.</p>

<p>앞서 말했던 로 타입의 지원 이유는 이전 버전들과의 호환성 때문입니다. 그렇다면 List 같은 로 타입과 List&#60;Object&#62;의 차이는 무엇일까요? 전자는 제네릭에서 완전히 발을 뺀다는 것이고 후자는 모든 타입을 허용하겠다는 것을 컴파일러에게 명확하게 전달하는 것입니다. 만약 매개변수로 List 로 타입을 받으면 List&#60;String&#62;을 넘길 수 있지만 List&#60;Object&#62;를 받는 메서드에는 넘길 수 없습니다. 여기서 알 수 있는 점은 List&#60;String&#62;은 로 타입의 하위 타입이 되지만 List&#60;Object&#62;의 하위 타입은 아닙니다.(불공변) 그래서 <strong>로 타입을 사용하면 그냥 아무 제네릭 타입이 다 들어갈 수 있게 되고 타입 안전성을 잃게 됩니다.</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">unsafeAdd</span><span class="o">(</span><span class="nc">List</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="o">...</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">strings</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">unsafeAdd</span><span class="o">(</span><span class="n">strings</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">42</span><span class="o">));</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">strings</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>위 코드는 런타임에 ClassCastException이 발생합니다. unsafeAdd() 메서드의 List를 로 타입이 아닌 List&#60;Object&#62;로 바꾸면 컴파일조차 되지 않습니다. strings의 타입이 List&#60;String&#62;이고 List&#60;Object&#62;의 하위 타입이 아니기 때문입니다.</p>

<p>만약 제네릭 타입을 쓰고 싶긴 하지만 실제 타입 매개변수가 무엇인지는 신경쓰고 싶지 않을 때는 비한정적 와일드카드(?)를 사용하면 됩니다. 가령 제네릭 타입인 Set&#60;E&#62;의 비한정적 와일드카드 타입은 Set&#60;?&#62;입니다. 비한정적 와일드카드 타입을 사용하면 컬렉션에 null 이외에는 어떠한 원소도 넣을 수 없습니다. 또한 꺼낼 수 있는 객체의 타입도 전혀 알 수 없게 됩니다. 만약 이런 제약을 받아들이기 힘들면 제네릭 메서드나 한정적 와일드카드 타입을 사용하면 됩니다.</p>

<h3 id="예외">예외</h3>

<p>로 타입을 사용할 수 있는 예외 상황이 존재합니다.</p>

<ul>
  <li>
    <p>class 리터럴에는 로 타입을 써야 한다.
자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했습니다. 가령 List.class, String[].class, int.class는 허용하지만 List&#60;String&#62;.class, List&#60;?&#62;.class는 허용하지 않습니다.</p>
  </li>
  <li>
    <p>instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없고, 비한정적 와일드카드 타입이나 로 타입이나 instanceof에서는 완전 동일하게 동작하기 때문에 차라리 로 타입을 써라.
제네릭에 대한 정보는 런타임이 되면 완전히 사라지게 됩니다. 즉 컴파일타임에 컴파일러에게 유의미한 정보 전달을 위해서 제네릭이 존재하는 것이기 때문에 차라리 로 타입을 쓰는 것이 깔끔합니다.</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span><span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Set</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Set</span><span class="o">&lt;?&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Set</span><span class="o">&lt;?&gt;)</span> <span class="n">o</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="아이템-27-비검사-경고를-제거하라">아이템 27. 비검사 경고를 제거하라</h2>

<hr />

<p>제네릭을 잘못 사용하면 컴파일러가 수많은 경고를 보내게 됩니다. 비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등이 있는데 이런 경고는 사실 고마운 존재들 입니다. 이 경고들만 해결하면 코드의 타입 안전성이 보장되는 것이니까요.</p>

<h3 id="suppresswarningsunchecked">@SuppressWarnings(“unchecked”)</h3>

<p>만약 타입 안전하다고 확신할 수 있는 상황인데 경고 제거가 불가능한 상황이라면 @SuppressWarnings(“unchecked”) 애너테이션을 사용해서 경고를 숨길 수 있습니다. 이런 조치가 필요한 이유는 안전하다는 것이 검증된 경고를 숨기지 않고 두면 진짜 문제를 알리는 중요한 경고를 놓칠 수 있기 때문입니다.</p>

<p>이 애너테이션은 개별 지역변수부터 클래스 레벨까지 어떤 선언에도 달 수 있습니다. 하지만 가능한한 좁은 범위에 적용하는 것이 좋습니다. 보통은 지역 변수, 아주 짧은 메서드, 생성자에 붙이는 것이 좋습니다. 클래스에 적용을 해버리면 그 클래스에 대해 발생하는 모든 경고를 숨기기 때문에 심각한 경고를 놓치는 위험이 있습니다.</p>

<p>한 줄이 넘는 메서드나 생성자에 달린 @SuppressWarnings 애너테이션이 있으면 지역변수 선언 쪽으로 옮기는 것이 좋습니다.</p>

<p>마지막으로 @SuppressWarnings(“unchecked”) 애너테이션을 사용했다면 그 경고를 무시해도 안전한 이유를 주석으로 남겨줘야 합니다. 다른 사람이 그 의도를 이해하는 데 도움이 되고, 코드를 잘못 수정해서 타입 안전성을 잃는 상황을 줄여줍니다.</p>

<h2 id="아이템-28-배열보다는-리스트를-사용하라">아이템 28. 배열보다는 리스트를 사용하라</h2>

<hr />

<p>배열과 제네릭 타입에는 중요한 차이가 2개 있습니다.</p>

<ul>
  <li>
    <p>배열은 공변이고 제네릭은 불공변이다.
공변이라는 것은 Sub가 Super의 하위 타입이라면 Sub[]도 Super[]의 하위 타입이라는 의미이고 불공변은 List&#60;Sub&#62;이 List&#60;Super&#62;의 하위 타입도, 상위 타입도 아니라는 것을 의미합니다. 배열의 공변은 아래와 같은 문제를 지닙니다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">Object</span><span class="o">[]</span> <span class="n">objectArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Long</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
  <span class="n">objectArray</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="s">"타입이 달라 넣을 수 없다."</span><span class="o">;</span> <span class="c1">// ArrayStoreException</span>
</code></pre></div>    </div>

    <p>위 코드는 컴파일이 되는 코드 입니다. 왜냐하면 Long[]이 Object[]의 하위 타입이기 때문 입니다. 그런데 배열에 문자열 값을 넣는 순간 런타임 오류가 발생합니다. 즉 컴파일 수준에서 잡아내기 힘듭니다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">ol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;();</span> <span class="c1">// 호환되지 않는 타입</span>
  <span class="n">ol</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"타입이 달라 넣을 수 없다."</span><span class="o">);</span>
</code></pre></div>    </div>

    <p>반면 위 코드는 컴파일 수준에서 바로 문제가 있음을 알 수 있습니다. 당연히 런타임보다 컴파일 타임에 문제를 발견하는 것이 좋습니다.</p>
  </li>
  <li>
    <p>배열은 실체화 타입이지만 리스트는 실체화 불가 타입이다.
바로 위에서 살펴본 내용 입니다. 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인하기 때문에 Long배열에 String을 넣으려고 하면 런타임에 ArrayStoreException을 던지게 됩니다. 반면 제네릭은 타입 정보가 런타임에 사라지기 때문에 원소의 타입을 런타임에 알 수 없습니다. 즉, 실체화되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가집니다. 이처럼 소거 메커니즘 때문에 매개변수화 타입 가운데 실체화가 가능한 타입은 List&#60;?&#62;와 Map&#60;?, ?&#62; 뿐입니다.</p>
  </li>
</ul>

<p>위의 두 차이 때문에 제네릭과 배열은 잘 어울리지 못합니다. 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없습니다. 즉 new List&#60;E&#62;[], new List&#60;String&#62;[], new E[] 와 같이 작성하면 컴파일 오류가 발생합니다. 제네릭 배열을 허용하면 타입 안전하지 않습니다. 런타임에 ClassCastException을 막기 위해서 등장한 것이 제네릭인데 무용지물이 되기 때문입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">stringLists</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// (1)</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">intList</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">42</span><span class="o">);</span> <span class="c1">// (2)</span>
  <span class="nc">Object</span><span class="o">[]</span> <span class="n">objects</span> <span class="o">=</span> <span class="n">stringLists</span><span class="o">;</span> <span class="c1">// (3)</span>
  <span class="n">objects</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">intList</span><span class="o">;</span> <span class="c1">// (4)</span>
  <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">stringLists</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// (5)</span>
</code></pre></div></div>

<p>위의 코드에서 (1)이 허용된다고 가정해보겠습니다. (3)에서 배열은 공변이기 때문에 List&#60;String&#62;[]은 Object[]의 하위 타입이 되기 때문에 대입이 가능합니다. 그리고 (4)에서도 런타임시 제네릭은 소거되기 때문에 objects의 원소로 intList가 들어갈 수 있습니다. 이렇게 되면 (5)에서 stringLists[0].get(0)은 정수 42가 되는데 String타입으로 형변환을 하게 되어 ClassCastException이 발생합니다. 이런 문제를 방지해야하기 때문에 (1)에서 컴파일 오류를 내는 것입니다.</p>

<p>배열을 제네릭 타입으로 만들 수 없어서 귀찮은 순간도 있습니다. 제네릭 컬렉션에서는 자신의 원소 타입을 담은 배열을 반환하는 것이 보통 불가능합니다. 또한 제네릭 타입과 가변인수 메서드를 함께 쓸 때 가변인수 매개변수를 담는 배열의 원소가 실체화 불가 타입이라면 경고가 발생할 것입니다. 이 문제는 @SafeVarargs 애너테이션으로 대처할 수 있습니다.</p>

<p>배열로 형변환할 때 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는 경우 대부분 배열인 E[] 대신 컬렉션인 List&#60;E&#62;를 사용하면 해결됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Chooser</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">choiceArray</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Chooser</span><span class="o">(</span><span class="nc">Collection</span> <span class="n">choices</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">choiceArray</span> <span class="o">=</span> <span class="n">choices</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">choose</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">Random</span> <span class="n">rnd</span> <span class="o">=</span> <span class="nc">ThreadLocalRandom</span><span class="o">.</span><span class="na">current</span><span class="o">();</span>
      <span class="k">return</span> <span class="n">choiceArray</span><span class="o">[</span><span class="n">rnd</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">choiceArray</span><span class="o">.</span><span class="na">length</span><span class="o">)];</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>위 클래스는 컬렉션 안의 원소 중 하나를 무작위로 반환하는 choose() 메서드를 제공합니다. 그런데 반환 타입이 Object이기 때문에 호출한 쪽에서 반환된 값을 원하는 타입으로 변환해서 사용해야 합니다. 그런데 만약 원하는 타입과 다른 타입이 들어있기라도 한다면 형변환 오류가 발생합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Chooser</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="no">T</span><span class="o">[]</span> <span class="n">choiceArray</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Chooser</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">choices</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">choiceArray</span> <span class="o">=</span> <span class="o">(</span><span class="no">T</span><span class="o">[])</span> <span class="n">choices</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// choose 메서드는 그대로</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>제네릭을 적용한 버전 입니다. 그런데 생성자 코드에서 T[] 타입으로 형변환을 해주는데 그 이유는 컬렉션은 비실체화 타입이라서 런타임에는 choices의 원소 타입을 알 수 없기 때문에 명시적으로 형변환을 해주는 것입니다. 그러나 이 자체는 컴파일러가 안전을 보장하지 못합니다. 그래서 비검사 형변환 경고가 뜨는데 이는 앞서 살펴봤던 애너테이션을 달고 안전한 이유를 주석으로 남김면 됩니다. 만약 경고를 숨기지 않고 제거하고 싶다면 배열 대신 리스트를 쓰면 됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Chooser</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">choiceList</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">Chooser</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">choices</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">choiceList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">choices</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="no">T</span> <span class="nf">choose</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">Random</span> <span class="n">rnd</span> <span class="o">=</span> <span class="nc">ThreadLocalRandom</span><span class="o">.</span><span class="na">current</span><span class="o">();</span>
      <span class="k">return</span> <span class="n">choiceList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">rnd</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">choiceList</span><span class="o">.</span><span class="na">size</span><span class="o">()));</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="아이템-29-이왕이면-제네릭-타입으로-만들라">아이템 29. 이왕이면 제네릭 타입으로 만들라</h2>

<hr />

<p>어떤 클래스를 제네릭으로 만들지 않으면 그 클래스의 클라이언트는 형변환을 해야 합니다. 그러나 이는 런타임 오류의 위험성을 내포하게 되는 것이고 그것보단 컴파일 타임에 오류를 잡아낼 수 있고, 형변환도 할 필요가 없는 제네릭으로 만드는 것이 좋습니다. 기존 타입 중에 제네릭이었어야 하는 타입이 있다면 제네릭으로 변경해주는 것이 좋습니다. <a href="https://anstn1993.github.io/2021/06/09/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-2%EC%9E%A5.html">아이템 7</a>에서 다루었던 Stack 클래스 코드를 제네릭으로 변경해보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">E</span><span class="o">[]</span> <span class="n">elements</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">16</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Stack</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">elements</span> <span class="o">=</span> <span class="k">new</span> <span class="no">E</span><span class="o">[</span><span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">ensureCapacity</span><span class="o">();</span>
      <span class="n">elements</span><span class="o">[</span><span class="n">size</span><span class="o">++]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="no">E</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">EmptyStackException</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="no">E</span> <span class="n">result</span> <span class="o">=</span> <span class="n">elements</span><span class="o">[--</span><span class="n">size</span><span class="o">];</span>
      <span class="n">elements</span><span class="o">[</span><span class="n">size</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 다 쓴 객체 참조 해제</span>
      <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// isEnpty, ensureCapacity 메서드는 그대로</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>위와 같이 코드를 작성하면 오류가 하나 발생합니다. 바로 생성자에서 E 타입으로 배열을 초기화하는 코드인데요. 아이템 28에서 살펴봤듯이 E와 같은 실체화 불가 타입으로는 배열을 만들 수 없기 때문입니다. 이런 문제를 우회하는 방법이 두 가지 있습니다.</p>

<ul>
  <li>
    <p>elements를 Object[]로 초기화</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">...</span>
  <span class="c1">// 생성자</span>
  <span class="kd">public</span> <span class="nf">Stack</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">elements</span> <span class="o">=</span> <span class="o">(</span><span class="no">E</span><span class="o">[])</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">];</span>
  <span class="o">}</span>
  <span class="o">...</span>
</code></pre></div>    </div>

    <p>초기화를 Object[]로 하고 제네릭 타입 매열로 형변환을 하는 방식입니다. 이렇게 하면 컴파일러는 이제 오류 대신 경고를 내보냅니다. 런타임이 되면 제네릭 정보는 지워지게 되고 그렇게 되면 비검사 형변환이 일어나는 꼴이라서 안전성을 해치기 때문입니다. 하지만 코드의 작성자는 push 메서드가 무조건 E타입의 원소만 매개변수로 받고 elements 참조를 다른 메서드로 전달하거나 클라이언트로 반환하지 않기 때문에 타입 안전하다는 것을 알고 있습니다. 그러니까 그냥 @SuppressWarnings 애너테이션으로 경고를 숨기면 됩니다.</p>
  </li>
  <li>
    <p>elements 필드의 타입 자체를 Object[]로 변경</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">...</span>
  <span class="kd">private</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">elements</span><span class="o">;</span>
  <span class="o">...</span>
  <span class="c1">// 생성자</span>
  <span class="kd">public</span> <span class="nf">Stack</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">elements</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">];</span>
  <span class="o">}</span>
</code></pre></div>    </div>
    <p>위와 같이 elements의 타입 자체를 Object[]로 바꾸면 첫번째와 달리 pop() 메서드에서 원소를 E타입으로 꺼내는 코드에서 오류가 발생합니다. 이번에도 마찬가지로 E 타입으로 형변환을 해주면 오류는 사라지고 경고만 발생합니다.</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="no">E</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="no">E</span><span class="o">)</span> <span class="n">elements</span><span class="o">[--</span><span class="n">size</span><span class="o">];</span>
</code></pre></div>    </div>
    <p>이번에도 elemetns의 원소는 E 타입이라는 것을 컴파일러는 모르지만 코드 작성자는 확신할 수 있기 때문에 경고를 숨기면 됩니다.</p>
  </li>
</ul>

<p>위의 두 방법 모두 나름의 지지를 받지만 보통 첫번째 방법을 많이 사용합니다. 왜냐하면 배열의 타입 자체가 E[]가 되기 때문에 E 타입만 받는 배열이라는 것을 확실하게 보여주고 배열의 원소에 접근하는 코드가 클래스 내부에 많을텐데 그때마다 형변환을 해주지 않아도 되기에 코드의 양도 줄어듭니다. 반면 두번째 방법은 타입이 Object[]이기 때문에 원소에 접근할 때마다 형변환을 해줘야 합니다. 하지만 첫번째 방식은 런타임 타입과 컴파일 타임의 타입이 달라서 힙 오염이 생기기 때문에 힘 오엽을 피하기 위해서 두번째 방식을 고수하기도 합니다.</p>

<h2 id="아이템-30-이왕이면-제네릭-메서드로-만들라">아이템 30. 이왕이면 제네릭 메서드로 만들라</h2>

<hr />

<p>클래스와 마찬가지로 메서드도 제네릭으로 만들 수 있습니다. 매개변수화 타입을 받는 정적 유틸리티 메서드는 보통 제네릭입니다. 가령 Collections의 binarySearch, sort 등의 메서드는 모두 제네릭입니다. 메서드의 매개변수와 반환 값을 형변환하는 것보단 제네릭으로 만들어서 안전성을 높이는 것이 좋습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">int</span>	<span class="nf">binarySearch</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="no">T</span> <span class="n">key</span><span class="o">)</span>
<span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;&gt;</span> <span class="kt">void</span>	<span class="nf">sort</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span>
</code></pre></div></div>

<p>메서드 시그니처를 보면 메서드의 인자로는 모두 매개변수화 타입이 들어갑니다. 타입 매개변수 목록은 메서드의 접근 제어자와 반환 타입 사이에 오게 됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 매개변수로 전달된 두 집합의 합집합 반환 메서드</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">union</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="n">s1</span><span class="o">);</span>
  <span class="n">result</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
<span class="o">...</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">guys</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"톰"</span><span class="o">,</span> <span class="s">"딕"</span><span class="o">,</span> <span class="s">"해리"</span><span class="o">);</span>
  <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stooges</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"래리"</span><span class="o">,</span> <span class="s">"모에"</span><span class="o">,</span> <span class="s">"컬리"</span><span class="o">);</span>
  <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">aflCio</span> <span class="o">=</span> <span class="n">union</span><span class="o">(</span><span class="n">guys</span><span class="o">,</span> <span class="n">stooges</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">aflCio</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위와 같이 작성을 하면 어떠한 경고도 출력되지 않고 잘 동작합니다. union 메서드의 집합 3개(입력 2개, 반환 1개)는 모두 같은 타입이 되어야 함을 컴파일 타임에 강제하게 됩니다. 만약 한정적 와일드카드 타입(extends)를 사용하면 더 유연하게 타입을 받도록 개선도 가능합니다.</p>

<p>불변 객체를 여러 타입으로 활용할 수 있게 만들 수도 있습니다. 요청한 타입 매개변수에 맞게 매번 그 객체의 타입을 바꿔주는 정적 팩토리가 필요한데 이를 제네릭 싱글턴 팩토리라고 합니다. Collections.reverseOrder(), Collections.emptySet() 메서드가 대표적입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">reverseOrder</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="nc">Comparator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;)</span> <span class="nc">ReverseComparator</span><span class="o">.</span><span class="na">REVERSE_ORDER</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">emptySet</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="nc">Set</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;)</span> <span class="no">EMPTY_SET</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>타입 매개변수를 무엇으로 설정하냐에 따라서 그 매개변수화 타입으로 형변환을 해서 반환을 해주게 됩니다. 제네릭 메서드로 만들어서 런타임 오류가 발생하지 않음을 알 수 있기 때문에 비검사 형변환 경고를 숨기고 있습니다.</p>

<p>상대적으로 드물긴 하지만 자기 자신이 들어간 표현식을 사용해서 타입 매개변수의 허용 범위를 한정할 수도 있습니다. 가장 대표적으로 쓰이는 케이스가 바로 Comparable 입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Copmparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="no">T</span> <span class="n">o</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>타입 매개변수 T는 Comparable&#60;T&#62;를 구현한 타입이 비교할 수 있는 원소의 타입을 정의합니다. 즉 거의 모든 타입은 자신과 같은 타입의 원소와만 비교할 수 있습니다. 그럼 Comparable을 구현한 원소의 컬렉션을 입력받는 메서드들은 주로 그 원소들을 정렬하고 검색하거나 최소, 최대값을 구하는 식으로 활용할 것이기 때문에 원소 타입을 Comparable을 구현한 타입으로 제약하기 위해서 아래와 같이 만들 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;&gt;</span> <span class="no">E</span> <span class="nf">max</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">);</span>
</code></pre></div></div>

<p>이렇게 되면 모든 타입 E는 자기 자신과의 비교가 가능하다는 것이 보장됩니다.</p>

<h2 id="아이템-31-한정적-와일드카드를-사용해-api-유연성을-높이라">아이템 31. 한정적 와일드카드를 사용해 API 유연성을 높이라</h2>

<hr />

<p>한정적 와일드카드 타입을 사용하면 매개변수화 타입이 불공변이라서 발생하는 불편함을 해결할 수 있습니다. Stack의 다음의 메서드가 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">pushAll</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="no">E</span> <span class="n">e</span> <span class="o">:</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">push</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>클라이언트에서는 위 메서드를 다음과 같이 사용했습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numberStack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
<span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integers</span> <span class="o">=</span> <span class="o">...;</span>
<span class="n">numberStack</span><span class="o">.</span><span class="na">pushAll</span><span class="o">(</span><span class="n">integers</span><span class="o">);</span>
</code></pre></div></div>

<p>위의 코드는 Number의 하위 타입이 Integer니까 논리적으로는 가능해보이지만 매개변수화 타입은 불공변이기 때문에 오류가 발생합니다. pushAll 메서드의 매개변수화 타입을 비한정적 와일드카드 타입으로 바꿔보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">pushAll</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="no">E</span> <span class="n">e</span> <span class="o">:</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">push</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>pushAll의 매개변수는 E의 하위 타입의 Iterable이 됩니다. 이제 클라이언트 코드는 정상적으로 동작하게 됩니다.</p>

<p>다음은 반대로 매개변수로 전달된 컬렉션에 stack의 원소를 모두 전달해주는 popAll 메서드를 작성해보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">popAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">dst</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">while</span><span class="o">(!</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">dst</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pop</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>클라이언트에서는 위 메서드를 다음과 같이 사용했습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numberStack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
<span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">integers</span> <span class="o">=</span> <span class="o">...;</span>
<span class="n">numberStack</span><span class="o">.</span><span class="na">popAll</span><span class="o">(</span><span class="n">integers</span><span class="o">);</span>
</code></pre></div></div>

<p>이 경우도 당연히 안 됩니다. 이번에도 한정적 와일드카드 타입으로 해결할 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">popAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">dst</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">while</span><span class="o">(!</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">dst</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pop</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이번에는 super가 사용됐는데 이 경우에는 E의 상위 타입의 Collection이 되는 됩니다.</p>

<p>비한정적 와일드카드 타입은 유연성을 극대화시켜줍니다. 그리고 extends, super를 쓰는 판단 기준이 존재합니다. 매개변수화 타입이 생산자면 extends를, 소비자면 super를 쓰면 됩니다. 이를 <strong>PECS(Producer - Extends, Consumer - Super)</strong>라고 합니다. Stack의 예에서 pushAll의 매개변수는 Stack의 원소를 채워주는 생산자 역할을 했기 때문에 extends를 쓴 것이고 popAll의 매개변수는 Stack의 원소를 받아서 자신을 채우는 소비자 역할을 했기 때문에 super를 쓴 것입니다. 그런데 만약 매개변수화 타입이 소비자, 생산자 역할을 동시에 한다면 이때는 한정저거 와일드카드 타입을 쓰면 안 되고 타입을 정확히 지정해줘야 합니다.</p>

<p>그렇다면 아이템 30에서 봤던 union 메서드도 다음과 같이 바꿔서 유연성을 높일 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">union</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="n">s1</span><span class="o">);</span>
  <span class="n">result</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
<span class="o">...</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integers</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
  <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">doubles</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mf">2.0</span><span class="o">,</span> <span class="mf">4.0</span><span class="o">,</span> <span class="mf">6.0</span><span class="o">);</span>
  <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">union</span><span class="o">(</span><span class="n">integers</span><span class="o">,</span> <span class="n">doubles</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">numbers</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이번에는 아이템 30의 max 메서드를 수정해 보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">E</span><span class="o">&gt;&gt;</span> <span class="no">E</span> <span class="nf">max</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">);</span>
</code></pre></div></div>

<p>PECS 공식을 두 번 적용했습니다. 먼저 매개변수의 list를 이용해서 E 인스턴스 생성을 하기 때문에 생산자로 보고 extends가 사용됐습니다. 타입 매개변수의 E를 보면 super가 사용됐습니다. 타입 매개변수에 와일드카드가 적용된 첫번째 예시입니다. Comparable&#60;E&#62;는 E 인스턴스를 소비하게 됩니다. 그래서 Comparable의 경우 super를 사용하는 것이 일반적으로 낫습니다. 만약 이렇게 수정하지 않으면 다음 리스트는 max 메서드가 처리하지 못합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">ScheduledFuture</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">scheduledFutures</span> <span class="o">=</span> <span class="o">...;</span>
</code></pre></div></div>

<p>ScheduledFuture는 Comparable&#60;ScheduledFuture&#62;를 구현하고 있지 않고 대신 상위 타입인 Delayed가 구현을 하고 있기 때문입니다. 그런데 만약 수정된 버전으로 사용하게 되면 Comparable&#60;Delayed&#62;를 확장한 Delayed를 확장한 ScheduledFuture를 원소로 가지는 list도 처리를 할 수 있게 됩니다. 다시 말해 Comparable(Comparator)를 직접 구현하지 않고, 직접 구현한 다른 타입을 확장한 타입을 지원하려면 와일드카드가 필요해지는 것입니다.</p>

<p>마지막으로 타입 매개변수와 와일드카드 둘 중 어느 것을 사용해도 괜찮을 때를 살펴보겠습니다. 주어진 리스트에서 명시한 두 인덱스의 온소를 교환하는 정적 메서드를 두 방식으로 정의해보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="nc">LisT</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">);</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swql</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">);</span>
</code></pre></div></div>

<p>이 중에서 public api로 공개되는 경우라면 두번째 방식이 더 좋습니다. swap 메서드처럼 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드 카드로 대체하는 것이 좋습니다. 타입 매개변수가 비한정적 타입이면 비한정적 와일드카드로, 한정적 타입 매개변수면 한정적 와일드카드로 바꾸면 됩니다. 하지만 두번째 방식으로 메서드를 정의하면 컴파일이 되지 않습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)));</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>왜냐하면 List&#60;?&#62; 타입에는 null외에 어떤 값도 넣을 수 없기 때문입니다. 이 문제를 해결하려면 도우미 제네릭 메서드를 만들어서 전달해주면 됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">swapHelper</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">swapHelper</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)));</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>swapHelper 메서드는 리스트가 List&#60;E&#62; 타입인 것을 명확히 알기 때문에 문제 없이 컴파일이 됩니다.</p>

<h2 id="아이템-32-제네릭과-가변인수를-함께-쓸-때는-신중하라">아이템 32. 제네릭과 가변인수를 함께 쓸 때는 신중하라</h2>

<hr />

<p>가변인수 메서드는 가변인수를 담기 위한 배열을 생성하기 때문에 가변인수 메서드의 매개변수로 제네릭이나 매개변수화 타입 들어가게 되면 컴파일 경고가 발생합니다. 왜냐하면 매개변수화 타입이 타입이 다른 객체를 참조해서 힙 오염이 발생할 수 있기 때문입니다. 그렇게 되면 매개변수화 타입으로 자동 형변환을 컴파일러가 해도 런타임에 형변환 실패가 발생할 수 있어서 제네릭을 사용하는 의미가 없어집니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">dangerous</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;...</span> <span class="nc">StringLists</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">intList</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">42</span><span class="o">);</span>
  <span class="nc">Object</span><span class="o">[]</span> <span class="n">objects</span> <span class="o">=</span> <span class="n">stringLists</span><span class="o">;</span>
  <span class="n">objects</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">intList</span><span class="o">;</span> <span class="c1">// 힙 오염</span>
  <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">stringLists</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span><span class="c1">// ClassCastException</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위처럼 배열이 공변이기 때문에 objects에 stringLists가 대입이 가능해지면서 문제가 발생합니다.</p>

<p>그럼 제네릭 배열은 프로그래머가 못 만들게 막았으면서 왜 제네릭 가변인수 매서드는 만들 수 있게 허용했을까요? 그 이유는 그게 실무에서 매우 유용하게 쓰이기 때문입니다. 자바 라이브러리에서도 이를 적극적으로 활용하고 있습니다. Arrays.asList(T… a), Collections.addAll(Collection&lt;? super T&gt; c, T… elements), EnumSet.of(E first, E… rest)갸 대표적입니다.</p>

<p>자바 7부터는 @SafeVarargs 애너테이션을 이용해서 제네릭 가변인수 메서드를 호출한 클라이언트 측 경고를 숨길 수 있습니다. 이 애너테이션은 메서드 작성자가 그 메서드가 타입 안전함읠 보장하는 장치입니다. 컴파일러도 이 애너테이션이 달리면 더 이상 경고를 출력하지 않습니다. 메서드의 안전은 다음 두가지만 지켜지면 됩니다.</p>

<ul>
  <li>메서드가 가변인수 배열에 아무것도 저장하지 않는다.(즉 배열을 덮어쓰지 않는다)</li>
  <li>배열의 참조가 밖으로 노출되지 않는다.(즉 배열을 반환하지 않는다)</li>
</ul>

<p>위의 내용을 종합해보면 결국 그 메서드에 순수하게 가변인수들을 전달하는 것에서 그친다면 안전합니다. 다음의 코드는 안전합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SafeVarargs</span>
<span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">flatten</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;...</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  <span class="n">fof</span><span class="o">(</span><span class="nc">LisT</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">:</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">result</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드에서는 가변인수 배열을 덮어쓰거나 배열을 반환하여 바깥에 노출하지도 않고 단순히 읽기 작업만 수행하여 안전합니다.</p>

<p>그런데 두번째 규칙에 대해서는 예외가 존재합니다. 하나는 @Safevarargs로 에노테이트된 또 다른 varargs 메서드에 배열의 참조를 넘기는 것은 가능합니다. 다른 하나는 전달하는 배열 원소의 일부 함수를 호출만 하는 (가변인수를 받지 않는) 일반 메서드에 참조를 넘기는 것도 안전합니다.</p>

<p>@SafeVarargs 이외에 다른 방법도 있습니다. 가변인수를 사용하지 않고 그 자리를 List 매개변수로 바꾸는 것입니다. 이 방식을 이용하면 클라이언트 코드가 살짝 지저분해지고 속도가 조금 느려질 수 있다는 단점이 있지만 컴파일러 타임에 타입 안전성이 보장됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SafeVarargs</span>
<span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">flatten</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">lists</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// 코드 동일</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="아이템-33-타입-안전-이종-컨테이너를-고려하라">아이템 33. 타입 안전 이종 컨테이너를 고려하라</h2>

<hr />

<p>제네릭은 Set&#60;E&#62;나 Map&#60;K, V&#62; 등의 컬렉션 같은 단일원소 컨테이너도 흔히 사용됩니다. 이때 매개변수화되는 대상은 원소가 아닌 컨테이너 자신입니다. Set은 원소의 타입을 뜻하는 하나의 타입 매개변수만 있으면 되고, Map은 키와 값 타입을 의미하는 2개의 타입 매개변수만 있으면 됩니다.</p>

<p>그런데 더 유연한 수단이 필요할 때도 있습니다. 가령 타입별로 즐겨 찾는 인스턴스를 저장하고 검색할 수 있는 Favorites 클래스를 보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Favorites</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">favorites</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

  <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">putFavorites</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">,</span> <span class="no">T</span> <span class="n">instance</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">favorites</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">type</span><span class="o">),</span> <span class="n">instance</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">getFavorite</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">type</span><span class="o">.</span><span class="na">cast</span><span class="o">(</span><span class="n">favorites</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">type</span><span class="o">));</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Class의 cast 메서드는 Class 클래스가 제네릭이기 때문에 Class 객체의 타입 매개변수와 같습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="no">T</span> <span class="nf">cast</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이런 설계 덕분에 T로 비검사 형변환하는 과정을 거치지 않고도 타입 안전하게 반환이 가능해집니다.</p>

<p>다음은 Favorites 클래스를 사용하는 클라이언트 코드 예시입니다. 즐겨찾는 String, Integer, Class인스턴스를 저장, 검색, 출력합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Favorites</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Favorites</span><span class="o">();</span>

  <span class="n">f</span><span class="o">.</span><span class="na">putFavorites</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"JAVA"</span><span class="o">);</span>
  <span class="n">f</span><span class="o">.</span><span class="na">putFavorites</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mh">0xcafebabe</span><span class="o">);</span>
  <span class="n">f</span><span class="o">.</span><span class="na">putFavorites</span><span class="o">(</span><span class="nc">Class</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">Favorites</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

  <span class="nc">String</span> <span class="n">favoriteString</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">getFavorite</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="kt">int</span> <span class="n">favoriteInteger</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">getFavorite</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">favoriteClass</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">getFavorite</span><span class="o">(</span><span class="nc">Class</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"%s %x %s%n"</span><span class="o">,</span> <span class="n">favoriteString</span><span class="o">,</span> <span class="n">favoriteInteger</span><span class="o">,</span> <span class="n">favoriteClass</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Favorites 클래스는 각 인스턴스의 Class 객체를 매개변수화한 키로 사용하고 있습니다. 이게 가능한 이유는 메서드의 매개변수를 보면 알 수 있듯이 class의 클래스가 제네릭이기 때문입니다. 그리고 class 리터럴의 타입은 Class&#60;T&#62;라서 String.class의 타입은 Class&#60;String&#62;이 됩니다. 그리고 이런 class 리터럴을 타입 토큰(ex. String.class)이라고 합니다. 이처럼 컨테이너가 아닌 키를 매개변수화해서 컨테이너에 값을 넣거나 뺄 때 그 매개변수화된 키를 제공하면 키의 타입과 값의 타입과 같음을 보장해줍니다. 이런 방식을 <strong>이종 컨테이너 패턴</strong>이라고 합니다. 이종 컨테이너로 구현을 하면 키에 들어오는 타입이 동적이기 때문에 일반적인 맵과 달리 여러 타입의 원소를 담을 수 있게 됩니다.</p>

    
  </section>

  <!-- Social media shares -->
  

<div class="share-buttons">
    <ul class="share-buttons">
        <div class="meta">Share</div>
        
        <li>
            <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fanstn1993.github.io%2F2021%2F06%2F30%2F%25EC%259D%25B4%25ED%258E%2599%25ED%258B%25B0%25EB%25B8%258C-%25EC%259E%2590%25EB%25B0%2594-5%25EC%259E%25A5.html" target="_blank" title=" Facebook">
			<i class="fa fa-facebook-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Share on Facebook</span>
		</a>
        </li>
         
        <li>
            <a href="https://twitter.com/intent/tweet?text=%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94+-+5%EC%9E%A5.+%EC%A0%9C%EB%84%A4%EB%A6%AD%20https%3A%2F%2Fanstn1993.github.io%2F2021%2F06%2F30%2F%25EC%259D%25B4%25ED%258E%2599%25ED%258B%25B0%25EB%25B8%258C-%25EC%259E%2590%25EB%25B0%2594-5%25EC%259E%25A5.html" target="_blank" title="">
			<i class="fa fa-twitter-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Tweet</span>
		</a>
        </li>
            
        <li>
            <a href="http://www.reddit.com/submit?url=https://anstn1993.github.io/2021/06/30/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-5%EC%9E%A5.html&title=%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94+-+5%EC%9E%A5.+%EC%A0%9C%EB%84%A4%EB%A6%AD%20%7C%20MunSooKim%27s+devlog" target="_blank" title=" Reddit">
			<i class="fa fa-reddit-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Share on Reddit</span>
		</a>
        </li>
           
        <li>
            <a href="mailto:?subject=%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94+-+5%EC%9E%A5.+%EC%A0%9C%EB%84%A4%EB%A6%AD%20%7C%20MunSooKim%27s+devlog&body=:%20https://anstn1993.github.io/2021/06/30/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-5%EC%9E%A5.html" target="_blank" title="">
			<i class="fa fa-envelope-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Email</span>
		</a>
        </li>
        
    </ul>
</div>




   <!-- Tag list -->
  
  


<footer>
  <div class="tag-list">
    
      <div class="meta">Tags</div>
    

    
    <a class="button" href="/tags#%EA%B8%B0%EC%88%A0">
      <p><i class="fa fa-tag fa-fw"></i> 기술</p>
    </a>
    
    <a class="button" href="/tags#%EC%9E%90%EB%B0%94">
      <p><i class="fa fa-tag fa-fw"></i> 자바</p>
    </a>
    
  </div>
</footer>


</article>

<!-- Disqus -->

<div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname = 'https-anstn1993-github-io';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view comments.</noscript>
</div>


<!-- Post navigation -->

  <div id="post-nav">
    
    <div id="previous-post">
        <a alt="이펙티브자바 - 6장. 열거 타입과 애너테이션" href="/2021/07/07/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-6%EC%9E%A5.html">
            <p>Previous post</p>
            이펙티브자바 - 6장. 열거 타입과 애너테이션
        </a>
    </div>
    

    
    <div id="next-post">
        <a alt="이펙티브자바 - 4장. 클래스와 인터페이스" href="/2021/06/23/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-4%EC%9E%A5.html">
            <p>Next post</p>
            이펙티브자바 - 4장. 클래스와 인터페이스
        </a>
    </div>
    
</div>



<!-- To change color of links in the page -->
<style>
  
  .feature-image a { color: brown !important; }
  div#post-nav a { color: brown !important; }
  footer a { color: brown !important; }
  .site-header nav a:hover {  color: brown !important; }
  header#main { background-color: brown !important; }
  

  header#main {
    background-repeat:no-repeat;
  background-image: url('/assets/img/lineart.png');  
  }
</style>

    </div>
    <footer class="site-footer">
    <p class="text">
         </p>
            <div class="footer-icons">
                <ul>
                <!-- Social icons from Font Awesome, if enabled -->
                


<li>
    <a href="mailto:anstn1993@gmail.com" title="Email">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
        </span>
    </a>
</li>













<li>
    <a href="https://github.com/anstn1993" title="Follow on GitHub">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-github fa-stack-1x fa-inverse"></i>
        </span>
    </a>
</li>
































                </ul>
            </div>
</footer>



  </body>
</html>
