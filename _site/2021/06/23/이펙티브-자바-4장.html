<!DOCTYPE html>
<!--
    Type on Strap jekyll theme v2.3.0
    Copyright 2016-2020 Sylhare
    Theme free for personal and commercial use under the MIT license
    https://github.com/sylhare/Type-on-Strap/blob/master/LICENSE
-->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!-- Main JS (navbar.js, katex_init.js and masonry_init.js)-->
    <script defer src="/assets/js/main.min.js"></script>
    
    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <!--Favicon-->
    <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

    <!-- RSS -->
    <link rel="alternate" type="application/atom+xml" title="MunSooKim's devlog" href="https://anstn1993.github.io/feed.xml"/>
    
    

    <!-- KaTeX 0.12.0 -->
    
    <script defer src="/assets/js/vendor/katex.min.js"></script>
    <script defer src="/assets/js/vendor/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
    

    <!-- Mermaid 8.8.2 -->
    
    <!-- <script src=”https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.8.2/mermaid.min.js" onload="mermaid.initialize({startOnLoad:true});"></script> -->
    <script defer src="/assets/js/vendor/mermaid.min.js" onload="mermaid.initialize({startOnLoad:true});"></script>
    

    <!-- Simple-Jekyll-Search 1.17.12 -->
    <script src="/assets/js/vendor/simple-jekyll-search.min.js" type="text/javascript"></script>

    <!-- Google Analytics / Cookie Consent -->
    <script>
      const cookieName = 'cookie-notice-dismissed-https://anstn1993.github.io';
      const isCookieConsent = 'false';
      const analyticsName = '';
    </script>

    
    

    <!-- seo tags -->
    <meta property="og:image" content="https://anstn1993.github.io/assets/img/pexels/triangular.jpeg">
    
    <meta property="og:type" content="website" />
    
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>이펙티브자바 - 4장. 클래스와 인터페이스 | MunSooKim’s devlog</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="이펙티브자바 - 4장. 클래스와 인터페이스" />
<meta name="author" content="Mun Soo Kim" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다." />
<meta property="og:description" content="조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다." />
<link rel="canonical" href="https://anstn1993.github.io/2021/06/23/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-4%EC%9E%A5.html" />
<meta property="og:url" content="https://anstn1993.github.io/2021/06/23/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-4%EC%9E%A5.html" />
<meta property="og:site_name" content="MunSooKim’s devlog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-06-23T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="이펙티브자바 - 4장. 클래스와 인터페이스" />
<script type="application/ld+json">
{"headline":"이펙티브자바 - 4장. 클래스와 인터페이스","dateModified":"2021-06-23T00:00:00+09:00","datePublished":"2021-06-23T00:00:00+09:00","url":"https://anstn1993.github.io/2021/06/23/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-4%EC%9E%A5.html","mainEntityOfPage":{"@type":"WebPage","@id":"https://anstn1993.github.io/2021/06/23/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-4%EC%9E%A5.html"},"author":{"@type":"Person","name":"Mun Soo Kim"},"description":"조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <!-- RSS -->
    <link type="application/atom+xml" rel="alternate" href="https://anstn1993.github.io/feed.xml" title="MunSooKim's devlog" />

    <!-- Twitter Cards -->
    <meta name="twitter:title" content="이펙티브자바 - 4장. 클래스와 인터페이스">
    <meta name="twitter:description" content="조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.4장. 클래스와 인터페이스클래스와 인터페이스는 추상화의 핵심입니다. 이 장에서는 클래스와 인터페이스를 잘 사용하는 방법들에 대해서 살펴봅니다.아이템 15. 클래스와 멤버의 접근 권한을 최소화하라클래스를...">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:image" content="https://anstn1993.github.io/assets/img/pexels/triangular.jpeg">
    <meta name="twitter:image:alt" content="이펙티브자바 - 4장. 클래스와 인터페이스">
</head>

  <body>
    <header class="site-header">

    <!-- Logo and title -->
	<div class="branding">
        
		<a href="/">
			<img alt="logo img" class="avatar" src="/assets/img/triangle.png" />
		</a>
        
        <a class="site-title" aria-label="MunSooKim's devlog" href="/">
        MunSooKim's devlog
		</a>
	</div>

    <!-- Toggle menu -->
    <nav class="clear">
    <a aria-label="pull" id="pull" class="toggle" href="#">
    <i class="fa fa-bars fa-lg"></i>
    </a>

    <!-- Menu -->
    <ul class="hide">
        

        
            
            
        
            
            <li class="separator"> | </li>
            <li>
                <a class="clear" aria-label="About" title="About" href="/about">
                     About 
                </a>
            </li>
            
            
        
            
            
        
            
            
        
            
            
        
            
            <li class="separator"> | </li>
            <li>
                <a class="clear" aria-label="Search" title="Search" href="/search">
                     <i class="fa fa-search" aria-hidden="true"></i>
                    
                </a>
            </li>
            
            
        
            
            <li class="separator"> | </li>
            <li>
                <a class="clear" aria-label="Tags" title="Tags" href="/tags">
                     <i class="fa fa-tags" aria-hidden="true"></i>
                    
                </a>
            </li>
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    </ul>

	</nav>
</header>

    <div class="content">
      <article class="feature-image" >
  <header id="main" style="">
    <div class="title-padder">
      
      <h1 id="%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94+-+4%EC%9E%A5.+%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80+%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4" class="title">이펙티브자바 - 4장. 클래스와 인터페이스</h1>
      


<div class="post-info">
    <p class="meta">
      June 23, 2021
    </p></div>

      
    </div>
  </header>

  <section class="post-content">
  
      <p>조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.</p>

<h1 id="4장-클래스와-인터페이스">4장. 클래스와 인터페이스</h1>

<p>클래스와 인터페이스는 추상화의 핵심입니다. 이 장에서는 클래스와 인터페이스를 잘 사용하는 방법들에 대해서 살펴봅니다.</p>

<h2 id="아이템-15-클래스와-멤버의-접근-권한을-최소화하라">아이템 15. 클래스와 멤버의 접근 권한을 최소화하라</h2>

<hr />

<p>클래스를 사용하는 클라이언트에는 클래스의 내부 멤버와 구현에 대해 최대한 감추고 api만 노출하는 것이 가장 좋습니다. 이는 정보 은닉, 캡슐화라고 하는 객체 지향의 기본 개념 중 하나 입니다. 정보 은닉을 통해 얻는 이점은 다음과 같습니다.</p>

<ul>
  <li>
    <p>여러 컴포넌트를 병렬적으로 개발하여 개발 속도가 향상된다.</p>
  </li>
  <li>
    <p>각 컴포넌트를 빠르게 디버깅할 수 있어서 관리 비용이 절감된다.</p>
  </li>
  <li>
    <p>컴포넌트별 역할의 분리가 명확하기 때문에 개선이 필요한 컴포넌트를 정하기 용이하며 성능 최적화로 이어진다.</p>
  </li>
  <li>
    <p>재사용성이 높다.</p>
  </li>
  <li>
    <p>컴포넌트 별로 개별적인 개발 및 테스트가 가능하기 때문에 대형 시스템 제작의 난이도가 낮아진다.</p>
  </li>
</ul>

<p>이 정보 은닉은 접근 제어자를 이용해서 달성할 수 있습니다. 가장 기본은 모든 클래스와 멤버의 접근성을 최대한 좁히는 것입니다. 구체적으로 살펴보겠습니다.</p>

<p><strong>1. 톱레벨 클래스와 인터페이스에서는 api로 공개할 필요가 없는 경우에는 모두 default로 설정하라.</strong>
톱레벨 클래스와 인터페이스에는 접근 제어자로 public, default를 지정할 수 있습니다. 이들을 클라이언트에게 api로 반드시 제공해야 한다면 public으로 설정해야겠지만 그럴 필요가 없으면 무조건 default로 설정합니다. 그래야 이후에 수정, 교체, 제거를 해도 클라이언트에 영향이 없기 때문입니다.</p>

<p><strong>2. 한 클래스에서만 사용하는 클래스나 인터페이스는 private static으로 중첩시켜라.</strong>
단 하나의 클래스만이 의존하는 클래스나 인터페이스를 굳이 별도의 톱레벨 클래스로 만들 필요는 없습니다. 그렇게 되면 적어도 같은 패키지 내의 모든 클래스에서 접근이 가능해지기 때문입니다.</p>

<p><strong>3. 클래스의 공개 api를 모두 세심하게 설계하고 나머지 멤버들은 모두 private로 만들어라.</strong>
다른 클래스에서 접근할 필요가 없는 멤버를 private로 지정해서 존재 자체도 알 필요가 없게 만드는 것이 좋습니다. 만약 같은 패키지 내의 클래스에서 꼭 접근이 필요한 멤버가 있으면 그런 멤버만 default 수준까지 풀어줍니다. 그런데 이런 일이 자주 일어난다면 컴포넌트의 분리가 더 필요한 건 아닌지 의심해봐야 합니다.
더 나아가서 public 클래스에서 protected까지 접근 제한이 풀리게 되는 멤버는 공개 api가 되는 것이기 때문에 내부 동작을 문서화해서 이용자에게 공개해야 할 수도 있습니다. 아이템 19에서도 살펴보겠지만 해당 클래스를 상속한 클래스에서 protected 메서드를 재정의해서 상위 호출을 하면 예기치 못한 동작을 할 수도 있기 때문입니다.</p>

<p><strong>4. public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.</strong>
가변 객체나 final이 아닌 인스턴스를 public으로 지정하면 클라이언트가 그 인스턴스에 접근할 수 있게 허용하는 꼴입니다. 그 말은 결국 그 인스턴스에 대한 불변식 보장이 안 되는 것이고 더 나아가 public 가변 필드를 갖는 클래스는 스레드 안전하지 않습니다. 심지어 그 필드가 불변이면서 final이더라도 내부 구현을 바꾸고 싶거나 해당 필드를 제거하고 싶어도 이미 클라이언트의 의존 가능성이 생기기 때문에 제거할 수 없습니다.</p>

<p><strong>5. 길이가 0이 아닌 배열은 모두 가변이니 주의하라.</strong>
클래스에서 배열을 public static final로 두거나 이 배열을 반환하는 접근자 메서드도 제공해서는 안 됩니다. 그 순간 배열 속의 원소를 변경할 수 있는 권한을 클라이언트에게 제공하게 됩니다. 이에 대한 두 가지 대안이 있습니다.</p>

<ul>
  <li>원본 배열은 private로 만들고 외부에 공개할 불변 리스트를 따로 추가</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Thing</span><span class="o">[]</span> <span class="no">PRIVATE_VALUES</span> <span class="o">=</span> <span class="o">{</span> <span class="o">...</span> <span class="o">};</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">LisT</span><span class="o">&lt;</span><span class="nc">Thing</span><span class="o">&gt;</span> <span class="no">VALUES</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">unmodifiableList</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="no">PRIVATE_VALUES</span><span class="o">));</span>
</code></pre></div></div>

<ul>
  <li>원본 배열은 private로 만들고 복사본을 반환하는 public 메서드를 추가(방어적 복사)</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Thing</span><span class="o">[]</span> <span class="no">PRIVATE_VALUES</span> <span class="o">=</span> <span class="o">{</span> <span class="o">...</span> <span class="o">};</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Thing</span><span class="o">[]</span> <span class="nf">values</span><span class="o">()</span> <span class="o">{</span>
   <span class="k">return</span> <span class="no">PRIVATE_VALUES</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
 <span class="o">}</span>
</code></pre></div></div>

<h2 id="아이템-16-public-클래스에서-public-필드가-아닌-접근자-메서드를-사용하라">아이템 16. public 클래스에서 public 필드가 아닌 접근자 메서드를 사용하라</h2>

<hr />

<p>멤버를 public으로 공개하는 것은 정보 은닉, 캡슐화의 이점을 포가히는 것과 다름 없습니다. 클라이언트가 마음대로 멤버를 주물럭거릴 수 있게 되니 내부 표현을 마음대로 바꿀 수 없고, 불변식 보장도 안 되고, 외부에서 필드에 접근할 때 부수 작업을 수행할 수도 없습니다. public 클래스에 한해서 멤버에 대한 접근은 모두 접근자 메서드로만 허용하는 것이 맞습니다. 이렇게 되면 클라이언트가 필드에 접근할 수 있게 하면서도 내부 표현을 언제든지 바꿀 수 있게 됩니다.</p>

<p>그런데 <strong>default 수준의 클래스나 private 중첩 클래스는 데이터 필드를 외부로 노출해도 아무 상관이 없습니다.</strong> 이 경우에는 그냥 필드로 바로 접근하게 허용하는 것이 코드도 간결해집니다. 물론 클라이언트의 코드가 해당 클래스의 표현에 묶이지만 그 클라이언트도 같은 패키지에서만 동작하는 코드일 뿐이기 때문에 표현 방식을 바꾸는 데 무리가 없습니다.</p>

<h2 id="아이템-17-변경-가능성을-최소화하라">아이템 17. 변경 가능성을 최소화하라</h2>

<hr />

<p>불변 클래스는 인스턴스 내부의 값을 절대로 수정할 수 없는 클래스 입니다. 자바 라이브러리의 String, 원시 타입의 박싱 클래스들(Integer, Double…), BigInteger, BigDecimal 등도 다 불변 클래스 입니다. 불변 클래스는 외부에 의해서 수정될 수 없기에 구현, 설계하기에 편하고 오류도 생길 가능성이 적습니다. 이런 불변 클래스를 만들기 위한 다섯 가지 규칙은 아래와 같습니다.</p>

<h3 id="불변-클래스-작성-규칙">불변 클래스 작성 규칙</h3>

<ul>
  <li>객체의 상태를 변경하는 메서드(setter)를 제공하지 않는다.</li>
  <li>클래스의 확장을 막는다.
클래스 상속을 final이나 private 생성자 방식으로 막습니다. 특히 private 생성자 방식이 대부분의 경우 최선입니다. 생성자를 private로 두고 정적 팩토리를 제공하면 다른 패키지에서는 이 클래스의 확장은 막으면서도 내부에서는 원하는 클래스 구현이 가능해지기 때문에 유연해지기 때문입니다.</li>
  <li>모든 필드를 final로 선언한다.
final은 설계자의 의도를 명확히 드러내는 방법인 동시에 멀티 스레드 환경에서 동기화 없이 동작하게 보장하기 위해서도 필요합니다.</li>
  <li>모든 필드를 private로 선언한다.
가변 객체 멤버를 클라이언트가 직접 접근해서 수정하는 것을 막아야 합니다. 물론 멤버가 불변 객체나 기본 타입은 public final로 설정해도 불변 객체가 되지만 이후에 내부 표현을 못 바꾸기 때문에 지양해야 합니다.</li>
  <li>자신 이외에는 내부의 가변 객체에 접근할 수 없도록 한다.
불변 클래스가 가변 객체를 멤버로 가지면 클라이언트가 그 객체의 참조를 얻을 수 없게 막아야 합니다. 즉 접근자도 제공하면 안 됩니다.</li>
</ul>

<p>함수형 프로그래밍을 잘 활용하면 불변 클래스를 만들기 용이합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Complex</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">re</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">im</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Complex</span><span class="o">(</span><span class="kt">double</span> <span class="n">re</span><span class="o">,</span> <span class="kt">double</span> <span class="n">im</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">re</span> <span class="o">=</span> <span class="n">re</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Comlex</span> <span class="nf">plus</span><span class="o">(</span><span class="nc">Complex</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">Complex</span><span class="o">(</span><span class="n">re</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="na">re</span><span class="o">,</span> <span class="n">im</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="na">im</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="o">...</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>위의 클래스는 복소수(실수부와 허수부로 구성된 수)를 표현합니다. 그런데 plus() 메서드를 보면 자기 자신의 멤버를 증가시키지 않고 새로운 복소수 인스턴스를 반환해줍니다. 이렇게 하면 메서드를 호출한 객체는 불변이 되면서 더하기 연산의 결과가 반영된 새로운 불변 객체가 생성되기 때문에 완벽히 불변이 됩니다.</p>

<h3 id="불변-클래스의-장단점">불변 클래스의 장단점</h3>

<p>그럼 불변 클래스가 주는 장점에 대해서 좀 더 자세히 살펴보겠습니다.</p>

<ul>
  <li>
    <p>스레드 안전하여 따로 동기화할 필요가 없다.
여러 스레드가 불변 객체를 공유해도 안전합니다. 여러 스레드가 동시에 값을 변경해서 레이스 컨디션에 빠질 가능성이 전혀 없기 때문입니다. 그래서 불변 클래스는 사실 한 번 만들어두고 계속 캐싱하여 재사용하는 것이 좋습니다. 자주 사용되는 객체는 상수(public static final)로 제공하는 것도 방법입니다. 더 나아가면 정적 펙토리를 통해서 캐싱된 불변 객체를 반환해주는 것까지 생각해볼 수 있습니다. 생성자 대신 정적 팩토리로 객체를 반환하게 만들어두면 중간에 캐싱 기능이 추가되더라도 api 수정 없이 가능해지는 이점도 챙길 수 있습니다.</p>
  </li>
  <li>
    <p>불변 객체는 방어적 복사도 필요 없다.
불변 객체는 복사본이나 원본이나 동일하기 때문에 그냥 자기 자신을 반환하면 됩니다. 그래서 불변 클래스는 clone() 메서드나 복사 생성자를 제공하지 않는 것이 좋습니다.</p>
  </li>
  <li>
    <p>불변 객체끼리는 내부 데이터를 공유해도 안전하다.
가령 어떤 불변 클래스가 멤버로 배열을 가진다고 가정하면, 그 클래스의 객체들은 동일한 배열을 참조로 가져도 무관합니다.</p>
  </li>
</ul>

<p>물론 단점도 존재합니다. 멤버의 값이 달라지면 객체가 새롭게 생성되어야 한다는 점인데요. 이런 문제를 해결하기 위해 많은 경우 해당 클래스에 대한 가변 동반 클래스를 제공합니다. String은 불변이기 때문에 문자열을 새롭게 붙일 때마다 객체가 새롭게 생성됩니다. 그런데 String의 가변 동반 클래스인 StringBuffer, StringBuilder를 이용하면 원하는 값의 구성이 완료되면 딱 한 번만 객체가 생성되게 할 수 있습니다.</p>

<h3 id="예외">예외</h3>

<p>앞서 살펴봤던 불변 클래스의 작성 규칙이 너무 엄격하다는 판단이 서면 다음과 같이 완화할 수는 있습니다.</p>

<ul>
  <li>어떤 메서드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없다.</li>
  <li>계산 비용이 큰 필드는 실제로 그 필드가 사용될 때 초기화를 해서 캐싱을 하게 하기 위해서 final을 사용하지 않는다.</li>
</ul>

<h2 id="아이템-18-상속보다는-컴포지션을-사용하라">아이템 18. 상속보다는 컴포지션을 사용하라</h2>

<hr />

<p>상속은 코드 재사용성을 높여주지만 조심해서 사용해야 합니다. 물론 상위 클래스와 하위 클래스가 같은 프로그래머가 통제하는 같은 패키지 내에 있다면 상속도 안전합니다. 또한 처음부터 상속을 고려하여 설계하고 문서화까지 잘 된 경우에도 괜찮습니다. 그런데 이런 케이스가 아니라면 <strong>상속은 많은 경우 캡슐화(정보 은닉)를 깨뜨립니다.</strong> 하위 클래스가 상위 클래스의 구현에 의존하는 경우가 발생하기 때문입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">InstrumentedHashSet</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">addCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">InstrumentedHashSet</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">InstrumentedHashSet</span><span class="o">(</span><span class="kt">int</span> <span class="n">initCap</span><span class="o">,</span> <span class="n">fload</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">super</span><span class="o">(</span><span class="n">initCap</span><span class="o">,</span> <span class="n">loadFactor</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">addCount</span><span class="o">++;</span>
      <span class="kd">super</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">addAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">addCount</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
      <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAddCount</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">addCount</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

</code></pre></div></div>

<p>위 클래스는 HashSet을 확장한 클래스 입니다. addCount는 ‘원소가 추가된 횟수’를 저장하는 멤버가 됩니다. 그런데 addAll() 메서드는 절대로 의도한대로 동작하지 않습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">InstrumentedHashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InstrumentedHashSet</span><span class="o">&lt;&gt;();</span>
  <span class="n">s</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"틱"</span><span class="o">,</span> <span class="s">"틱탁"</span><span class="o">,</span> <span class="s">"탁탁"</span><span class="o">))</span>
</code></pre></div></div>

<p>프로그래머는 위 코드가 실행된 뒤의 addCount는 3이라고 기대할 것입니다. 하지만 실제로는 6이 됩니다. 왜냐하면 HashSet의 addAll()메서드의 구현을 보면 내부적으로 add() 메서드를 호출하기 때문입니다. 이때의 add() 메서드는 InstrumentedHashSet에서 재정의한 add()가 됩니다. 이런 사례는 하위 클래스가 상위 클래스를 확장할 때 상위 클래스의 구현에 대해 정확히 파악해야만 한다는 것을 의미하게 됩니다.
더 심각한 문제는 어찌어찌 잘 파악해서 구현했다고 하더라도 다음 릴리즈 때 상위 클래스의 구현 방식이 바뀌기라도 하면 하위 클래스에서의 구현은 또 예기치 못한 방식으로 동작하게 될 수 있다는 것입니다.
뿐만 아니라 이후에 상위 클래스에 메서드가 추가되기라도 한다면 하위 클래스에서 그 메서드를 호출하는 순간 재정의된 메서드가 아닌 상위 클래스의 메서드가 호출되기 때문에 하위 클래스의 사정에 맞는 방식으로 동작하지 않을 가능성이 매우 높습니다. 가령 하위 클래스에서는 재정의된 메서드에 특정 조건에 부합하는 경우에 한해서만 원소가 추가되게는 구현을 추가해뒀는데 새롭게 추가된 상위 클래스의 메서드가 호출되면 그런 검사 없이 바로 원소가 추가될 것이기 때문에 허용되지 않은 원소가 포함될 수 있습니다.</p>

<p>이런 문제들을 해결하려면 확장 클래스의 private 멤버로 기존 클래스 안스턴수를 참조하게 바꾸면 됩니다. 그리고 메서드 재정의 대신에 재정의 메서드에 대응되는 메서드에서 기존 클래스 인스턴스의 메서드를 호출하는 forwarding(전달) 방식으로 구현하면 됩니다. 이렇게 되면 사실 멤버 인스턴스 클래스의 api에 대한 구현과는 완전히 독립할 수 있게 됩니다. 이런 composition과 forwarding의 조합은 넓은 의미로 <strong>위임</strong>이라고 부르는데 위임은 엄밀한 의미로는 확장의 대상이 되는 인스턴스의 래퍼 객체가 확장 인스턴스에게 자신의 참조를 넘기는 경우에만 위임이라고 합니다.</p>

<h3 id="정말-상속이-쓰일-수-있는-경우">정말 상속이 쓰일 수 있는 경우</h3>

<p>상속은 하위 클래스가 정말 상위 클래스의 하위 타입인 경우에만 쓰여야 합니다. 두 클래스가 아주 유명한 is-a 관계일 때에 한해서만 상속이 이루어져야 합니다. 클래스 B가 클래스 A를 확장하려고 한다면 정말 클래스 B가 A인지 자문해봐야 합니다. 그런데 정말 그런 관계가 성립하더라도 두 클래스의 패키지가 다르고 상위 클래스가 확장을 고려하지 않고 설계됐다면 여전히 문제가 발생할 가능성은 존재합니다.</p>

<h2 id="아이템-19-상속을-고려해-설계하고-문서화하라-그러지-않았다면-상속을-금지하라">아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라</h2>

<hr />

<p>아이템 18에서 상속이 캡슐화를 어떻게 깨게 되는지 살펴봤습니다. 그렇기 때문에 상속이 가능한 클래스의 재정의 가능 메서드들에 대한 문서를 남겨야 합니다. api로 공개된 메서드 내부에서 클래스 자신의 또 다른 메서드를 호출할 수 있습니다. 그런데 그 메서드가 재정의 가능 메서드라면 그것을 반드시 호출하는 메서드의 문서에 기록해줘야 합니다.</p>

<p>api 문서의 메서드 설명 끝에 “Implementation Requirements”로 시작하는 절은 그 메서드의 내부 동작 방식을 설명하는 곳입니다. 이 절은 메서드 주석에 @implSpec 태그를 붙이면 자바독 도구가 생성해줍니다.이처럼 구현에 대해 구구절절 설명하는 방식은 ‘어떻게’가 아닌 ‘무엇’을 설명하는 좋은 api 문서와는 거리가 멀지만 어쩔 수 없습니다.</p>

<p>상속을 위한 설계는 문서화만 있는 건 아닙니다. 클래스의 내부 동작 과정 중간에 필요할 수 있는 메서드나 필드를 protected로 설정하여 하위 클래스의 기능 구현에 도움을 줄 수도 있습니다. 가령 java.util.AbstractList의 removeRange() 메서드는 인자로 전달된 범위의 원소를 리스트에서 제거합니다. List 구현체의 최종 사용자는 이 메서드에 관심이 없지만 clear() 메서드를 고성능으로 쉽게 구현할 수 있게 도움을 주는 메서드이기 때문에 protected로 설정했습니다.</p>

<p>어떤 메서드를 protected로 노출할지 결정하는 유일한 방법은 직접 하위 클래스를 적어도 3개 이상 만들어보는 것 뿐입니다. 그리고 protected 메서드는 내부 구현에 해당하기 때문에 그 수가 최대한 적어야 하겠지만 그렇다고 너무 적게 노출해서 상속의 이점을 없애지 않는 것도 주의해야 합니다.</p>

<p>상속을 고려할 때 주의해야 할 또 다른 중요한 점은 바로 <strong>상속용 클래스의 생성자에서 직, 간접적으로 재정의 가능 메서드를 절대 호출하면 안 된다</strong>는 것입니다. 상위 클래스의 생성자에서 재정의 가능 메서드를 호출하게 되면 하위 클래스의 생성자가 호출됐을 때 상위 클래스 생성자가 호출된 후 하위 클래스 객체가 다 초기화 되기도 전에 하위 클래스의 재정의 메서드가 호출되기 때문입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Super</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Super</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">overrideMe</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">overrideMe</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Sub</span> <span class="kd">extends</span> <span class="nc">Super</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Instant</span> <span class="n">instant</span><span class="o">;</span>

    <span class="nc">Sub</span><span class="o">()</span> <span class="o">{</span>
      <span class="c1">// 상위 클래스 생성자에서 아래의 재정의된 overrideMe()가 호출</span>
      <span class="n">instant</span> <span class="o">=</span> <span class="nc">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">overrideMe</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">instant</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Sub</span> <span class="n">sub</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Sub</span><span class="o">();</span>
      <span class="n">sub</span><span class="o">.</span><span class="na">overrideMe</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>main() 메서드에서 Sub 타입의 인스턴스를 초기화할 때 호출되는 println은 null이 출력됩니다. 왜냐하면 상위 타입의 생성자에서 overrideMe()를 호출하는데 아직 instant가 초기화되기 전이기 때문 입니다. 이런 주의사항은 생성자와 같이 객체를 생성해주는 clone()과 readObject() 메서드에서도 동일합니다. 이들 메서드 내에서도 재정의 가능 메서드를 호출하면 안 됩니다.</p>

<h2 id="아이템-20-추상-클래스보다는-인터페이스를-우선하라">아이템 20. 추상 클래스보다는 인터페이스를 우선하라</h2>

<hr />

<p>자바는 다중 구현을 위한 수단으로 인터페이스와 추상 클래스를 제공합니다. 자바 8부터는 인터페이스에도 default 메서드가 제공되면서 추상 클래스와 인터페이스 모두 메서드를 추상이 아닌 구현으로 제공할 수 있게 됐습니다. 이 둘의 차이는 다중 구현의 가능 여부 입니다. 자바는 단일 상속만 지원하기 때문에 추상 클래스를 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 됩니다. 그러나 인터페이스의 경우 다중 구현이 가능합니다. 그래서 추상 클래스는 기존 클래스 위에 새로운 추상 클래스를 끼워넣기 어렵습니다. 그럼 이런 특징들로 인해서 인터페이스가 추상 클래스에 비해 어떤 장점을 가지는지 살펴보겠습니다.</p>

<ul>
  <li>
    <p>인터페이스는 믹스인 정의에 안성맞춤이다.
믹스인은 원래 클래스의 주된 타입 이외의 구현 가능한 타입을 선택적으로 제공하여 혼합한다는 의미입니다. 그러나 추상 클래스는 기존 클래스가 이미 부모를 섬기고 있다면 믹스인을 정의할 수 없습니다. 우선 다중 상속이 불가능하고 클래스는 계층 구조라는 특징을 가지는 것이기 때문에 개념적으로도 믹스인이라고 생각하기 어렵습니다.</p>
  </li>
  <li>
    <p>인터페이스와 추상 골격 구현 클래스를 이용해서 템플릿 메서드 패턴을 구현할 수 있다.
인터페이스로는 타입을 정의하고 골격 구현 클래스는 인터페이스로 선언한 메서드들을 구현하는 방식입니다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Login</span> <span class="o">{</span>

    <span class="kt">boolean</span> <span class="nf">authenticate</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">,</span> <span class="nc">String</span> <span class="n">password</span><span class="o">);</span><span class="c1">// 사용자 인증 메서드</span>
    <span class="kt">int</span> <span class="nf">authorize</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">);</span><span class="c1">// 사용자 권한 코드 획득 메서드</span>

    <span class="k">default</span> <span class="nc">User</span> <span class="nf">login</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">,</span> <span class="nc">String</span> <span class="n">password</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span><span class="o">(!</span><span class="n">authenticate</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="o">(</span><span class="s">"올바르지 않은 사용자 정보 입니다."</span><span class="o">);</span>
      <span class="o">}</span>

      <span class="c1">// 사용자의 권한 코드</span>
      <span class="kt">int</span> <span class="n">authCode</span> <span class="o">=</span> <span class="n">authorize</span><span class="o">(</span><span class="n">username</span><span class="o">);</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">User</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">authCode</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// 추상 골격 구현 클래스</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">AbstractLogin</span> <span class="kd">implements</span> <span class="nc">Login</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kt">boolean</span> <span class="nf">authenticate</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">,</span> <span class="nc">String</span> <span class="n">password</span><span class="o">)</span> <span class="o">{</span>
      <span class="o">...</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">authorize</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">)</span> <span class="o">{</span>
      <span class="o">...</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>

    <p>위의 코드를 보면 default 메서드를 통해 템플릿 메서드를 만들고 추상 골격 구현 클래스는 Login 인터페이스를 구현해서 인터페이스의 나머지 메서드들을 구현했습니다. 관례상 인터페이스 이름이 Interface면 골격 구현 클래스 이름은 AbstractInterface로 짓습니다. 물론 인터페이스가 아닌 추상 클래스로도 구현이 가능하지만 타입의 제한이 생겨버립니다.</p>
  </li>
</ul>

<h2 id="아이템-21-인터페이스는-구현하는-쪽을-생각해-설계하라">아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라</h2>

<hr />

<p>인터페이스 설계를 할 때는 반드시 그 인터페이스를 구현하는 쪽의 입장에 서서 심사숙고해야 합니다. 여러 개발자들이 여러 방식으로 해당 인터페이스를 구현할 것을 가정하여 릴리즈 전에 다양한 방식으로 직접 구현을 해보는 것이 중요합니다. 특히 인터페이스에 default 메서드가 생겼다고 해서 이미 릴리즈된 인터페이스에 default 메서드를 함부로 추가해선 안 됩니다.(새로운 인터페이스를 만드는 경우라면 default 메서드를 적극 활용하는 것이 좋습니다.)</p>

<p>릴리즈 이후에 default 메서드가 추가되면서 발생할 수 있는 문제는 앞서 살펴본 클래스의 상속 문제와 유사합니다. 중간에 갑자기 default 메서드가 삽입되어버리면 기존에 해당 인터페이스를 구현하고 있던 클래스들이 그 메서드를 호출할 때 기본 구현으로 동작하게 되고 이게 기존 클래스의 불변식을 보장하리란 보장이 없습니다. Collection 인터페이스를 구현하는 SynchronizedCollection의 정적 팩토리 메서드가 반환하는 객체의 모든 메서드는 내부적으로 락을 걸어주는 기능을 추가 제공합니다. 그런데 Collection 인터페이스의 default 메서드로 removeIf() 메서드가 추가되었고, 이 메서드는 동기화에 관해서는 모르기 때문에 락 객체를 사용할 수 없는 문제가 생겼습니다. 이처럼 default 메서드는 기존의 구현체에 어떤 영향을 미칠지 알 수 없기 때문에 주의해서 추가를 해야 합니다.</p>

<h2 id="아이템-22-인터페이스는-타입을-정의하는-용도로만-사용하라">아이템 22. 인터페이스는 타입을 정의하는 용도로만 사용하라</h2>

<hr />

<p>인터페이스는 자신을 구현한 클래스의 인스턴스 참조 타입의 역할을 할 수 있습니다. 즉 어떤 인터페이스를 구현했다는 것은 구현체 인스턴스가 어떤 기능을 제공하는지를 클라이언트에게 보여주는 것입니다. 인터페이스는 이런 용도로만 사용되어야 합니다.</p>

<p>인터페이스를 상수를 정의하는 용도로 사용해서는 안 됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">PhysicalConstants</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="no">AVOGADROS_NUMBER</span> <span class="o">=</span> <span class="mf">6.022_140_857e23</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="no">BOLTZMANN_CONSTANT</span> <span class="o">=</span> <span class="mf">1.380_648_52</span><span class="n">e</span><span class="o">-</span><span class="mi">23</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="no">ELECTRON_MASS</span> <span class="o">=</span> <span class="mf">9.109_383_56</span><span class="n">e</span><span class="o">-</span><span class="mi">31</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>위와 같이 상수만 잔뜩 있는 상수 인터페이스는 해당 인터페이스 타입이 제공하는 기능이 무엇인지 표상하는 역할을 하지도 못 하고 외부에 공개될 이유가 없는 내부 구현에 해당하는 값을 api로 노출해버리는 결과를 낳습니다. 클라이언트가 저 상수를 사용하기라도 하면 클라이언트의 코드는 저 상수에 의존성을 가져버립니다. 그래서 이후 릴리즈에 저 상수가 쓰이지 않게 되더라도 호환성을 위해 인터페이스를 유지할 수밖에 없습니다.</p>

<p>만약 상수를 api로 공개할 생각이라면 차라리 그 상수와 강한 연관이 있는 클래스나 인터페이스에 추가를 하는 게 좋습니다. 가장 대표적인 예시가 숫자 타입의 박싱 클래스로, Integer.MAX_VALUE 같은 상수 입니다. 또한 열거 타입으로 표현하기 적합한 상수면 그냥 열거 타입으로 제공하면 됩니다. 그것도 아니면 인스턴스화할 수 없는 유틸리티 클래스에 담아서 공개합니다.</p>

<h2 id="아이템-23-태그-달린-클래스보다는-클래스-계층구조를-활용하라">아이템 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라</h2>

<hr />

<p>두 가지 이상의 의미를 지니는 클래스를 태그로 분기하여 분기된 의미의 클래스로 활용하는 방식이 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nc">Figure</span> <span class="o">{</span>
    <span class="kd">enum</span> <span class="nc">Shape</span> <span class="o">=</span> <span class="o">{</span> <span class="no">RECTANGLE</span><span class="o">,</span> <span class="no">CIRCLE</span> <span class="o">};</span>

    <span class="c1">// 태그 필드</span>
    <span class="kd">final</span> <span class="nc">Shape</span> <span class="n">shape</span><span class="o">;</span>

    <span class="c1">// RECTANGLE일 때만 사용되는 필드</span>
    <span class="kt">double</span> <span class="n">length</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">width</span><span class="o">;</span>

    <span class="c1">// CIRCLE일 때만 사용되는 필드</span>
    <span class="kt">double</span> <span class="n">radius</span><span class="o">;</span>

    <span class="c1">// RECTANGLE용 생성자</span>
    <span class="kd">public</span> <span class="nf">Figure</span><span class="o">(</span><span class="kt">double</span> <span class="n">length</span><span class="o">,</span> <span class="kt">double</span> <span class="n">width</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="nc">Shape</span><span class="o">.</span><span class="na">RECTANGLE</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">length</span> <span class="o">=</span> <span class="n">length</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">width</span> <span class="o">=</span> <span class="n">width</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">Figure</span><span class="o">(</span><span class="kt">double</span> <span class="n">radius</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="nc">Shape</span><span class="o">.</span><span class="na">CIRCLE</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">double</span> <span class="nf">area</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">switch</span><span class="o">(</span><span class="n">shape</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nl">RECTANGLE:</span>
          <span class="k">return</span> <span class="n">length</span> <span class="o">*</span> <span class="n">width</span><span class="o">;</span>
        <span class="k">case</span> <span class="nl">CIRCLE:</span>
          <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">PI</span> <span class="o">*</span> <span class="o">(</span><span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span><span class="o">);</span>
        <span class="k">case</span> <span class="k">default</span><span class="o">:</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nf">AssertionError</span><span class="o">(</span><span class="n">shape</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>위와 같이 태그를 이용해서 하나의 클래스를 사각형, 원을 의미하는 클래스로 활용하는데 이런 클래스는 작성하면 안 됩니다. Figure 클래스를 부모 타입으로 두고 각각 Rectancle, Circle로 확장을 해서 계층 구조를 가지게 해야 합니다. 태그 클래스를 보면 불필요하게 enum을 멤버로 가지고, 의미별로 사용되는 멤버가 달라지기 때문에 코드의 양도 많아지고 가독성도 좋지 않습니다. 그리고 멤버를 final로 선언하려면 사용되지 않는 필드까지 억지로 초기화를 해줘야 합니다. 더 큰 문제는 새로운 의미라도 추가되는 날엔 저 클래스에 거의 모든 코드에 수정이 일어나야 할 것입니다. 하나라도 수정을 놓치게 되면 런타임 오류가 발생할 것입니다. 그럼 계층구조를 가지게끔 수정을 해보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Figure</span> <span class="o">{</span>
  <span class="kd">abstract</span> <span class="kt">double</span> <span class="nf">area</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Rectangle</span> <span class="kd">extends</span> <span class="nc">Figure</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="kt">double</span> <span class="n">length</span><span class="o">;</span>
  <span class="kd">final</span> <span class="kt">double</span> <span class="n">width</span><span class="o">;</span>

  <span class="nc">Rectangle</span><span class="o">(</span><span class="kt">double</span> <span class="n">length</span><span class="o">,</span> <span class="kt">double</span> <span class="n">width</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">length</span> <span class="o">=</span> <span class="n">length</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">width</span> <span class="o">=</span> <span class="n">width</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kt">double</span> <span class="nf">area</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">length</span> <span class="o">*</span> <span class="n">width</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Circle</span> <span class="kd">extends</span> <span class="nc">Figure</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="kt">double</span> <span class="n">radius</span><span class="o">;</span>

  <span class="nc">Circle</span><span class="o">(</span><span class="kt">double</span> <span class="n">radius</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kt">double</span> <span class="nf">area</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">PI</span> <span class="o">*</span> <span class="o">(</span><span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>상속을 통한 확장을 하면 자신에게 필요한 필드만 가져갈 수 있고 final로 선언을 해도 아무 문제가 없습니다. 그리고 추상 메서드의 구현 여부를 컴파일 타임에 확인하기 때문에 태그 클래스 때처럼 빠진 태그로 인해 발생할 수 있는 런타임 에러가 발생하지 않습니다.</p>

<h2 id="아이템-24-멤버-클래스는-되도록-static으로-만들어라">아이템 24. 멤버 클래스는 되도록 static으로 만들어라</h2>

<hr />

<p>중첨 클래스의 종류는 정적 멤버 클래스, 멤버 클래스, 익명 클래스, 지역 클래스 4가지 입니다. 이 주에 정적 멤버 클래스를 제외한 나머지는 내부 클래스(inner class)로 분류합니다. 각각의 특징에 대해서 살펴보겠습니다.</p>

<h3 id="정적-멤버-클래스">정적 멤버 클래스</h3>

<p>정적 멤버 클래스는 바깥 클래스의 private 멤버에 접근이 가능합니다. 하지만 static인 멤버에 대해서만 접근이 가능합니다. 비정적 멤버 클래스와 달리 바깥 클래스에 대한 외부 참조를 가지지 않기 때문입니다. 바깥 클래스의 객체가 초기화된 상태에서만 그 객체에 대한 초기화가 가능한 비정적 멤버 클래스와는 달리 정적 멤버 클래스는 바깥 클래스의 초기화여부와 무관하게 독립적으로 초기화가 이루어질 수 있는 클래스 입니다.</p>

<p>정적 멤버 클래스는 바깥 클래스의 도우미 클래스 역할을 하기에 좋습니다. 계산기의 연산 종류를 열거하는 Operation이라는 열거 타입을 만들어서 클라이언트에서 쓰려면 Calculator의 public 정적 멤버 클래스가 되면 됩니다. 그래서 Calculator.Operation.PLUS, Calculator.Operation.MINUS 같은 형태로 이용이 가능합니다.</p>

<h3 id="비정적-멤버-클래스">비정적 멤버 클래스</h3>

<p>정적 멤버 클래스에서도 언급했듯이 멤버 클래스는 바깥 클래스와 연결되어 외부 클래스 객체에 대한 참조를 가집니다. 그래서 드물지만 <strong>바깥 클래스를 초기화된 객체.new 연산자</strong>를 이용해서 초기화를 할 수 있고, 바깥 클래스 인스턴스와 비정적 멤버 클래스 인스턴스는 연결됩니다. 보통은 바깥 클래스의 메서드의 구현에서 멤버 클래스 생성자를 호출해서 관계를 맺습니다.</p>

<p>이런 비정적 멤버 클래스는 어댑터용으로 많이 사용합니다. 즉, 바깥 클래스가 실제 클래스의 인서턴스를 감싸주는 역할을 합니다. 가령 Map 인터페이스의 구현체들은 보통(keySet, entrySet, values 메서드가 반환하는) 자신의 컬렉션 뷰를 구현할 때 비정적 멤버 클래스를 사용합니다. Set이나 List 같은 인터페이스 구현도 자신의 반복자를 구현할 때 내부에 private 비정적 멤버 크래스를 사용합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">MySet</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">AbstractSet</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="o">...</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">MyIterator</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">class</span> <span class="nc">MyIterator</span> <span class="kd">implements</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>위와 같이 반복자를 멤버 클래스로 두고 메서드에서 초기화를 해주는 것이 일반적입니다. 이처럼 비정적 내부 클래스는 유용해보이지만, 멤버 클래스에서 바깥 인스턴스 참조를 해야하는 경우가 아니라면 무조건 정적 멤버 클래스로 만드는 것이 좋습니다. 비정적 멤버 클래스를 이용하면 외부 참조가 생기게 되고 이는 바깥 클래스의 인스턴스를 저장하기 위한 <strong>시간과 공간이 더 많이 소비</strong>된다는 것이고 클라이언트로부터 바깥 클래스의 인스턴스가 더 이상 참조되지 않더라도 내부참조가 남기 때문에 가비지 컬렉션이 일어나지 않는 <strong>메모리 누수 문제</strong>가 발생할 수 있기 때문입니다.</p>

<h3 id="익명-클래스">익명 클래스</h3>

<p>익명 클래스는 쓰이는 시점에 선언과 동시에 인스턴스가 만들어집니다. 비정적 문맥에서만 바깥 클래스의 인스턴스 참조가 가능하고 정적 문맥에서 사용되더라도 상수 변수 외의 정적 멤버는 가질 수 없습니다. 즉 상수 표현을 위해 초기화된 final 기본 타입과 문자열 필드만 가질 수 있습니다.</p>

<p>익명 클래스는 제약이 많습니다. 선언한 지점에서만 인스턴스화가 가능하고 instanceof 검사가 불가하며 인터페이스 다중 구현도 안 되고, 인터페이스 구현과 동시에 클래스 상속도 불가능합니다. 또한 익명 클래스는 코드 중간에 등장하기 때문에 10줄 이하로 짧지 않으면 가독성이 떨어집니다.</p>

<h3 id="지역-클래스">지역 클래스</h3>

<p>지역 클래스는 local scope에서 선언할 수 있는 클래스입니다. 즉 메서드 안에서 작성이 가능한 클래스인데 네 가지 중첩 클래스 중에서 가장 드물게 쓰입니다. 당연히 유효범위도 local scope입니다. 지역 클래스도 멤버 클래스처럼 이름이 있고 local scope내에서 선언하고 반복 사용이 가능합니다. 그리고 익명 클래스처럼 비정적 문맥에서 사용될 때만 바깥 인스턴스 참조가 되고 정적 멤버를 가질 수는 없습니다.</p>

<h2 id="아이템-25-톱레벨-클래스는-한-파일에-하나만-담으라">아이템 25. 톱레벨 클래스는 한 파일에 하나만 담으라</h2>

<hr />

<p>java 파일 안에 톱레벨 클래스는 하나만 담아야 합니다. 그렇게 하지 않으면 소스 파일의 컴파일 순서에 따라서 프로그램의 동작이 달라지는 치명적인 문제가 생길 수 있습니다.</p>

<p>위와 같이 하지 않고 정적 멤버 클래스를 사용하는 것을 고려해야 합니다. 특히 private로 선언하면 접근 범위까지 최소화할 수 있으니 더 좋습니다.</p>

    
  </section>

  <!-- Social media shares -->
  

<div class="share-buttons">
    <ul class="share-buttons">
        <div class="meta">Share</div>
        
        <li>
            <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fanstn1993.github.io%2F2021%2F06%2F23%2F%25EC%259D%25B4%25ED%258E%2599%25ED%258B%25B0%25EB%25B8%258C-%25EC%259E%2590%25EB%25B0%2594-4%25EC%259E%25A5.html" target="_blank" title=" Facebook">
			<i class="fa fa-facebook-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Share on Facebook</span>
		</a>
        </li>
         
        <li>
            <a href="https://twitter.com/intent/tweet?text=%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94+-+4%EC%9E%A5.+%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80+%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%20https%3A%2F%2Fanstn1993.github.io%2F2021%2F06%2F23%2F%25EC%259D%25B4%25ED%258E%2599%25ED%258B%25B0%25EB%25B8%258C-%25EC%259E%2590%25EB%25B0%2594-4%25EC%259E%25A5.html" target="_blank" title="">
			<i class="fa fa-twitter-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Tweet</span>
		</a>
        </li>
            
        <li>
            <a href="http://www.reddit.com/submit?url=https://anstn1993.github.io/2021/06/23/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-4%EC%9E%A5.html&title=%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94+-+4%EC%9E%A5.+%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80+%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%20%7C%20MunSooKim%27s+devlog" target="_blank" title=" Reddit">
			<i class="fa fa-reddit-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Share on Reddit</span>
		</a>
        </li>
           
        <li>
            <a href="mailto:?subject=%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94+-+4%EC%9E%A5.+%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80+%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%20%7C%20MunSooKim%27s+devlog&body=:%20https://anstn1993.github.io/2021/06/23/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-4%EC%9E%A5.html" target="_blank" title="">
			<i class="fa fa-envelope-square fa-2x" aria-hidden="true"></i>
			<span class="sr-only">Email</span>
		</a>
        </li>
        
    </ul>
</div>




   <!-- Tag list -->
  
  


<footer>
  <div class="tag-list">
    
      <div class="meta">Tags</div>
    

    
    <a class="button" href="/tags#%EA%B8%B0%EC%88%A0">
      <p><i class="fa fa-tag fa-fw"></i> 기술</p>
    </a>
    
    <a class="button" href="/tags#%EC%9E%90%EB%B0%94">
      <p><i class="fa fa-tag fa-fw"></i> 자바</p>
    </a>
    
  </div>
</footer>


</article>

<!-- Disqus -->

<div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname = 'https-anstn1993-github-io';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view comments.</noscript>
</div>


<!-- Post navigation -->

  <div id="post-nav">
    
    <div id="previous-post">
        <a alt="이펙티브자바 - 5장. 제네릭" href="/2021/06/30/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-5%EC%9E%A5.html">
            <p>Previous post</p>
            이펙티브자바 - 5장. 제네릭
        </a>
    </div>
    

    
    <div id="next-post">
        <a alt="이펙티브자바 - 3장. 모든 객체의 공통 메서드" href="/2021/06/16/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%9E%90%EB%B0%94-3%EC%9E%A5.html">
            <p>Next post</p>
            이펙티브자바 - 3장. 모든 객체의 공통 메서드
        </a>
    </div>
    
</div>



<!-- To change color of links in the page -->
<style>
  
  .feature-image a { color: brown !important; }
  div#post-nav a { color: brown !important; }
  footer a { color: brown !important; }
  .site-header nav a:hover {  color: brown !important; }
  header#main { background-color: brown !important; }
  

  header#main {
    background-repeat:no-repeat;
  background-image: url('/assets/img/lineart.png');  
  }
</style>

    </div>
    <footer class="site-footer">
    <p class="text">
         </p>
            <div class="footer-icons">
                <ul>
                <!-- Social icons from Font Awesome, if enabled -->
                


<li>
    <a href="mailto:anstn1993@gmail.com" title="Email">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
        </span>
    </a>
</li>













<li>
    <a href="https://github.com/anstn1993" title="Follow on GitHub">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-github fa-stack-1x fa-inverse"></i>
        </span>
    </a>
</li>
































                </ul>
            </div>
</footer>



  </body>
</html>
