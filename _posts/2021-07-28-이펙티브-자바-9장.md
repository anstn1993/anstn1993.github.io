---
layout: post
title: 이펙티브자바 - 9장. 일반적인 프로그래밍 원칙 # Title of the page
hide_title: false # Hide the title when displaying the post, but shown in lists of poststhumbnail: "assets/img/thumbnails/sample-th.png"  # Add
color: brown # Add the specified color as feature image, and change link colors in post
author: "Mun Soo Kim"
tags: [기술, 자바]
---

조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.

# 9장. 일반적인 프로그래밍 원칙

이 장에서는 자바로 개발할 때 지켜야 하는 여러 원칙들에 대해서 살펴보겠습니다.

## 아이템 57. 지역변수의 범위를 최소화하라

---

지역변수의 유효 범위를 최소한으로 줄이는 것은 가독성, 유지보수성, 오류 방지 측면에서 중요합니다. 지역변수의 범위를 줄이기 위한 기법들을 살펴보겠습니다.

- 가장 처음 쓰일 때 선언하라.
  C언어처럼 전방전언을 하게 되면 실제 그 변수가 사용되는 블록이 끝나도 살아있게 되기 때문에 의도한 범위 앞, 뒤에서 그 변수를 사용해서 원치 않는 결과를 초래할 수 있습니다.

- 거의 모든 지역변수는 선언과 동시에 초기화해야 한다.
  try-catch문과 같이 try문 바깥에서 변수를 참조해야 하는 경우를 제외하고는 거의 모든 경우에 선언과 초기화를 함께 해주는 것이 좋습니다.

- 반복 변수 값을 반복문이 종료된 뒤에도 써야 하는 상황이 아니면 while문보다는 for문을 사용하라.
  for, for-each 모두 반복 변수의 범위가 반복문의 몸체와 반복문 블록 안으로 제한되기 때문에 범위를 제한하기에 좋습니다. 특히 프로그램의 오류를 컴파일 타임에 잡아내기에도 훨씬 좋습니다.

  ```java
    Iterator<Element> i = c.iterator();
    while (i.hasNext()) {
      doSomething(i.next());
    }

    Iterator<Element> i2 = c2.iterator();
    while (i.hasNext()) { // 앞에서 사용한 i를 다시 사용! 하지만 컴파일은 잘 됨
      doSomething(i.next());
    }
  ```

  두번째 while문에서는 i2 반복자를 사용해야 했지만 i를 사용했습니다. 이런 실수를 for문에서는 컴파일 타임에 잡아내게 됩니다.

  ```java
    for(Iterator<Element> i = c.iterator; i.hasNext(); ) {
      Element e = i.next();
      ...
    }

    // i를 찾을 수 없나는 컴파일 오류 발생
    for(Iterator<Element> i2 = c2.iterator; i.hasNext(); ) {
      Element e = i2.next();
      ...
    }
  ```

  심지어 for문을 사용하면 for문을 사용할 때마다 반복 변수의 이름을 똑같이 사용할 수 있다는 장점도 있습니다.

- 메서드를 작게 유지하고 한 가지 기능에 집중하라.
  한 메서드에 여러 기능이 들어오면 한 기능과 관련된 지역변수에 다른 기능을 수행하는 쪽에서 접근할 수 있게 되기 때문에 메서드를 기능별로 쪼개야 합니다.

## 아이템 58. 전통적인 for 문보다는 for-each 문을 사용하라

---

for와 for-each(향상된 반복문) 중에서는 for-each를 사용하는 것이 for를 사용해야만 하는 경우를 제외하고는 더 좋습니다. 반복문에서 원소를 담고 있는 컬렉션이나 배열을 순회할 때 대부분 우리의 관심사는 원소이지 인덱스가 아닙니다. 그런데 for를 사용하면 원소 참조를 위해 반복 변수를 어쩔 수 없이 사용해야 하는 경우가 생기고 이는 잘못된 변수를 사용할 가능성이 높아짐을 의미합니다. 그리고 for-each를 사용했을 때 더 큰 장점은 배열이든 컬렉션이든 원소를 참조하는 방법이 동일하다는 점입니다. 즉 어떤 컨테이너를 다루는지 신경쓸 필요가 없습니다. 반면 for의 경우 배열과 컬렉션의 참조 방법이 달라지게 됩니다. for-each문은 컬렉션, 배열과 더불어 Iterable 인터페이스를 구현한 객체라면 모두 순회가 가능합니다.

하지만 for문을 사용할 수 밖에 없는 경우 3가지가 있습니다. 아래의 3가지 경우를 제외하고는 for-each를 사용하도록 합시다.

- 파괴적인 필터링
  컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove 메서드를 사용해야 합니다. 그런데 자바 8부터는 Collection의 removeIf 메서드를 사용해서 인자로 전달된 Predicate 함수 객체의 조건에 부합하는 원소는 모두 제거해주기 때문에 굳이 순회하면서 제거하지 않아도 됩니다.

- 변형
  배열, 리스트 등을 순회하면서 원소의 값 일부나 전체를 수정해야 하면 반복자나 인덱스를 사용해야 합니다.

- 병렬 반복
  여러 컬렉션을 병렬로 순회해야 하면 각각의 반복자, 인덱스 변수를 사용해서 제어할 수밖에 없습니다.

## 아이템 59. 라이브러리를 익히고 사용하라

---

라이브러리를 적극적으로 활용하면 그 코드를 작성한 전문가의 지식과 이를 앞서 사용한 다른 프로그래머들의 경험을 활용하여 개발 시간과 시행착오를 줄일 수 있습니다. 대부분의 프로그래머들은 애플리케이션 기능 개발에 집중하고 싶어하지, 하부 공사에 시간을 많이 쓰고 싶어하지 않습니다. 그리고 라이브러리를 사용하면 자신이 따로 유지보수를 하지 않아도 성능이 지속적으로 개선된다는 점입니다. 특히 사용자가 많을수록 라이브러리 제작자들이 더 나은 방법을 꾸준히 모색할 것입니다. 또 다른 이점으로는 시간이 지날수록 기능이 점점 많아진다는 점입니다. 마지막으로 라이브러리를 쓰면 해당 코드는 많은 사람들에게 익숙한 코드가 되어 다른 개발자들이 읽기 좋고, 유지보수하기 좋고, 재활용하기 쉬운 코드가 됩니다.

이런 장점들에도 불구하고 많은 프로그래머들은 이미 라이브러리로 있는 기능을 직접 구현해서 씁니다. 해당 라이브러리의 존재를 모르기 때문인 경우가 대부분일 것입니다. 자바는 메이저 릴리스마다 수많은 라이브러리들이 추가되고 웹 페이지에 그 내용을 공시합니다. 새로운 메이저 버전이 나오면 읽어보는 것이 좋습니다.(ex. java8-feat, java9-feat)

대표적으로 자바 9에서 InputStream에 추가된 transferTo 메서드를 살펴보겠습니다. 이 메서드는 지정한 URL로 요청을 보내 응답 본문을 쉽게 가져올 수 있는 메서드 입니다.

```java
public static void main(String[] args) throws Exception {
  try(InputStream in = new URL(args[0]).openStream()) {
    in.transferTo(System.out);
  }
}
```

자바 9 이전에는 위와 동일한 역할을 하는 코드를 작성하기가 까다롭고 길었지만 자바 9에서는 단 한줄이면 해결됩니다. 이처럼 라이브러리가 가져다주는 이점이 크기 때문에 자바 프로그래머라면 다음의 라이브러리들에 익숙해져야 합니다.

- java.lang, java.util, java.io와 그 하위 패키지들
- 자바 7부터는 Random보단 ThreadLocalRandom(포크-조인 풀이나 병렬 스트림에서는 SplittableRandom)
- 컬렉션 프레임워크와 스트림 라이브러리
- java.util.concurrent의 동시성 기능

## 아이템 60. 정확한 답이 필요하다면 float과 double은 피하라

---

float과 double 타입은 이진 부동 소수점 연산에 쓰이고, 넓은 범위의 수를 정밀한 '근사치'로 계산하게 설계되었기 때문에 **정확한 계산 결과가 필요할 때는 쓰면 안 됩니다.** 1.03달러 중에 42센트를 썼을 때 남는 돈을 구하는 어설픈 코드를 작성해보겠습니다.

```java
System.out.println(1.03 - 0.42);
```

위 코드는 정확한 값인 0.61을 출력하지 않고 0.6100000000000001을 출력합니다. **정확한 값을 구해야 하는, 특히 금융 계산에서는 BigDecimal, int, long을 사용**해야 합니다. 이때 BigDecimal은 두 가지 단점이 있습니다. 기본 타입보다 쓰기 불편하고, 훨씬 느립니다. 대신 반올림을 수행해야 하는 계산에서는 BigDecimal이 여덟 가지 반올림 모드를 제공하기 때문에 완벽히 제어가 가능하다는 장점도 있습니다. int, long의 경우 훨씬 빠르지만 값의 크기가 제한되고 소수점을 직접 관리해야 하기 때문에 계산의 요구사항에 따라 적절한 타입을 선택하면 됩니다.

## 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라

---

기본 타입과 그에 대응되는 박싱 타입은 오토 박싱과 오토 언박싱 덕분에 크게 구분하지 않고 사용하는 경우가 많은데 이 둘의 차이는 잘 알고 사용해야 합니다. 둘의 차이는 다음과 같습니다.

- 박싱된 기본 타입은 식별성이라는 속성을 가지기 때문에 두 인스턴스가 감싸고 있는 값이 같아도 다르다고 식별될 수 있다.
  이와 관련된 문제를 살펴보겠습니다. Integer 값을 오름차순으로 정렬하는 비교자를 만들어보겠습니다.
  ```java
  Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
  ```
  Integer 자체가 순서를 가지기 때문에 비교자를 만들 필요는 없지만 결함을 보여주기 위해 작성되었습니다. 얼핏 봤을 때는 문제가 없어보입니다. 하지만 naturalOrder.compare(new Integer(42), new Integer(42))를 호출하면 값이 42라서 0을 출력할 것 같지만 1을 출력합니다. 왜냐하면 부등호 연산에서는 오토 언박싱을 통해 값을 비교하지만 **== 연산에서는 인스턴스 비교**가 이루어지기 때문입니다. 즉 두 인스턴스의 비교 결과 false가 되어 1이 반환되는 것입니다. 문제를 해결하려면 기본타입 변수를 생성해서 그 변수로 비교를 하면 됩니다.
  ```java
  Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
    int i = iBoxed, j = jBoxed;
    return i < j ? -1 : (i == j ? 0 : 1);
  };
  ```
- 기본 타입의 값은 언제나 유효하지만 박싱된 기본 타입은 null을 가질 수 있다.
  다음의 간단한 프로그램을 보겠습니다.

  ```java
    public class Unbelievable {
      static Integer i;

      public static void main(String[] args) {
        if(i == 42) {
          System.out.println("믿을 수 없군!");
        }
      }
    }
  ```

  이 프로그램은 잘 모르고 보면 '믿을 수 없군!'이 출력될 것 같지만 NullPointerException을 던지게 됩니다. 기본 타입은 값을 정의하지 않더라도 기본 값으로 0이 들어가지만 참조 타입의 기본 값은 null이기 때문입니다. 해법은 간단하게 Integer 대신 int를 사용하는 것입니다.

- 기본 타입이 시간과 메모리 사용면에서 더 효율적이다.
  다음의 간단한 프로그램을 보겠습니다.
  ```java
    public static void main(String[] args) {
      Long sum = 0L;
      for (long i = 0; i < Integer.MAX_VALUE; i++) {
        sum += i;
      }
      System.out.println(sum);
    }
  ```
  이 프로그램은 sum을 박싱 타입으로 선언해서 느려졌습니다. 이때 i를 sum에 더하는 연산에서 언박싱과 박싱이 반복해서 일어나기 때문에 성능이 체감될 정도로 느려집니다.

박싱된 타입을 써야 하는 경우도 분명히 존재합니다.

- 컬렉션의 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로 박싱된 타입을 쓴다. 가령, 컬렉션의 원소, 키, 값으로 쓴다.

- 리플렉션을 통해 메서드를 호출할 때 박싱된 타입을 쓴다.

## 아이템 62. 다른 타입이 적절하다면 문자열 사용을 피하라

---

자바는 문자열을 잘 지원해주는 언어 중 하나인데 이런 이유 때문에 원래 의도에서 벗어난 용도로 사용되는 경우가 많습니다. 문자열을 쓰지 않아야 하는 사례들을 살펴보겠습니다.

- 문자열은 다른 값 타입을 대신하기에 적합하지 않다.
  입력받을 데이터가 문자열이 아니라면 그 데이터의 실제 타입을 사용하는 게 좋습니다. 데이터가 숫자라면 int, float, BigInteger 등 적당한 수치 타입으로 변환해야 합니다. 또는 '예/아니오' 질문의 답이라면 적절한 열거 타입이나 boolean을 써야 합니다. 그리고 그 어떠한 타입으로도 표현하기 힘들다면 새로 클래스를 하나 작성해야 합니다.
- 문자열은 열거 타입을 대신하기에 적합하지 않다.
- 문자열은 혼합 타입을 대신하기에 적합하지 않다.
  여러 요소가 혼합된 데이터를 특정 문자를 구분자로 삼아서 하나의 문자열로 표현하는 경우가 있습니다. 이 방식은 문제가 많습니다.

  - 구분자가 요소에 문자로 포함되어있기라도 하면 그 문자도 의도치 않게 구분자 역할을 하면서 데이터가 깨진다.
  - 개별 요소에 접근하기 위해서는 문자열을 파싱해야 한다. 이는 느리고, 귀찮고, 오류 가능성도 큰 방식이다.
  - equals, toString, compareTo 메서드를 제공할 수 없고, String의 메서드에만 의존할 수 있습니다.

  이런 문제를 겪지 않기 위해 차라리 전용 클래스를 만드는 게 낫습니다. 이런 클래스는 보통 private 정적 멤버 클래스로 선언합니다.

- 문자열을 권한을 표현하기에 적합하지 않다.
  자바 2 전에는 스레드 지역변수 기능을 프로그래머가 직접 설계해야 했는데 여러 방법을 모색하다가 다다른 하나의 설계가 클라이언트가 제공한 문자열 키로 스레드별 지역변수를 식별하는 것이었습니다.

  ```java
  public class ThreadLocal {
    private ThreadLocal() {} // 객체 생성 불가

    // 현 스레드의 값을 키로 구분해서 저장
    public static void set(String key, Object value);

    // (키가 가리키는) 현 스레드의 값을 반환
    public static Object get(String key);
  }
  ```

  우선 이 방식의 문제는 문자열 키가 전역 이름공간에서 공유된다는 것입니다. 즉, 클라이언트가 제공하는 키의 충돌이 발생할 여지가 있다는 것입니다. 그럼 두 클라이언트 모두 제대로 기능하지 못할 것입니다. 이는 보안도 취약함을 의미합니다. 악의적인 클라이언트가 의도적으로 같은 키를 이용해서 다른 클라이언트의 값을 가져올 수도 있습니다.

  해결책은 문자열 대신 위조할 수 없는 키를 사용하면 됩니다. 이 키를 권한(capacity)라고 합니다.

  ```java
  public class ThreadLocal {
    private ThreadLocal() {} // 객체 생성 불가

    public static class Key { // (권한)
      key() {}
    }

    //위조 불가능한 고유 키를 생성한다.ㅣ
    public static Key getKey() {
      return new Key();
    }

    // 현 스레드의 값을 키로 구분해서 저장
    public static void set(Key key, Object value);

    // (키가 가리키는) 현 스레드의 값을 반환
    public static Object get(Key key);
  }
  ```

  이제 key는 더 이상 스레드 지역변수를 구분하기 위한 키가 아니라 그 자체가 스레드 지역분수가 되고 set, get은 정적 메서드일 이유가 없습니다. 그럼 사실 톱레벨 클래스인 ThreadLocal은 딱히 하는 일이 없어지기 때문에 중첩 클래스인 Key를 ThreadLocal로 바꾸면 됩니다. 그리고 덧붙여 매개변수화 타입을 적용해서 get을 할 때 형변환을 하지 않게 만듭니다.

  ```java
  public class ThreadLocal<T> {
    public ThreadLocal() {}
    public static void set(T value);
    public static T get();
  }
  ```

## 아이템 63. 문자열 연결은 느리니 주의하라

---

문자열은 불변이기 때문에 문자열들을 연결하면 새로운 공간에 초기화를 하게 되기 때문에 성능 저하가 발생합니다. 자바 6 이후에는 문자열 연결 성능을 많이 개선했지만 그럼에도 불구하고 StringBuffer, StringBuilder가 훨씬 빠릅니다. 한 가지 더 기억할 점은 StringBuffer, StringBuilder를 초기화할 때 다중정의된 생성자를 통해 결과 문자열을 담기에 충분한 길이로 초기화하면 더 빠르다는 점입니다.

## 아이템 64. 객체는 인터페이스를 사용해 참조하라

---

어떤 타입이든 적합한 인터페이스만 있다면 매개변수뿐만 아니라 반환값, 변수, 필드를 전부 인터페이스로 선언하는 것이 좋습니다. 객체를 구상 클래스로 선언하는 상황은 '생성자'로 객체를 생성할 때뿐입니다. **인터페이스를 타입으로 사용하면 프로그램이 훨씬 유연해집니다.** 구상 클래스 교체를 해야 하더라도 그냥 하면 됩니다. 그리고 다른 코드는 전혀 손댈 필요가 없습니다. 다른 코드는 인터페이스 타입만 알지 기존 구상 클래스 타입이 무엇인지는 모르기 때문입니다.

주의할 점이 하나 있습니다. 기존 클래스가 인터페이스의 일반 규약 외에 특별한 기능을 제공하며, 주변 코드가 이 기능에 의존해서 동작하면 새롭게 교체될 클래스도 반드시 같은 기능을 제공해야 합니다. LinkedHashSet이 따르는 순서 정책을 가정하고 동작하는 코드가 있는데 이때 HashSet으로 바꿔버리면 반복자의 순회 순서 보장이 안 되기 때문에 문제가 생길 수 있습니다.

만약 적합한 인터페이스가 없으면 당연히 구상 클래스로 선언을 해야 합니다. String, BigInteger 같은 값 클래스가 대표적입니다. 이런 값 클래스를 여러 가지로 구현할 수 있다고 생각하고 설계하는 경우는 거의 없기에 final 클래스인 경우가 많고 상응하는 인터페이스가 존재하는 경우가 거의 없습니다. 또한 클래스 기반으로 작성된 프레임워크가 제공하는 객체들을 사용해야 하는 경우에도 적합한 인터페이스가 없을 것이기 때문에 구상 클래스를 사용해야 합니다. 하지만 이런 경우라고 해도 특정 구현 클래스를 사용하는 것보단 가장 상위(기반) 클래스(보통은 추상 클래스)를 사용해서 참조해야 합니다. 마지막으로 인터페이스에는 없는 메서드를 제공하는 클래스의 메서드를 사용해야 한다면 어쩔 수 없이 그 클래스로 참조를 해야 합니다. 예를 들어 PriorityQueue 클래스는 Queue 인터페이스에는 없는 comparator 메서드를 제공하는데 이 기능을 이용하려면 PriorityQueue로 참조할 수밖에 없습니다.

## 아이템 65. 리플렉션보다는 인터페이스를 사용하라

---

리플렉션 기능을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있습니다. Class 객체를 통해서 생성자, 메서드, 필드에 해당하는 Constructor, Method, Field 인스턴스를 가져올 수 있고, 그 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 등을 가져올 수 있습니다. 뿐만 아니라 Constructor, Method, Field를 이용해서 각각에 연결된 실제 생성자, 메서드, 필드를 조작할 수도 있습니다. 예를 들면 Method.invoke는 어떤 클래스의 어떤 객체가 가진 어떤 메서드라도 호출할 수 있습니다. 이런 **리플렉션을 이용하면 컴파일 당시에 존재하지 않았던 클래스도 이용할 수 있습니다.** 하지만 단점이 많습니다.

- 컴파일타임의 타입 검사가 주는 이점을 하나도 누릴 수 없다.
  앞서 컴파일 당시에 없던 클래스도 사용할 수 있다고 했지만 이는 역으로 말하면 잘못해서 존재하지 않거나 접근할 수 없는 메서드를 호출하려고 시도하면 런타임 오류가 발생할 수 있음을 의미합니다.
- 리플렉션을 이용하면 코드가 지저분하고 장황해진다.
- 성능이 떨어진다.
  리플렉션을 통한 메서드 호출은 일반 메서드 호출보다 훨씬 느립니다.

이처럼 리플렉션은 단점이 명확해서 아주 제한된 형태로만 사용해야 단점은 피하고 이점만 취할 수 있습니다. 컴파일타임에 이용할 수 없는 클래스를 사용해야만 하는 프로그램은 비록 컴파일타임이라도 적절한 인터페이스나 상위 클래스를 이용할 수는 있을 것입니다. 이런 경우라면 **리플렉션은 인스턴스 생성에만 쓰고 이 인스턴스는 인터페이스나 상위 클래스로 참조해서 사용**합니다.

리플렉션을 이용한 프로그램 하나를 작성해보겠습니다. 이 프로그램은 `Set<String>` 인터페이스의 인스턴스를 생성하는데 구체 타입은 명령줄의 첫 번째 인수로 지정됩니다. 그리고 생성된 집합에 두 번째 이후의 인수들을 추가해서 화면에 출력합니다. 첫 번째 인수로 입력한 구체 타입이 무엇이냐에 따라 원소들의 출력 순서가 달라질 것입니다. 가령 java.util.HashSet이면 무작위, java.util.TreeSet을 지정하면 알파벳 순서로 출력될 것입니다.

```java
public static void main(String[] args) {
  // 클래스 이름을 Class 객체로 변환
  Class<? extends Set<String>> cl = null;
  try {
    cl = (Class<? extends Set<String>>) Class.forName(args[0]);// 비검사 형변환
  } catch (ClassNotFoundException e) {
    fatalError("클래스를 찾을 수 없습니다.");
  }

  // 생성자를 얻는다.
  Constructor<? extends Set<String>> cons = null;
  try {
    cons = cl.getDeclaredConstructor();
  } catch (NoSuchMethodException e) {
    fatalError("매개변수 없는 생성자를 찾을 수 없습니다.");
  }

  // 집합의 인스턴스를 만든다.
  Set<String> s = null;
  try {
    s = cons.newInstance();
  } catch (IllegalAccessException e) {
    fatalError("생성자에 접근할 수 없습니다.");
  } catch (InstantiationException e) {
    fatalError("클래스를 인스턴스화할 수 없습니다.");
  } catch (InvocationTargetException e) {
    fatalError("생성자가 예외를 던졌습니다: " + e.getCause());
  } catch (ClassCastException e) {
    fatalError("Set을 구현하지 않은 클래스입니다.");
  }

  // 생성한 집합을 사용한다.
  s.addAll(Arrays.asList(args).subList(1, args.length));
  System.out.println(s);
}

private static void fatalError(String msg) {
  System.err.println(msg);
  System.exit(1);
}
```

단점을 언급하기에 앞서 이 프로그램에 대해 평하자면, 이 프로그램은 간단하지만 강력합니다. 손쉽게 제네릭 집합 구현에 대한 테스터로 사용할 수 있습니다. Set 구현체를 공격적으로 조작해가며 Set 규약을 잘 지키는지 검사해볼 수 있습니다. 혹은 제네릭 집합 성능 분석 도구로 활용할 수도 있습니다. 대부분의 경우 리플렉션 기능은 이 정도면 충분합니다.

하지만 단점 두 가지가 나타납니다. 하나는 런타임에 여섯 가지나 되는 예외를 던질 수 있다는 점입니다. 이 모든 예외들은 리플렉션 없이 인스턴스를 생성했다면 컴파일타임에 모두 잡아낼 수 있는 예외들입니다. 다른 하나는 클래스 이름만으로 인스턴스 단 하나를 생성하기 위한 코드가 25줄이나 된다는 점입니다. 즉 너무 장황합니다.(참고로 자바 7부터는 리플렉션 예외를 각각 잡는 대신 모든 리플렉션 예외의 상위 클래스인 ReflectiveOperationException을 제공해줘서 코드 길이를 줄일 수 있긴 합니다.) 우선 객체가 만들어지면 그 후의 코드는 일반적인 코드와 똑같습니다.

정리하자면 리플렉션은 런타임에 존재하지 않을 수도 있는 다른 클래스, 메서드, 필드와의 의존성 관리가 필요할 때 적합할 것입니다. 하지만 그런 경우가 아니라면 사용하지 않는 것이 좋습니다.

## 아이템 66. 네이티브 메서드는 신중히 사용하라

---

자바 네이티브 인터페이스(Java Native Interface, JNI)는 자바 프로그램에서 네이티브 메서드를 호출하는 기술입니다. C, C++ 같은 네이티브 프로그래밍 언어로 작성한 메서드를 네이티브 메서드라고 합니다. 이 메서드는 주요 쓰임은 다음과 같습니다.

- 레지스트리 같은 플랫폼 특화 기능을 사용하는 경우
- 네이티브 코드로 작성된 라이브러리를 사용하는 경우
- 성능 개선을 목적으로 성능에 결정적 영향을 주는 영역만 따로 네이티브 언어로 작성하는 경우

플랫폼 특화 기능을 이용하려면 네이티브 메서드를 사용해야 하지만 시간이 지나면서 자바가 os 같은 하부 플랫폼의 기능들을 점점 흡수하고 있어서 네이티브 메서드의 필요성이 점점 줄어들고 있습니다. 대표적인 예가 자바 9에서 추가된 process api 입니다. 해당 api로 os 프로세스에 접근할 수 있게 되었습니다. 그러니까 **적절한 자바 라이브러리가 없는 경우에만 네이티브 메서드를 사용하면 됩니다.**

**성능 개선을 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않습니다.** JVM은 시간이 지날수록 엄청난 발전을 이룩해서 대부분의 작업에서 다른 플랫폼에 견줄만한 성능을 보입니다.

네이티브 메서드 사용을 권장하지 않는 이유는 심각한 단점 때문입니다. 네이티브 메서드를 사용하게 되면 해당 애플리케이션의 메모리 훼손 오류가 발생할 수 있습니다. 또한 자바와 달리 네이티브 언어는 플랫폼에 의존적이기 때문에 이식성이 낮습니다. 디버깅도 어렵고 가비지 컬렉터가 네이티브 메모리는 자동 회수하지 못하며 추적조차 할 수 없습니다. 그리고 자바 코드와 네이티브 코드의 경계를 넘나들 때마다 비용도 추가되고 둘을 이어주는 접착 코드까지 필요한데 귀찮고 가독성도 떨어집니다.

## 아이템 67. 최적화는 신중히 하라

---

최적화는 보통 좋은 결과보다는 해로운 결과로 이어지기 쉽고, 빠르지도 않고 제대로 동작하지도 않으면서 수정하기 어려운 소프트웨어를 탄생시킬 가능성이 높기 때문에 정말로 명백하고 확실한 해법을 찾지 않는 이상 하지 않는 것이 좋습니다. 그러니 빠른 프로그램을 작성하려고 안달하지 않아도 됩니다. 성능을 개선하겠다는 핑계로 견고한 구조를 파괴하면 안 됩니다. 최적화와 관련하여 지켜야 할 것들을 살펴보겠습니다.

- **빠른 프로그램보단 좋은 프로그램을 작성하는 것이 더 중요하다.**
  좋은 프로그램이라면 아키텍처가 훌륭할 것이고 그 자체로 최적화하기 좋은 구조가 될 것입니다. 캡슐화가 잘 지켜져서 개별 구성요소들을 독립적으로 개선할 수 있기 때문입니다. **구현상의 문제는 나중에 최적화로 해결할 수 있지만 구조의 결함이 성능을 제한하는 상황에서는 시스템 전체를 다시 작성해야만 한다**는 것을 명심해야 합니다.

- **성능을 제한하는 설계를 피하라.**
  애플리케이션이 완성된 후 가장 변경하기 어려운 요소가 컴포넌트끼리, 혹은 외부 시스템과의 소통 방식입니다. 이런 설계 요소들은 완성 후에는 변경하기 어렵거나 불가능할 수 있으니 신중해야 합니다.

- **API를 설계할 때 성능에 주는 영향을 고려하라.**
  public 타입을 가변으로 만들어서 불필요한 방어적 복사를 유발하는 것은 바람직하지 않으니 가능하다면 불변으로 만드는 것이 좋습니다. 그리고 컴포지션으로 해결할 수 있는 문제를 상속 방식으로 설계하는 public 클래스는 영원히 상위 클래스에 종속되고 성능의 제약까지도 물려받게 됩니다. 또한 인터페이스가 있는데 굳이 구상 클래스 타입을 사용하는 것 역시 좋지 않습니다. 나중에 더 빠른 구현체가 나오더라도 이용하지 못하게 됩니다.

- **최적화 시도 전후로 성능을 측정하라.**
  대부분 최적화를 한 후 성능 비교를 해보면 눈에 띄게 좋아지지 않았거나, 더 나빠지는 경우가 많을 것입니다. 주요 원인은 작성된 코드의 어떤 구간에서 시간이 많이 소요되는지 추측하기 어려운 것에 있습니다. 일반적으로 90%의 시간을 단 10%의 코드에서 사용합니다.
  프로파일링 도구를 사용하면 개별 메서드의 소비 시간과 호출 횟수 같은 런타임 정보를 제공해서 어디에 집중해야 할지 알려주기 때문에 유용하게 사용할 수 있습니다. jmh라는 것도 있습니다. 이는 프로파일러는 아니지만 자바 코드의 상세한 성능을 알기 쉽게 보여주는 마이크로 벤치마킹 프레임워크 입니다.

## 아이템 68. 일반적으로 통용되는 명명 규칙을 따르라

---

자바의 명명 규칙은 크게 철자와 문법, 두 범주로 나뉩니다. 이 규칙을 지키지 않은 api는 사용하기 어렵고 유지보수하기 어렵습니다. 또한 다른 프로그래머들이 읽기 어렵고 다른 뜻으로 오해할 수 있어서 오류까지 발생할 수 있으니 꼭 지킵시다.

### 철자 규칙

#### 패키지

패지지, 모듈의 이름은 각 요소를 점으로 구분해서 계층적으로 짓습니다. 각 요소의 이름은 소문자 알파벳이나 드물게 숫자로 이루어집니다. 만약 외부로 나가야 될 패키지라면 개발한 조직의 인터넷 도메인 이름을 역순으로 사용하면 됩니다.(ex. com.google...) 예외적으로 자바 표준 라이브러리와 선택적 패키지들은 각각 java와 javax로 시작합니다. 그 뒤에 붙는 나머지 이름은 해당 패키지를 설명하는 하나 이상의 요소로 이루어집니다. 각 요소는 일반적으로 8자 이하의 짧은 단어가 좋습니다. 보통 약어나 한 단어로 이루어집니다. 혹은 각 단어의 첫 글자만 따서 써도 됩니다.

#### 클래스(열거 타입 포함)와 인터페이스(애너테이션 포함)

클래스와 인터페이스의 이름은 하나 이상의 단어로 이루어지며 각 단어는 대문자로 시작합니다. 이때 단어들의 첫 글자만 딴 약자나 max, min 처럼 아주 널리 통용되는 줄임말을 제외하고는 단어를 줄여쓰지 않아야 합니다.

#### 메서드와 필드

첫 글자를 소문자로 쓴다는 점만 빼면 클래스 명명 규칙과 같습니다. 이때 첫 단어가 약자라면 단어 전체가 소문자여야 합니다. 단 '상수 필드'는 구성 단어 모두 대문자로 쓰며 단어 사이는 밑줄로 구분합니다. 이름에 밑줄을 사용하는 건 상수 필드가 유일합니다.

지역 변수도 비슷한 규칙이 적용되는데 차이는 약어를 써도 된다는 점입니다. 지역변수는 약어를 써도 그 변수가 사용되는 문맥에서 의미를 쉽게 유추할 수 있기 때문입니다. 입력 매개변수도 지역변수의 하나이지만 메서드 설명 문서에까지 등장하는 만큼 일반 지역변수보다는 신경써야 합니다.

#### 타입변수

타입 매개변수 이름은 보통 한 문자로 표현합니다. 대부분 다음의 다섯 가지 중 하나입니다.

- T: 타입
- E: 컬렉션 원소의 타입
- K, V: 맴의 키와 값의 타입
- X: 예외 타입
- R: 메서드의 반환 타입

이 외의 임의 타입의 시퀀스는 T, U, V 혹은 T1, T2, T3를 사용합니다.

### 문법 규칙

#### 클래스

객체를 생성할 수 있는 객체의 이름은 보통 단수 명사나 명사구를 사용합니다. 객체를 생성할 수 없는 클래스의 이름은 보통 복수형 명사로 짓습니다.(Collectors, Collections 등)

#### 인터페이스

클래스와 똑같이 짓거나(Collection, Comparator 등) able, ible로 끝나는 형용사로 짓습니다.(Runnable, Iterable, Accessible 등)

#### 애너테이션

워낙 다양하게 활용되어서 지배적인 규칙 없이 명사, 동사, 전치사, 형용사가 두루 쓰입니다.(BindingAnnotation, Inject, ImplementedBy, Singleton 등)

#### 메서드

목적어를 포함한 동사나 동사구로 짓습니다. boolean 값을 반환하는 메서드는 보통 is나 드물게 has로 시작하고 명사나 명사구, 형용사로 기능하는 아무 단어나 구로 끝나게 짓습니다.(isDigit, isProbablePrime, isEmpty, isEnabled, hasSiblings 등) 반환 타입이 boolean이 아니거나 해당 인스턴스의 속성을 반환하는 메서드의 이름은 보통 명사, 명사구, 혹은 get으로 시작하는 동사구로 짓습니다.(size, hashCode, getTime 등) get으로 시작하는 형태는 주로 자바빈즈 명세에 뿌리를 두고 있습니다. 자바빈즈는 재사용을 위한 컴포넌트 아키텍처의 초기 버전인데 최근 도구들 중에서도 이 규칙을 따르는 경우가 많아서 이런 도구의 규칙에 종속되는 경우라면 이 규칙을 따라야 합니다.

이외에 특별한 메서드 이름이 몇 가지 있습니다. 객체의 타입을 바꿔서 반환하는 인스턴스 메서드의 이름은 보통 toType 형태로 짓습니다.(toString, toArray 등) 객체의 내용을 다른 뷰로 보여주는 메서드의 이름은 asType 형태로 짓습니다.(asList 등) 객체의 값을 기본 타입 값으로 반환하는 메서드의 이름은 보통 typeValue 형태로 짓습니다.(intValue 등) 마지막으로 정적 팩토리의 이름은 다양하지만 from, of, valueOf, instance, getinstance, newInstance, getType, newType을 흔히 사용합니다.

#### 필드

필드 이름은 api 설계를 잘 했으면 직접 노출될 일이 거의 없어서 덜 중요합니다. boolean 타입의 필드 이름은 보통 boolean 접근자 메서드에서 앞 단어를 뺀 형태입니다.(initialized, composite 등) 다른 타입의 필드라면 명사나 명사구를 사용합니다.(height, digits, bodyStyle 등) 지역변수 이름도 필드와 비슷하게 지으면 되지만 좀 더 느슨합니다.
