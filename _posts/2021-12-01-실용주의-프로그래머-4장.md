---
layout: post
title: 실용주의 프로그래머 4장 # Title of the page
hide_title: false # Hide the title when displaying the post, but shown in lists of poststhumbnail: "assets/img/thumbnails/sample-th.png"  # Add
color: brown # Add the specified color as feature image, and change link colors in post
author: "Mun Soo Kim"
tags: [기술]
---

앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. '4장 실용주의 편집증'을 정리했습니다.

# 4장. 실용주의 편집증

---

### 21장. 계약에 의한 설계

정직한 거래를 보장하는 최선의 해법은 계약입니다. 계약의 당사자들은 모두 자신의 권리와 책임을 지고, 서로에게 기대한 바를 수행하도록 강제합니다. 이런 컨셉을 소프트웨어 모듈에도 적용하면 프로그램의 정확성을 높일 수 있습니다. 정확한 프로그램은 자신의 일이라고 주장하는 것에 대해 더 많지도, 적지도 않게 수행하는 것입니다. 그 주장을 문서화하고 검증하는 것이 바로 계약에 의한 설계(Design By Contract, DBC)입니다.
이 계약은 보통 함수, 메서드와 그것의 호출자 사이에 적용됩니다. 계약에 의한 설계 개념을 개발한 버트란드 마이어는 계약을 이행하기 위한 조건으로 다음 3가지를 말합니다.

- 선행조건: 루틴이 호출되기 위해 지켜져야 할 조건으로 이 조건이 위반된 경우에는 루틴이 호출되지 않아야 합니다. 즉 조건이 충족된 데이터를 루틴에 전달하는 것은 호출하는 쪽의 책임입니다.
- 후행조건: 루틴이 완료되었을 때의 상태를 의미합니다. 어떤 루틴에 후행조건이 있으면 그 루틴은 반드시 종료됨을 보장합니다.
- 클래스 불변식: 호출자의 입장에서 루틴이 종료되고 호출자로 제어권이 반환될 때 불변식이 항상 참임을 보장하는 것입니다. 루틴이 진행 중일 때는 불변식이 일시적으로 참이 아닐 수도 있습니다.

위의 조건을 정리하자면 만약 호출자가 루틴의 모든 선행조건을 이행한다면, 루틴은 종료시에 모든 호행조건과 불변식이 참이 될 것을 보장해야 하는 것입니다.

상속과 다형성에서도 이런 계약은 빛을 발합니다. 서브타입은 항상 부모 타입의 한 종류라는 간단한 사실을 잊지 않고 서브클래스에서는 자신의 부모 이상으로 받아들이고, 최소한 자신의 부모만큼은 보증해야 하는데 이런 규칙을 잘 이행하게 할 수 있습니다.

### 22장. 죽은 프로그램은 거짓말을 하지 않는다.

우리는 코드를 작성하는 그 순간부터 무슨 일이든 일어날 수 있다는 것을 인정해야 합니다. 많은 경우 '그런 일은 절대 일어날 리 없어'라는 생각과 함께 방어적으로 코딩을 하지 않는데, 가능하면 방어적으로 코딩하면서 에러를 최대한 빨리 잡아내고 **가능한한 일찍 프로그램의 작동을 멈추게 하는 것**이 좋습니다. 대표적으로 자바는 예외를 던져서 그것을 잡지 않으면 스택 트레이스를 출력하면서 프로그램을 종료합니다.
그렇게 하지 않으면 프로그램은 점점 망가져가고 결국 문제의 발생 지점과는 점점 멀어져서 어디서부터 잘못됐는지 알 수 없는 지경에 다다를 수도 있습니다. 멈출 수 있을 때 바로 멈춰버립시다!

### 23장. 단정적 프로그래밍

단정문(assertion)을 사용해서 절대 일어나선 안 될 일들에 대비를 해야 합니다. 단정문을 통한 검사 없이 '이런 일은 절대 일어날 수 없어'라고 생각하고 있다면 그것은 아주 큰 오산입니다. 혹자들은 단정문에 대한 오해를 가지고 단정문을 사용하지 않는데 주로 다음과 같은 오해가 있습니다.

- 단정문은 과부하를 준다. 단정문은 코드의 테스트를 위해 존재하고, 테스트가 끝나면 단정을 꺼야 한다.

위의 주장은 테스트가 모든 버그를 발건한다는 가정이 깔려있는데, 복잡한 프로그램에서는 모든 버그를 테스트만으로 못 잡을 가능성이 높습니다. 그리고 우리의 프로그램은 험한 세상에서 돌아가고있기 때문에 런타임에도 단정문으로 최대한 빨리 일어나선 안 될 일이 일어나는 것에 대비해야 합니다.

### 24장. 언제 예외를 사용할까

예외는 말 그대로 예외적인 상황에서 사용해야 합니다. 예를 들면, 파일을 열어서 읽어들일 때 파일이 존재하지 않는다면 예외가 발생해야 할까요? 정답은 파일이 반드시 존재해야 한다면 그렇고, 파일이 있을 수도 있고, 없을 수도 있다면 그렇지 않다는 것입니다. 파일이 반드시 존재해야 한다면 예외를 던지고 그렇지 않다면 에러만 반환합시다.
예외를 사용하지 말아야 할 때도 알아야 합니다. 예외는 절대 정상적인 로직을 처리하기 위해서 사용하면 안 됩니다. 모든 예외 처리를 다 제거했을 때 프로그램이 잘 동작하지 않는다면 예외를 잘못 사용하고 있는 건 아닌지 의심해봐야 합니다.

### 25장. 리소스 사용의 균형

리소스 사용의 균형은 **사용을 마쳤으면 반드시 반납하는 것**을 의미합니다. 메모리, 트랜잭션, 파일 등 어떤 종류의 리소스가 되었든 할당이 되었으면 반납이 되어야 합니다. 그리고 이 둘은 같은 객체가 책임져야 합니다. 이때 할당과 반납을 하는 함수는 별도로 만드는 것이 추후 유지보수 측면에서 좋습니다. 특정 역할을 하는 함수에서 반납까지 함께 처리하게 되면 시간이 지나면서 요구사항이 추가되고 그 함수가 조건에 따라 호출되지 않는 경우가 생겼을 때 자원이 반납되지 않게 되는 등의 문제가 생길 수 있습니다.
자원을 두개 이상 중첩할당할 수도 있습니다. 이때는 2가지를 주의해야 합니다.

- 리소스를 할당한 순서의 반대로 해제하라. 그렇게 해야 한 리소스가 다른 리소스를 참조하는 경우에도 리소스를 고아로 만들지 않는다.
- 코드의 여러 곳에서 동일한 리소스 집합을 할당받으려고 하면 할당 순서는 모든 곳에서 동일하게 해라. 그렇게 애햐 교착 상태에 빠질 가능성을 줄일 수 있다. 할당의 순서가 달라서 한 곳에서는 resource A -> B, 다른 한 곳에서는 resouce B -> A 순서로 할당을 요청하는데 공교롭게도 각각 A와 B를 할당받은 상태에서 다음 자원 할동을 요청하게 되면 그 다음 필요한 자원은 서로가 이미 할당받은 상태이기 때문에 계속해서 기다려야 합니다.
