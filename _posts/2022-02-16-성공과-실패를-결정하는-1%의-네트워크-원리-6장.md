---
layout: post
title: 성공과 실패를 결정하는 1%의 네트워크 원리 6장 # Title of the page
hide_title: false # Hide the title when displaying the post, but shown in lists of poststhumbnail: "assets/img/thumbnails/sample-th.png"  # Add
color: brown # Add the specified color as feature image, and change link colors in post
author: "Mun Soo Kim"
tags: [기술, CS]
---

Tsutomu Tone의 [성공과 실패를 결정하는 1%의 네트워크 원리]라는 책을 읽고 개인적으로 정리한 포스트 입니다. '6장 웹 서버에 도착하여 응답 데이터가 웹 브라우저로 돌아간다'를 정리했습니다.

# 6장. 웹 서버에 도착하여 응답 데이터가 웹 브라우저로 돌아간다

---

6장에서는 웹 서버에 도착한 패킷에서 요청 메시지를 추출하여 애플리케이션에 전달하고 애플리케이션의 응답 데이터를 어떻게 회송하는지를 살펴봅니다.

### 서버의 개요

서버는 클라이언트의 패킷을 수신하기 전에 수신을 할 수 있는 준비 동작을 합니다. 이 준비 동작을 이해하기 위해서 서버 전체의 모습을 살펴봅니다.

#### 클라이언트와 서버의 차이점

클라이언트와 서버의 머신은 하드웨어나 OS 부분에서 차이가 있을 수 있으나, 네트워크와 관련된 영역, LAN 어댑터, 프로토콜 스택, Socket라이브러리 등의 기능은 완전히 동일합니다. TCP나 IP의 기능도 하드웨어나 OS가 무엇이든지 동일합니다.
둘의 차이는 Socket 라이브러리의 사용에 있습니다. 클라이언트는 접속 동작을 하지만, 서버는 그 접속을 기다리는 형태이기 때문에 접속을 기다리는 루틴을 호출하게 됩니다. 또한 서버는 다수의 클라이언트와 대화를 한다는 차이도 있습니다. 이런 차이로 인해 서버 애플리케이션은 클라이언트와 구조가 달라집니다.

#### 서버 애플리케이션의 구조

서버 애플리케이션은 복수의 클라이언트와 통신을 하기 때문에 각 클라이언트를 전담하는 테스크나 스레드를 생성해서 처리하도록 합니다. 서버 애플리케이션은 **클라이언트의 접속을 기다리는 부분**과 **클라이언트와 대화를 처리하는 부분**으로 구성됩니다. 서버 애플리케이션이 초기화 동작을 마치면 접속을 기다리는 부분을 실행합니다. 이 부분은 소켓을 작성해두고 그 소켓을 클라이언트의 접속을 기다리는 상태로 만들어두고 쉬는 상태가 됩니다. 클라이언트가 접속을 하면 클라이언트와 대화하는 부분을 생성하여 접속동작을 마친 소켓을 전달하여 클라이언트와의 대화를 위임하게 됩니다. 이 클라이언트와 대화하는 부분은 클라이언트가 접속할 때마다 새롭게 생성됩니다. 이 방식은 클라이언트가 접속할 때마다 프로세스나 스레드를 새롭게 생성해야 하는 비용이 들기 때문에 미리 풀을 만들어두기도 합니다.

#### 서버 애플리케이션의 소켓 동작

그럼 클라이언트 접속을 기다리는 부분과 클라이언트와 대화를 처리하는 부분의 동작을 Socket라이브러리의 호출 루틴을 중심으로 살펴보겠습니다.

서버에서 호출하는 Socket 라이브러리의 루틴은 다음과 같습니다.

1. 소켓을 만든다.(소켓 작성)
2. 소켓을 접속 대기 상태로 만든다.(접속 대기)
3. 접속을 접수한다.(접속 접수)
4. 데이터를 송/수신한다.(송/수신)
5. 파이프를 분리하고 소켓을 말소한다.(연결 끊기)

여기서 2, 3번을 제외하면 클라이언트와 완전히 동일합니다. 2번은 bind(<디스크립터1>, 포트 번호, ...)를 호출하여 소켓에 포트 번호를 기록합니다. 그럼 listen(<디스크립터1>, ...)을 호출하여 소켓에 접속하기를 기다리는 상태라는 제어 정보를 기록하게 됩니다. 여기까지가 2번이고 클라이언트의 접속 동작을 기다리는 상태가 됩니다. 3번에서 accept(<디스크립터1>, ...)를 호출하게 됩니다. 클라이언트로부터 패킷이 도착하기 전까지 이 accept()에서 프로그램은 블록킹이 되어 패킷이 도착할 때까지 기다리게 됩니다. 이때 애플리케이션은 쉬는 상태가 됩니다. 그러다가 패킷이 도착하면 응답 패킷을 반속하고 접속 접수 동작을 실행합니다. 이때 **접속 대기 소킷을 복사하여 새로운 소켓을 만들고 거기에 접속 상대측 정보를 비롯한 제어 정보를 함께 기록**하게 됩니다. 여기까지 완료되면 새 소켓과 클라이언트의 소켓의 연결이 완성됩니다. accept()는 복제된 소켓의 디스크립터를 봔환하게 되는데 접속을 기다리는 부분은 클라이언트와 대화하는 부분을 생성해서 그 디스크립터를 전달하게 됩니다. 여기까지가 클라이언트의 접속을 기다리는 부분의 역할입니다.
그럼 클라이언트와 대화를 처리하는 부분은 데이터의 송/수신과, 연결 끊기 동작을 담당하게 됩니다.

이 일련의 과정에서 한 가지 눈여겨봐야 할 것이 있는데, 원래 접속 대기 상태의 소켓은 복사를 해서 새 소켓을 만든 후에 어떻게 되느냐 입니다. 이 소켓은 계속 접속 대기 상태로 남아있게 됩니다. accept()한번 호출되고 나서 다시 호출되어서 다음 패킷을 받기 위한 대기 상태가 되는데 이때 계속 같은 소켓을 사용해서 패킷이 도착했을 때 새 소켓을 복제하게 됩니다. 그렇게 하지 않고 접속 대기 상태의 소켓으로 클라이언트와 연결을 해버리면 접속 대기 역할을 수행할 소켓이 사라지기 때문입니다.

또 한 가지 주목해야 할 것은 포트 번호 입니다. 포트 번호는 소켓을 식별하기 위한 값이라고 했지만, 서버에서는 같은 포트 번호를 가진 소켓이 여러 개 존재하는 상태가 됩니다. 접속 대기 소켓의 포트 번호를 80번으로 지정해놨으면 그것을 통해 복제되는 소켓의 포트 번호도 80번으로 설정하게 됩니다. 그렇게 하지 않고 새로운 포트 번호로 설정을 해서 응답을 하면 클라이언트 입장에서 접속 패킷을 보낸 상대로부터 온 응답인지, 다른 상대로부터 잘못된 패킷이 온 것인지 판별할 수가 없기 때문입니다. 그런데 포트 번호를 80번으로 설정한 소켓이 여러 개 존재하면 서버 입장에서도 문제 입니다. 클라이언트로부터 패킷을 받아도 어떤 소켓과 대화하고 있는지 판별할 수 없기 때문입니다. 그래서 이 문제를 해결하기 위해서 **소켓을 지정할 때는 추가적으로 서버의 IP 주소, 클라이언트의 IP 주소, 클라이언트의 포트 번호를 함께 기록**합니다. 클라이언트 측은 소켓을 생성할 때마다 포트 번호를 다 다르게 생성하기 때문에 서버 측에서 함께 기록해두면 클라이언트의 포트 번호로 소켓 식별이 가능해집니다. 그렇지만 여러 클라이언트로부터 요청을 받기 때문에 클라이언트 포트 번호가 겹칠 가능성도 있기에 이럴 때는 클라이언트의 IP 주소로 서버 측의 소켓을 식별하게 됩니다.

### 서버의 수신 동작

그럼 이제 클라이언트가 보낸 패킷이 서버에 도착한 순간부터 다시 살펴보겠습니다.

#### LAN 어댑터의 수신 동작

MAC 부분은 먼저 신호 형태의 패킷을 디지털 데이터로 변환하고 패킷의 맨 마지막에 있는 FCS(프레임 체크 시퀀스)를 통해 오류가 있는지 확인합니다. 오류가 없는 것을 확인했으면 이더넷의 규칙에 따라 MAC 헤더에 있는 수신처 MAC을 조사하여 패킷이 자신에게 온 것인지 확인하고 그렇지 않으면 패킷을 버립니다. 그리고 패킷은 LAN 어댑터의 버퍼 메모리에 저장합니다.

이때 CPU는 다른 일을 수행하고 있기 때문에 패킷의 도착을 알지 못합니다. 그래서 수신 처리를 위해 인터럽트를 하여 LAN 어댑터에서 CPU로 패킷의 도착을 알립니다. 그럼 CPU는 LAN 드라이버를 실행하고 LAN 드라이버가 버퍼 메모리에서 패킷을 추출하고 MAC 헤더의 타입 필드의 값에 따라 프로토콜을 판별하고 OS가 그 프로토콜을 처리하는 소프트웨어를 호출합니다. 일반적으로 IP 프로토콜이기에 TCP/IP의 프로토콜 스택을 호출하고 여기에 패킷 전달을 합니다.

#### IP 담당 부분의 수신 동작

IP 담당 부분은 IP 헤더를 보고 내용에 오류가 없는지 점검하고 수신처 IP 주소가 자신에게 온 것인지 확인합니다. 만약 해당 서버가 라우터 역할을 겸하고 있으면 자신이 중계처가 될 수도 있는 것이기 때문에 수신처 IP 주소가 자신의 IP 주소가 아니면 라우팅 테이블을 통해 중계 대상을 정해서 패킷 중계를 합니다.

만약 자신을 대상으로 한 것이면 그 다음으로는 패킷이 조각화된 것인지 확인합니다. 만약 조각화가 된 경우 패킷을 메모리에 저장해두고 모든 조각이 도착했을 때 원래 패킷으로 복원을 합니다.

그 다음으로 IP 헤더의 프로토콜 번호를 조사해서 적절한 담당 부분에게 패킷을 전달합니다. 번호가 06이면 TCP, 11이면 UDP로 전달하게 될 것입니다. 이 뒤에서는 TCP로 전달하는 것으로 가정하겠습니다.

#### TCP 담당 부분의 접속, 데이터, 연결 끊기 수신 동작

TCP 담당 부분은 TCP 헤더의 컨트롤 비트에 어떤 값이 세팅되어있는지에 따라 동작이 달라지기 때문에 하나씩 살펴보겠습니다.

먼저 접속 패킷을 수신했을 때의 동작입니다. SYN 비트가 1로 되어있는 경우로 먼저 TCP 헤더의 수신처 포트 번호를 조사하여 이 번호와 동일한 번호를 할당한 접속 대기 상태의 소켓이 있는지 확인하고 존재하지 않으면 오류 통지 ICMP 패킷을 클라이언트에 반송합니다. 접속 대기 소켓이 있으면 패킷을 복사하여 새 소켓을 만들고 그 소켓에 송신처의 IP 주소와 포트번호, 시퀀스 번호 초기값, 윈도우 값 등의 제어 정보를 기록합니다. 그리고 송신 버퍼, 수신 버퍼용 메모리를 확보합니다. 그리고 ACK 번호, 서버에서 클라이언트로 보낼 시퀀스 번호 초가값, 윈도우 값을 기록한 TCP 헤더를 만들어서 IP 부분에 의뢰하여 반송합니다.
패킷을 받은 클라이언트는 다시 패킷을 받았음을 나타내는 ACK 번호를 서버에 보낼 것이고 이렇게 접속 동작은 마무리됩니다.

이번에는 데이터를 송/수신하는 과정에서의 동작을 살펴봅니다. 우선 도착한 패킷이 어느 소켓에 해당하는지 조사합니다. 접속이 끝난 소켓은 서버측 포트 번호가 같은 소켓이 여러 개일 수 있기 때문에 IP 헤더의 송신처 IP 주소와 수신처 IP 주소, TCP 헤더의 송신처 포트 번호와 수신처 포트 번호를 모두 이용하여 소켓을 찾습니다.
소켓을 찾았으면 소켓에 기록되어 있는 데이터 송/수신의 진행 상황과 도착한 패킷의 TCP 헤더의 정보를 결합하여 데이터 송/수신 동작이 올바르게 진행되는지 점검합니다. 소켓에 기록된 지난 번 시퀀스 번호나 지난 번 데이터 조각의 길이로부터 다음 시퀀스 번호 값을 구하고 도착한 패킷의 TCP 헤더의 시퀀스 번호와 합치하는지 조사하는 것입니다.
그 다음으로는 패킷에서 데이터 조각을 추출하여 수신 버버에 저장합니다. 이전 패킷에서 수신한 데이터 조각의 뒤에 이어 붙여서 데이터를 분할 전의 상태로 되돌립니다. 수신 버퍼에 데이터를 저장하면 수신 확인 응답용 TCP 헤더를 만듭니다. 수신 패킷의 시퀀스 번호와 데이터의 길이를 합쳐서 ACK 번호를 기록하여 IP 담당 부분에 의뢰하여 클라이언트로 반송합니다.
TCP 담당의 역할은 여기서 끝나고 이후에는 애플리케이션이 Socket라이브러리의 read를 호출하여 수신 버퍼의 데이터를 전달받게 됩니다. 보통은 데이터 패킷이 도착하기 전에 애플리케이션이 먼저 read를 호출하는데 이때 애플리케이션은 데이터의 도착을 기다리는 상태가 됩니다. 이때는 TCP 담당 부분의 수신 동작이 끝남과 동시에 애플리케이션에 데이터를 전달해주는 동작이 시작됩니다.

이번에는 연결 끊기 동작을 살펴보겠습니다. 이때의 동작은 클라이언트측과 완전히 동일합니다. 클라이언트와 서버 중 누가 먼저 끊기를 시작해도 무관합니다. 만약 서버가 먼저 끊는다면 서버측 애플리케이션이 Socket 라이브러리의 close를 호출하고 TCP 담당 부분이 FIN 비트를 세팅한 TCP 헤더를 만들고 IP 담당 부분에 의뢰하여 클라이언트로 보냅니다. 클라이언트가 ACK 번호를 반송하고, 마찬가지로 close를 호출하여 FIN을 1로 세팅한 TCP 헤더를 서버로 보내게 되고 서버도 ACK 번호를 반송하면서 끝나게 됩니다. 그리고 잠시 기다렸다가 소켓을 말소합니다.
