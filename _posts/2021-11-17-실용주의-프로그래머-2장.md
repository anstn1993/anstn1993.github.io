---
layout: post
title: 실용주의 프로그래머 2장 # Title of the page
hide_title: false # Hide the title when displaying the post, but shown in lists of poststhumbnail: "assets/img/thumbnails/sample-th.png"  # Add
color: brown # Add the specified color as feature image, and change link colors in post
author: "Mun Soo Kim"
tags: [기술]
---

앤드류 헌트, 데이비드 토머스의 [실용주의 프로그래머]라는 책을 읽고 개인적으로 정리한 포스트 입니다. '2장 실용주의 접근법'을 정리했습니다.

# 2장. 실용주의 접근법

---

### 7. 중복의 해악

우리가 만드는 소프트웨어는 계속해서 변합니다. 설계가 바뀔 수도 있고, 개발 중간에 요구사항이 변하거나, 새로운 요구사항이 도착할 수도 있습니다. 이에 대응하는 일련의 과정이 유지보수가 되는데, 이 유지보수를 방해하는 것이 바로 **중복**입니다. 유지보수를 쉽게 하려면 **DRY(Don't Repeat Yourself) 원칙**을 지켜야 합니다.

중복은 대부분 다음 범주 중 하나에 속합니다. 각 범주를 살펴보고 해결 방법도 살펴보겠습니다.

- 강요된 중복: 환경에 의한 중복입니다. 문서의 내용 자체가 코드의 중복을 요구하는 것처럼 보일 수 있습니다. 때로는 프로그래밍 언어 자체가 중복된 구조를 강제할 수도 있습니다. 이런 문제를 해결하기 위해서 다음을 지킵시다.
  - 주석의 내용으로 코드의 구현이 아닌 역할을 기술합시다. 구현을 적게 되면 필연적으로 중복되는 내용이 생기게 되고 변화가 생길 때마다 함께 바뀌어야 할 것입니다.
  - 문서와 코드를 동기화합시다. 일정의 압박에 시달리기 시작하면 코드 변경에 대한 문서 갱신이 뒤로 미루어지는데 그러지 맙시다!
    <br>
- 부주의한 중복: 설계 실수로 나타난 중복입니다. 가령 선을 담당하는 클래스를 만들 때, 속성으로 선의 길이를 포함할 수 있을 것입니다. 하지만 잘 생각해보면 선은 두 점을 통해 계산되는 값이기 때문에 함수로 빼는 것이 맞습니다. 즉 선을 속성으로 가지는 것은 두 점으로 구할 수 있는 속성을 중복으로 가지는 것입니다.
  <br>
- 참을성 없는 중복: 일정의 압박 속에서 이미 존재하는 비슷한 로직에서 살짝만 수정해서 빨리 구현을 할 수 있을 때 발생할 수 있는 중복입니다. 하지만 지금 당장 몇 초를 절약하려고 하다가 필히 나중에 몇 시간을 잃게 될 것입니다. 급할수록 돌아갑시다!
  <br>
- 개발자간의 중복: 서로 다른 개발자가 같은 기능을 각자 개발해서 발생하는 중복입니다. 이 문제를 해결하기 위해 다음을 지킵시다.
  - 개발자간에 적극적이고 빈번한 소통을 장려해야 합니다. 서로가 서로의 문서와 소스코드를 읽도록 장려해야 합니다. 서로가 만든 기존의 것을 찾아서 재사용도록 해야 합니다.

여러 중에 부주의한 중복, 참을성 없는 중복, 개발자간의 중복은 읽으면서 크게 공감했습니다. 특히 개발자간의 중복 문제는 작업을 하면서도 최대한 발생하지 않게 하기 위해서 작업 시작 전에 최대한 비슷한 기능을 하는 유틸리티, 서비스 코드가 있는지 찾아보는데 그래도 중복이 발생하고 있을지도 모르겠습니다. 위 내용들을 명심하고 최대한 중복이 발생하지 않게 노력해야겠습니다!

### 8장. 직교성

기하학에서 두 직선이 직각으로 만난다는 의미를 가지는 직교성은 프로그래밍에서는 독립성을 높이고 컴포넌트 간의 상호 의존성을 낮추는 것을 의미합니다. 이는 한 컴포넌트의 변화가 다른 컴포넌트들에 영향을 미치지 않는 것을 의미합니다. 직교적인 시스템을 구성하면 **테스트의 용이함**, **재사용성의 증가**와 같은 생선성 증가와 **나쁜 코드가 전염되지 않게 격리**하고 특정 벤터, 플랫폼에 덜 종속적이게 되는 리스크 감소라는 장점을 취할 수 있습니다.

설계를 할 때는 레이어식 접근을 통해 직교성을 높일 수 있습니다. 각 레이어들별로 추상화된 기능을 담당하여 하위의 구현을 바꾸더라도 상위 레이어에 변화를 유발하지 않도록 구성할 수 있습니다. 웹 개발에서도 항상 적용되고 있는 mvc 패턴이 대표적인 사례입니다. 코드를 작성할 때는 코드 간의 결합도를 낮추고 전역 데이터는 지양하고 유사한 기능을 하는 함수는 재사용성을 높여 중복을 줄여야 합니다.

### 9장. 가역성

우리가 만드는 소프트웨어는 항상 변하는 생물과 같기 때문에 그런 변화에 유연하게 대처할 수 있도록 항상 대비해야 합니다. 가역성이 높다는 것은 결국 변화가 요구될 때 그 요구를 쉽게 받아들이고 해결할 수 있음을 의미합니다. 예를 들어 중간에 데이터베이스가 변하더라도 데이터베이스와 연동되는 부분을 잘 추상화해두면 데이터베이스만 가볍게 교체하고 끝날 수 있습니다. 하지만 그런 추상화 없이 코드 전반에 걸쳐 데이터베이스 연동부가 강하게 결합된다면 매우 골치아픈 작업이 되겠죠^^. 늘 **최종결정이란 없다**는 것을 명심하면서 작업을 해야겠습니다.

### 10장. 예광탄

예광탄은 일반 탄환이 목표물을 맞추기 전에 먼저 목표물로 향하는 궤적에 빛을 남기면서 목표물에 도달하는 탄환을 의미합니다. 이 예광탄 덕분에 실제 탄환이 어디에 맞게될지 알 수 있는 것이죠. 우리가 제품을 만들 때도 이런 예광탄을 유용하게 사용할 수 있습니다. 프로그래밍에서 예광탄은 최종 제품의 초기 버전 정도로 생각하면 될 것 같습니다. 이 초기버전은 전체 기능의 일부만을 지니지만 제품 전체의 구조가 잡히고 모든 모듈 간의 연동이 잘 이루어져서 **동작하는 것이 확인**된 정교한 상태입니다. 여기에 기능만 채워나간다면 결국 완성된 제품이 될 것입니다.

예광탄은 다음과 같은 장점을 지닙니다.

- 사용자들에게 뭔가 작동하는 제품을 매우 일찍부터 보여줄 수 있습니다. 이는 사용자들에게 시기별로 얼마나 최종 목표에 가까워졌는지를 매우 가시적으로 보여줄 수 있기에 그들로 하여금 관심도를 끌어올릴 수 있습니다.

- 개발자들에게 구조를 제공합니다. 애플리케이션의 모든 요소들 간 상호작용을 구성해두었기 때문에 개발자는 필요한 구역으로 가서 기능만 채우면 됩니다.

- 통합 작업을 수시로 쉽게 수행할 수 있습니다. 이미 모든 요소들이 통합된 상태이기 때문에 새롭게 추가된 기능을 하루에도 여러번 통합할 수 있습니다. 이렇게 자주자주 통합작업이 이루어지면 작은 단위의 기능 변화가 시스템 전체에 어떤 변화를 주는지를 더 명확하게 볼 수 있게 됩니다. 그래서 디버깅과 테스트 속도는 자연스럽게 더 빠르고 정확해질 것입니다.

이렇게 보고나면 프로토타입이 떠오를 수 있는데, 프로토타입과 예광탄은 엄연히 다르다고 합니다. 예광탄은 실제 제품까지 사용될 코드인 반면 프로토타입은 최종 제품에 대한 특정한 측면을 평가하고 측정하기 위해 일시적으로 사용되고 버려지는 코드입니다. 즉 프로토타입은 예광탄이 발사되기 전에 선행되는 정찰과 정보 수집 행위 정도로 생각하면 됩니다.

예광탄을 읽다보니 스프링과 같은 프레임워크가 결국 예광탄이 아닐까라는 생각이 들었습니다. 요즘에는 잘 만들어진 예광탄들이 넘쳐나니 감사하면서 개발해야할 것 같습니다!

### 11장. 프로토타입과 포스트잇

앞서 살펴봤지만 프로토타입을 만드는 것은 시스템 전반의 위험 요소를 조기에 분석해서 매우 저렵한 비용으로 바로잡을 기회를 얻기 위해 필요합니다. 프로토타입은 전체 시스템 중 특정 영역에 대한 검증을 위해 만들어지는 것이기 때문에 그 영역을 제외한 나머지에 대해서는 정교함을 요구할 필요가 없습니다. 만약 나머지에 대해서도 정교함을 가하고 있다면 그것은 프로토타입이 아닐 가능성이 높습니다. 프로토타입을 만들 때는 다음의 세부사항은 무시해도 됩니다.

- 정확성: 더미데이터를 사용해도 됩니다.
- 완전성: 제한된 기능만 제공하면 됩니다.
- 안정성: 에러에 대한 대비를 할 필요가 없습니다. 정해진 시나리오대로 실행시키지 않았을 때 와장창 깨지더라도 상관없습니다.
- 스타일: 프로토타입 코드에 대한 주석, 문서를 만들 필요는 없습니다.

프로토타입은 꼭 코드로 만들 필요는 없습니다. 전체 시스템의 아키텍처를 프로토타이핑할 때는 화이트보드, 포스트잇을 사용하는 것만으로도 충분할 때가 많습니다.

### 12장. 도메인 언어

특정 언어를 선택한다는 것은 그 언어적 특성이 사고방식과 의사소통에 영향을 미치는 것을 의미합니다. 이보다는 도메인의 언어를 이용해서 프로그래밍는 것을 고려해볼 수 있습니다. 여차하면 특정 애플리케이션 도메인에 맞추어진 소형 언어를 만들 수도 있습니다. 개발자 스스로에게 도메인에 더 밀접하게 일할 수 있는 도구를 스스로에게 제공합시다.

### 13장. 추정

프로젝트를 진행을 하다보면 일정 추정, 성능에 대한 추정과 같은 다양한 추정을 하게 됩니다. 하지만 이 추정을 정확히 해낸다는 것은 사실 불가능에 가깝습니다. 다만 누가 더 근사치에 가까울지가 다를 뿐이죠. 하지만 추정을 잘 할 수 있는 방법들은 존재합니다.

- 추정을 할 때 양을 표현하는 단위를 신중하게 선택합시다. 예를 들어 어떤 일을 끝내는 데 180일이 걸린다고하면 듣는 이의 입장세너는 가까운 시일 내에 끝날 것이라고 생각하고 정확한 일정이라는 기대를 하게 됩니다. 하지만 그것을 6개월이 걸린다고 바꿔서 말하면 180일보다 대략적이고 유동적인 느낌을 주게 됩니다.

- 이미 그 일을 해본 사람에게 물어봅시다. 과거에 비슷한 상황에 처했던 사람이 있다면 그 사람들의 경험을 통해 상당히 성공적인 추정치를 도출해낼 수 있습니다.

- 시스템의 모델을 만들어봅시다. 가령 응답시간을 추정하고 있다면 몇 가지 트래픽 모델을 만들어보는 겁니다. 모델을 만드는 과정에서 표면에 잘 드러나지 않던 패턴과 프로세스를 발견할 수도 있습니다.

- 추정치를 기록합시다. 그 값이 실제 결과에 얼마나 가까운지 평가하기 위함입니다. 이렇게 추정치와 실제값을 비교하다보면 생각보다 추정치가 실제값에 꽤 가갑다는 것을 인지할 것이고 점차 자신이 도출한 추정치에 대한 믿음이 생길 것입니다.

- 프로젝트 일정 추정은 해당 프로젝트를 경험하는 것 말고는 답이 없습니다. 초기에는 얼마나 많은 공수가 필요한지 감이 안 오지만 시간이 지날수록 이전 작업들의 반복을 통한 감이 생기기 때문에 점차 추정치에 대한 확신이 생길 것입니다.
