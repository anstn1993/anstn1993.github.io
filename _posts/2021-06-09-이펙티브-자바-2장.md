---
layout: post
title: 이펙티브자바 - 2장. 객체 생성과 파괴 # Title of the page
hide_title: false # Hide the title when displaying the post, but shown in lists of poststhumbnail: "assets/img/thumbnails/sample-th.png"  # Add
color: brown # Add the specified color as feature image, and change link colors in post
author: "Mun Soo Kim"
tags: [기술, 자바]
---

조슈아 블로크의 [이펙티브 자바]라는 책을 읽고 개인적으로 정리한 포스트 입니다.

# 2장. 객체 생성과 파괴

## 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라

---

정적 팩토리 메서드는 클래스의 객체를 생성해서 반환해주는 메서드로 생성자를 통해서 객체를 생성할 때와 비교해서 많은 장점들을 가집니다.

### 장점

- 메서드에 이름을 부여해서 반환되는 객체의 속성(특성)을 사용자가 파악하기 쉽게 해줍니다. 생성자로만 객체를 생성한다고 생각해 보면 생성자 오버로딩을 통해서 여러 특성을 가지는 객체를 반환할 수 있지만 그 생성자만 보고 어떤 특징을 가지는 객체인지 파악할 수는 없습니다.
  <br/>
- 호출될 때마다 새로운 인스턴스의 생성 여부를 제어할 수 있습니다. 매번 인스턴스를 새롭게 만들지 않고 이미 생성되어 있는 인스턴스를 캐싱해서 반환해줄 수 있다면, 불필요한 객체를 생성을 피할 수 있습니다. 책에서 소개하는 플라이웨이트 패턴이 이와 비슷한 방식이라고 하는데 간단하게 코드를 보겠습니다.

  ```java
  public class Person {
      private final String name;

      public Person(String name) {
          this.name = name;
      }
  }

  public class PersonFactory {
      private static final Map<String, Person> cache = new HashMap<>();

      public static Person getPerson(String name) {
          Person person = cache.get(name);

          if(person != null) {
              return person;
          }

          person = new Person(name);
          cache.put(name, person);
          return person;
      }
  }
  ```

  이름을 가지는 Person 클래스의 인스턴스를 반환해 주는 정적 팩토리 메서드가 있습니다. map에 사람의 이름을 키로 지정해서 인스턴스를 캐싱하고 클라이언트가 특정 이름에 대한 인스턴스를 요청하면 매개변수로 전달된 이름이 map에 존재하지 않는 경우에 한해서만 새로운 인스턴스를 생성해 줍니다. 이처럼 정적 팩토리 메서드는 인스턴스의 생성 여부를 유연하게 결정할 수 있게 됩니다.

<br/>

- 반환 타입의 하위 타입 객체를 반환하여 유연성을 높일 수 있습니다. 이는 정적 팩터리 메서드가 구현부에서 반환할 하위 타입을 결정할 수 있는 유연성을 가지는 것을 의미하고, api 입장에서는 구현체의 타입을 외부에 노출하지 않고도 그 구현체를 반환할 수 있게 되고 클라이언트 입장에서도 추상화된 상위 타입만 알면 되기 때문에 프로그래머의 입장에서도 인터페이스의 명세만 파악하면 됩니다. 이는 인터페이스 기반의 프레임워크를 만드는 핵심 기술이며 자바의 컬렉션 프레임워크가 대표적입니다.
  ```java
  List<Object> objects = Collections.emptyList();
  ```
  emptyList()라는 팩토리 메서드가 List 인터페이스의 구현체를 반환하더라도 실제 인스턴스의 타입은 List가 됩니다. 구현체가 클라이언트에 노출되지 않기 때문에 이후 jdk 버전에서 구현체가 교체되어야 하는 등의 변화가 발생해도 클라이언트의 코드에는 영향을 주지 않습니다. 객체 지향의 원칙 중 기능을 구현하는 쪽의 확장에는 열려있고, 기능을 사용하는 쪽의 변경에는 닫혀있는 개방-폐쇄의 원칙을 아주 잘 보여주는 케이스인 것 같습니다.
  <br/>
- 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있습니다. 이는 바로 위의 장점과 맥을 같이하는데, 매개변수에 따라 반환할 하위 타입을 결정할 수 있다는 것을 의미합니다.
  <br/>
- 정적 팩토리 메서드를 작성하는 시점에는 반환 타입의 클래스가 존재하지 않아도 됩니다. jdbc를 통해서 살펴보면 실제로 어떤 db에 대한 Driver인지와는 무관하게 DriverManger를 통해서 Connection 객체를 반환받아서 사용할 수 있습니다.

### 단점

- 정적 팩토리 메서드만으로 인스턴스 생성을 강제하게 되면 해당 클래스 상속은 불가능해집니다. 상속을 하려면 public, protected 수준의 생성자가 존재해야 하는데 사실 정적 팩토리 메서드를 쓰겠다는 건 생성자를 통한 생성은 지양하겠다는 것을 의미하기 때문에 결국 상속과는 상충될 수밖에 없습니다. 하지만 상속보다 조립을 유도하게 된다는 점에서는 장점이라고 볼 수도 있습니다.
  <br/>
- 정적 팩토리 메서드를 프로그래머가 찾기 어렵습니다. 생성자는 해당 클래스의 명세에 다 나와있기에 찾기 쉽지만 팩토리 메서드는 별도로 찾아봐야 하는 수고를 해야 합니다. 그래서 문서화를 잘 해두고 메서드의 이름을 통해서 의미 전달이 잘 되도록 해야 합니다.

## 아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라

---

생성자나 정적 팩토리 메서드나 입력받는 매개변수가 많은 경우 생성자 오버로딩을 통해 점층적 생성자 패턴으로 매개변수의 조합을 늘려갈 수 있지만, 클라이언트 입장에서는 자신에게 필요한 생성자를 찾는 것이 쉽지 않습니다. 특히 매개변수의 모든 값들이 필수가 아니고 타입이 동일한 경우 더더욱 그렇습니다. 필수가 아닌 값에는 임의의 기본 값을 의미 없이 넣어줘야 할 수도 있고, 매개변수의 타입이 동일하면 입력의 순서가 바뀌거도 컴파일 레벨에서는 문제가 없다가 런타임에 오류가 발생할 수도 있습니다.

setter를 이용한 자바 빈즈 패턴을 이용하면 점층적 생성자 패턴과 달리 어떤 값을 세팅하는지 명확해지고 불필요한 값을 세팅해 주지 않아도 된다는 점이 장점이지만 객체가 완성되기 전까지 일관성이 무너진 상태가 되고 클래스를 불변으로 만드는 것도 불가능합니다.

빌더 패턴은 생성자의 일관성에 대한 안정성과 자바 빈즈 패턴의 가독성을 모두 갖춘 유용한 패턴입니다.

```java
public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    private NutritionFacts(Builder builder) {
        this.servingSize = builder.servingSize;
        this.servings = builder.servings;
        this.calories = builder.calories;
        this.fat = builder.fat;
        this.sodium = builder.sodium;
        this.carbohydrate = builder.carbohydrate;
    }

    public static Builder builder(final int servingSize, final int servings) {
        return new Builder(servingSize, servings);
    }

    public static class Builder {

        private final int servingSize;
        private final int servings;

        private int calories = 0;
        private int fat = 0;
        private int sodium = 0;
        private int carbohydrate = 0;

        private Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }


        public Builder calories(int var) {
            calories = var;
            return this;
        }

        public Builder fat(int var) {
            fat = var;
            return this;
        }

        public Builder sodium(int var) {
            sodium = var;
            return this;
        }

        public Builder carbohydrate(int var) {
            carbohydrate = var;
            return this;
        }

        public NutritionFacts build() {
           return new NutritionFacts(this);
        }
    }
}
```

빌더를 정적 내부 클래스로 만들고 각 멤버를 세팅하는 메서드를 멤버의 이름으로 설정해서 자바 빈즈 패턴의 장점을 취하고 최종적으로 build()를 하는 순간 생성자에 빌더 객체를 전달해서 일관성 체크를 하는 것도 가능합니다. 그뿐만 아니라 자신이 원하는 멤버만 선택적으로 세팅할 수 있습니다.

빌더 패턴은 계층적으로 설계된 클래스에도 사용하기 좋습니다. 구상 클래스들은 저마다의 빌더를 구현하여 멤버 구성의 유연성을 확보할 수 있습니다.

```java
public abstract class Pizza {
    public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUCAGE }
    final Set<Topping> toppings;

    abstract static class Builder<T extends Builder<T>> {
        EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);

        public T addTopping(Topping topping) {
            toppings.add(Objects.requireNonNull(topping));// 파라미터가 null이면 npe throw
            return self();
        }

        abstract Pizza build();

        protected abstract T self();
    }

    Pizza(Builder<?> builder) {
        toppings = builder.toppings.clone();
    }
}
```

이 클래스의 구상 클래스에서는 self() 메서드를 통해서 자기 자신을 반환하게 구현하면 됩니다.

```java
public class NyPizza extends Pizza {

    public enum Size { SMALL, MEDIUM, LARGE }
    private final Size size;

    public static class Builder extends Pizza.Builder<Builder> {
        private final Size size;

        public Builder(Size size) {
            this.size = Objects.requireNonNull(size);
        }

        @Override
        NyPizza build() {
            return new NyPizza(this);
        }

        @Override
        protected Builder self() {
            return this;
        }
    }

    private NyPizza(Builder builder) {
        super(builder);
        size = builder.size;
    }
}

public class Calzone extends Pizza {

    final boolean sauceInside;

    public static class Builder extends Pizza.Builder<Builder> {
        private boolean sauceInside;

        public Builder sauceInside() {
            sauceInside = true;
            return this;
        }

        @Override
        Calzone build() {
            return new Calzone(this);
        }

        @Override
        protected Builder self() {
            return this;
        }
    }

    Calzone(Builder builder) {
        super(builder);
        sauceInside = builder.sauceInside;
    }
}
```

두 개의 구상 클래스가 있는데 뉴욕 피자는 Size를, 칼초네 피자는 sauceInside라는 멤버를 가집니다. 각 클래스의 build() 메서드를 보면 추상 타입인 Pizza가 아닌 MyPizza, Calzone를 반환하게 됩니다. 이처럼 하위 클래스의 메서드가 상위 클래스의 메서드가 정의한 반환 타입이 아닌 하위 타입으로 반환하는 것을 '공변 반환 타이핑
'이라고 합니다.

빌더패던이 무조건 좋은 건 아닙니다. 우선 빌더를 만들어야 하기 때문에 생성 비용이 크진 않지만 존재하고 성능에 민감한 상황에서는 문제가 될 수 있습니다. 또 매개변수가 4개 이상은 되어야 값어치를 합니다.

## 아이템 3. private 생성자나 열거타입으로 싱글턴임을 보장하라

---

싱클턴을 만드는 방식은 보통 둘 중 하나 입니다. 두 방식을 살펴보고 그보다 더 좋은 방식인 열거타입으로 만드는 싱클턴을 살펴보겠습니다.

#### 1. public static final 멤버

```java
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();

    private Elvis() {
        ...
    }

    ...
}
```

생성자를 private로 만들고 INSTANCE가 초기화될 때 딱 한 번만 호출되게끔 의도한 코드입니다. 이 방식의 장점은 해당 멤버가 싱글턴임이 api에 명확하게 드러난다는 점입니다.

하지만 리플렉션인 AccessibleObject.setAccessible을 이용하면 private 생성자도 호출이 가능합니다.

```java
Constructor constructor = INSTANCE.getClass().getDeclaredConstructor(new Class[0]);
constructor.setAccessible(true);

Elvis elvis2 = (Elvis) constructor.newInstance();
```

이 공격을 방어하려면 생성자가 호출될 때 검사를 통해서 두 번째 객체가 생성되려고 할 때 예외를 던지면 됩니다.

#### 2. public static getInstance 메서드

```java
public class Elvis {
   private static final Elvis INSTANCE = new Elvis();

   private Elvis() {
       ...
   }

   public static Elvis getInstance() {
       return INSTANCE;
   }
   ...
}
```

정적 멤버를 private로 만들고 정적 팩토리 메서드인 getInstance()로만 싱글턴 객체를 받는 방식입니다. 이 방식의 장점은 팩토리 메서드만의 변경으로 싱글턴이 아니게 바꿀 수 있다는 점입니다. 그리고 정적 팩터리 메서드 참조롤 함수형 인터페이스인 Supplier로 사용할 수 있습니다.

이 방식도 1번과 마찬가지로 리플렉션 공격으로부터 자유로울 수는 없습니다.

두 방식 모두 만약 직렬화를 제공하는 경우 역직렬화를 할 때마다 새로운 인스턴스가 만들어지게 됩니다. 그렇기 때문에 이럴 때는 readResolve() 메서드를 추가해 줍니다.

```java
private Object readResolve() {
    return INSTANCE;
}
```

일반적으로 앞선 두 방식보다는 열거형으로 싱글턴을 만드는 것이 더 좋습니다. 직렬화, 리플렉션 공격 문제로부터 완전히 자유로워지기 때문입니다.

```java
public enum Elvis {
    INSTANCE;
}
```

열거형으로 만드는 경우 클래스 상속은 불가능하지만 인터페이스 구현은 가능합니다.

## 아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라

---

정적 필드로만 구성된 클래스는 Arrays처럼 기본 타입 값이나 배열 관련 메서드를 모아두거나, Collections처럼 특정 인터페이스 구현체를 생성해 주는 정적 팩토리 메서드를 모아두거나, final 클래스에서 기능하는 메서드를 모아둘 때와 같은 상황에서 사용할 수 있습니다.

이런 클래스에 대해서 인스턴스를 생성할 수 있는 것은 클래스 설계 의도에 맞지 않기 때문에 인스턴스화를 막아줄 필요가 있습니다. 생성자의 접근 제어자를 private로 설정해서 막아줍니다.

```java
public class UtilityClass {
    // 인스턴스화 방지
    private UtilityClass() {
        throw new AssertionError();
    }
    ...
}
```

AssertionError를 꼭 던지지 않아도 되지만 클래스 내부에서 실수로 인스턴스를 생성하거나 있고 리플렉션 공격을 당하는 경우에 대비할 수 있습니다. 이 방식은 생성자가 private가 되기 때문에 상속도 막아줍니다.

## 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

---

대부분의 클래스는 다른 클래스에 의존하게 됩니다. 이때 테스트의 용이성, 기능의 확장성 등을 생각해 보면 의존객체를 내부에서 바로 만드는 것보단 생성자, 빌더, 정적 팩토리로 주입받는 것이 더 좋습니다.

```java
public class SpellChecker {
    private final Lexicon dictionary;

    public SpellChecker(Lexicon dictionary) {
        this.dictionary = Objects.requireNonNull(dictionary);
    }
}
```

생성자를 통해서 의존성 주입을 받았습니다. 이와 유사한 다른 방식으로는 생성자의 매개변수로 의존성 객체에 대한 팩토리 메서드를 넘겨줄 수 있습니다. 자바 8부터 제공된 함수형 인터페이스 Supplier가 대표적인 예시가 됩니다.

```java
public SpellChecker(Supplier<? extends Lexicon> dictionaryFactory) {
    this.dictionary = dictionaryFactory.get();
}
```

제네릭 타입에 한정적 와일드카드 타입을 사용해서 Lexicon의 하위 타입이라면 무엇이든 받아서 생성할 수 있습니다. 개인적인 생각으로는 이렇게 팩토리 메서드를 넘기게 되면 실제로 해당 의존성 객체가 필요한 시점에 평가를 하고 주입을 해줄 수 있기 때문에 경우에 따라서 lazy evaluation(지연 평가)의 이점도 가질 수 있다고 봅니다.

의존 객체 주입은 스프링 프레임워크의 DI 구현의 핵심이 됩니다.

## 아이템 6. 불필요한 객체 생성을 피하라

---

똑같은 기능을 하는 객체는 재사용을 하라는 의미입니다.

```java
String s = new String("이렇게 쓰지 마세요!");// 새로운 인스턴스 생성
String s = "이렇게 쓰세요!";// string pool에서 재사용
```

String 인스턴스는 무조건 두 번째 방식을 통해서 재사용하는 것이 좋습니다.

뿐만 아니라 생성 비용이 아주 비싼 객체의 경우에도 재사용을 통해서 부하를 줄이는 것이 좋습니다. 가장 대표적인 예가 정규 표현식을 검사하는 String.matches() 메서드입니다.

```java

// String.matches()
public boolean matches(String regex) {
    return Pattern.matches(regex, this);
}

//Pattern.matches()
public static boolean matches(String regex, CharSequence input) {
        Pattern p = Pattern.compile(regex);
        Matcher m = p.matcher(input);
        return m.matches();
}

// Pattern.compile()
public static Pattern compile(String regex) {
    return new Pattern(regex, 0);
}
```

String.matches()의 구현부를 보면 Pattern.matches()를 호출하고 있습니다. Pattern.matches()를 보면 Pattern.compile()메서드를 호출하는데 이 메서드에서 Pattern 인스턴스를 새로 만들고 이후 바로 gc의 대상이 됩니다. 그리고 Pattern 인스턴스는 생성 비용이 매우 비싸기 때문에 재사용이 되도록 구성하는 것이 좋습니다.

```java
public class RumanNumerals {
    private static final Pattern ROMAN = Pattern.compile("^(?=.)M*(C[MD]|D?C{0,3})"
    + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

    static boolean isRumanNumeral(String s) {
        ROMAN.matcher(s).matches();
    }
}
```

위와 같이 Pattern 인스턴스를 static final로 생성해두고 재사용이 되게 구성했습니다.

오토박싱도 불필요한 객체를 생성하는 주범이 됩니다.

```java
private static long sum() {
    Long sum = 0L;

    for(int i = 0; i < Integer.MAX_VALUE; i++)
        sum += i;

    return sum;
}
```

sum 변수를 Long으로 선언해서 반복문 안에서 += 연산이 일어날 때마다 Long 인스턴스가 계속 생성됩니다. 이럴 때는 박싱 타입보다는 기본 타입을 사용하는 것이 바람직합니다.

## 아이템 7. 다 쓴 객체 참조를 해제하라

---

자바는 c, c++과 달리 managed 언어이기 때문에 기본적으로 메모리 관리는 가비지 컬렉션이 담당하게 됩니다. 그래서 **참조를 담은 변수를 최소한으로 하여 유효범위 밖으로 잘 밀어내기만 한다면** 프로그래머가 따로 메모리 관리를 위해서 신경 쓸 일은 없습니다. 하지만 메모리를 직접 관리하는 클래스의 경우에는 메모리 누수를 의식하면서 사용하지 않는 참조에 대해서는 모두 **null 처리를 명시적으로** 해줘야 합니다. 메모리를 직접 관리하는 Stack을 보겠습니다.

```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if(size == 0)
            throw new EmptyStackException();
        return elements[--size];
    }

    private void ensureCapacity() {
        if(elements.length == size) {
            elements = Arrays.copyOf(elements, 2 * size + 1);
        }
    }
}
```

위와 같은 Stack을 사용하게 되면 pop을 하더라도 elements가 여전히 pop의 반환 객체를 참조하고 있기 때문에 gc에 의해서 수거되지 못합니다. pop() 메서드에서 다음과 같이 null 처리를 명시적으로 해줍니다.

```java
public Object pop() {
    if(size == 0)
        throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null;// 명시적으로 참조를 해제하여 gc의 수집 대상이 되게 해줌
    return result;
}
```

캐시 메모리도 메모리 누수를 일으킬 수 있습니다. 객체 참조를 캐싱한 후 객체를 다 이용한 후에도 그대로 두면서 발생하게 됩니다. 자바에서는 이에 대한 해결책으로 여러 인터페이스 구현체를 제공합니다.

#### 1. WeakHashMap

이 맵은 키가 참조형이고 이 키가 외부에서 참조되는 동안만 엔트리가 유지되면 되고 키의 외부 참조가 사라지는 순간 엔트리도 함께 지워져야 하는 제한적인 상황에서 사용할 수 있는 맵입니다.

```java
    Key key = new Key();
    Value value = new Value();
    Map<Key, Value> map = new WeakHashMap<>();
    map.put(key, value);
    System.out.println(map.containsValue(value)); // true
    key = null; // 키의 참조 해제
    System.gc();
    Thread.sleep(4000);// gc가 완료되기 전에 프로세스가 종료되지 못 하게 잠깐 sleep
    System.out.println(map.containsValue(value)); // false

```

키에 대한 참조가 해제되면 해당 키에 대한 엔트리도 map에서 제거됩니다. 그리고 WeakHashMap은 WeakReference를 기반으로 동작하기 때문에 참조가 사라지는 순간 메모리의 부족 여부와 무관하게 다음 gc에서 바로 수거가 됩니다. 리스너나 콜백을 등록만 하고 해제하지 않아서 발생하는 누수도 이 방식으로 해결할 수 있습니다. 콜백을 WeakHashMap에 저장하여 약한 참조로 만들어줍니다.

#### 2. LinkedHashMap

이 맵은 새로운 엘리먼트가 추가되면 가장 오래된 엔트리를 제거합니다.

## 아이템 8. finalizer와 cleaner 사용을 피하라

---

자바는 finalizer라는 객체 소멸자를 제공하지만 오동작, 낮은 성능 등의 이유 때문에 기본적으로 쓰지 말아야 합니다. 자바 9에서는 finalizer를 deprecated api로 지정하고 그 대안으로 cleaner를 소개하지만 이것도 여전히 예측할 수 없고, 느리고, 일반적으로 쓸 일이 없습니다. finalizer와 cleaner는 구체적으로 다음의 문제들을 가집니다.

#### 1. finalizer와 cleaner는 즉시 수행된다는 보장이 없다.

객체에 접근이 불가능해진 뒤에 finalizer나 cleaner가 언제 실행될지 알 수 없기 때문에 즉시 자원 반납을 해줘야 하는 작업을 수행하기에 적절하지 않습니다. finalizer의 경우 finalizer를 수행하는 스레드가 다른 스레드들보다 우선순위가 낮아서 대기열에서 계속 밀려날 수 있고, cleaner의 경우 스레드 제어가 되긴 하지만 결국 gc의 통제 하에 실행되기 때문에 즉각 수행은 보장되지 않습니다. 즉, 이들이 얼마나 빨리 수행될지는 gc 알고리즘에 달려있기 때문에 천차만별이고 jvm별로 gc 알고리즘이 다를 수 있기 때문에 문제가 없던 프로그램이 다른 환경에서는 큰 문제로 다가올 수 있습니다. 가령 파일 닫기 작업을 finalizer, cleaner에게 맡기면 시스템이 새로운 파일을 열지 못하는 심각한 오류를 초래할 수 있습니다. 더 심각한 문제는 사실 이들이 실행되는 것조차 보장되지 않는다는 것입니다. 즉 프로그램이 종료되어도 반드시 반납되어야 할 자원이 반납되지 않을 수도 있습니다.

#### 2. finalizer 동작 중 발생한 예외는 무시되며 처리할 작업이 남아있어도 종료된다.

cleaner의 경우 스레드의 통제권이 있기 때문에 예외 처리가 가능하지만 finalizer의 경우에는 예외를 처리할 수 없고 심지어 어떤 예외인지에 대한 경고(스택 추적 내역)도 출력해 주지 않습니다.

#### 3. finalizer, cleaner는 성능이 좋지 않다.

AutoClosable을 구현하여 try with resources를 이용하여 객체를 수거하는 경우와 비교했을 때 finalizer, cleaner는 객체 파괴에 걸리는 시간이 훨씬 깁니다.

#### 4. finalizer를 사용한 클래스는 finalizer 공격에 노출되어 보안 문제를 일으킬 수 있다.

생성자나 직렬화 과정(readResolve, readObject 메서드 내에서) 예외가 발생할 때 이 객체의 하위 클래스의 finalizer가 수행되게 할 수 있습니다. 그렇게 되면 finalizer 로직에서 정적 필드에 자신의 참조를 할당해서 gc에 의해 수집되지 않게 만들 수 있고 해당 객체의 메서드를 비정상 호출할 수 있습니다. 만약 클래스가 final이었다면 하위 클래스를 만들 수 없으니 이 문제로부터 자유롭지만 그렇지 않다면 반드시 **아무 일도 하지 않는 finalize 메서드를 만들고 final로 선언**하여 오버라이딩을 막아야 합니다.

하지만 cleaner와 finalizer가 사용될 수 있는 케이스도 있습니다. 크게 두 가지가 있습니다.

#### 1. close() 메서드를 호출하지 않는 것에 대비한 안전망 역할

자원을 소유하여 사용한 객체가 반납을 위해서 close 메서드를 호출하지 않는 경우에 대비하기 위해서 cleaner와 finalizer를 이용할 수 있습니다. 물론 앞서 살펴본 것처럼 이들이 언제 호출될지(혹은 아예 호출되지 않을지도) 모르지만 자원 회수 시도를 안 하는 것 보단 낫다는 점에서 의미가 있습니다.

#### 2. 네이티브 피어와 연결된 객체에서 네이티브 객체 회수 역할

네이티브 피어는 c, c++ 같은 외부 언어로 작성된 네이티브 메서드를 가지는 객체로 자바 객체가 기능을 위임한 객체입니다. 이 객체는 자바 객체가 아니기 때문에 gc가 그 존재를 몰라서 회수를 하지 못합니다. 이때 cleaner, finalizer를 이용해서 처리를 할 수 있습니다. 하지만 이것도 가능하면 close()를 통해서 처리하는 것을 최우선으로 고려해야 합니다.

## 아이템 9. try-finally보다는 try-with-resources를 사용하라

---

자바 7 이전까지는 Closable 인터페이스의 close() 메서드와 try/finally를 조합하여 자원을 반납해왔습니다. 하지만 이 방식에는 한 가지 문제가 있습니다. try, finally 블록 모두에서 예외가 발생하면 try 블록에서 발생한 예외가 finally 블록에서 발생한 예외로 덮어져서 try 블록에서 어떤 예외가 발생했는지 알 수 없다는 점입니다.

이 문제를 자바 7에서 나온 try-with-resources를 이용하면 해결할 수 있습니다. 자원을 사용하는 클래스에 AutoClosable 인터페이스만 구현하면 이용할 수 있습니다. 이미 자바에서 외부 자원을 사용하는 많은 클래스/인터페이스들이 Autoclosable 인터페이스를 구현해둔 상태입니다.

```java
static void copy(String src, String dst) throws IOException {
    try(InputStream in = new FileInputStream(src);
        OutputStream out = new FileOutputStream(dst)) {
        ...
    }
}
```

try-with-resources를 사용하면 코드가 훨씬 간결해지고 close() 메서드를 명시적으로 프로그래머가 호출하지 않아도 내부적으로 알아서 호출이 되고 만약 예외가 발생하더라도 close()에서 발생한 예외는 숨겨지고 try 블록 내의 예외가 출력됩니다.
